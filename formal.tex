\chapter{形式类型论 (Formal Type Theory)}
\label{cha:rules}

\index{formal!type theory|(形式!类型论|(}%
\index{type theory!formal|(类型论!形式|(}%
\index{rules of type theory|(类型论规则|(}%

正如可以在不显式使用策梅洛-弗兰克尔集合论的公理的情况下在集合论中发展数学一样，在本书中，我们在不明确提及同伦类型论形式系统的情况下，在单值基础上发展了数学。然而，\emph{拥有}对同伦类型论作为一个形式系统的精确定义是很重要的，例如，为了

\begin{itemize}
  \item 陈述并证明其元理论性质，包括逻辑一致性，
  \item 构造模型，例如在单纯集合、模型范畴、更高拓扑斯等中，\item 将其在 \Coq 或 \Agda 等证明助手中实现。
  \index{proof!assistant证明!助手}
\end{itemize}
%
即使是同伦类型论的逻辑一致性\index{consistency一致性}，即在空上下文中没有术语 $a:\emptyt$，也是不明显的：如果我们错误地选择了一个定义，使得 $\eqv{\emptyt}{\unit}$，那么单值性将暗示 $\emptyt$ 有一个元素，因为 $\unit$ 有一个元素。我们的 $\Sn^1$ 作为一个高阶归纳类型的定义是否能够表现得像普通的圆，也是不明显的。

在处理这些问题之前，我们必须明确类型论的两个方面。回想一下，在引言中我们提到，类型论包含一组规则，用来规定何时判断 $a:A$ 和 $a\jdeq a':A$ 成立——例如，积的规则是：当 $a:A$ 和 $b:B$ 时，$(a,b):A\times B$。要使这一点精确，我们首先必须精确定义术语的语法——这些判断所涉及的对象 $a,a',A,\dots$；然后，我们必须精确定义判断及其推理规则——即如何从其他判断中推导出判断。

在本附录中，我们将介绍 Martin-L\"{o}f 类型论及构成同伦类型论的扩展的两种表述。第一种表述 (\cref{sec:syntax-informally}) 描述了作为无类型 $\lambda$-演算扩展的术语的语法和判断的形式，而推理规则则保持非正式状态。第二种表述 (\cref{sec:syntax-more-formally}) 以自然演绎的方式递归地定义了术语、判断和推理规则，这在许多类型论文献中是常见的做法。

\section*{预备知识 (Preliminaries)}
\label{sec:formal-prelim}

在 \cref{cha:typetheory} 中，我们介绍了类型论的两个基本\define{判断 (judgments)}\index{judgment判断}。第一个判断 $a:A$ 断言一个术语 $a$ 具有类型 $A$。第二个判断 $a\jdeq b:A$ 断言两个术语 $a$ 和 $b$ 在类型 $A$ 下是\define{判断等同的 (judgmentally equal)}\index{equality!judgmental等同性!判断上的}\index{judgmental equality判断等同性}。这些判断是由 \cref{sec:syntax-more-formally} 中描述的一组推理规则递归定义的。

构造类型 $A$ 的元素 $a$ 就是推导出 $a:A$；在本书中，我们给出了描述 $a$ 构造的非正式论证，但在正式场合中，必须具体指定一个术语 $a$ 以及 $a:A$ 的完整推导。

然而，本书中的类型论表述与本附录中的表述之间的主要区别在于，这里判断是在显式的\define{上下文 (context)}\index{context上下文}中进行表述的，或假设的列表，形式为
\[
  x_1:A_1, x_2:A_2,\dots,x_n:A_n.
\]
上下文中的元素 $x_i : A_i$ 表示变量 $x_i$ 拥有类型 $A_i$ 的假设。上下文中出现的变量 $x_1, \ldots, x_n$ 必须是不同的。我们用字母 $\Gamma$ 和 $\Delta$ 来表示上下文。

上下文 $\Gamma$ 中的判断 $a:A$ 记作
\[ \oftp\Gamma aA \]
表示在 $\Gamma$ 列出的假设下 $a:A$。当假设列表为空时，我们仅写作
\[ \oftp{}aA \]
或
\[ \oftp\emptyctx aA \]
其中 $\emptyctx$ 表示空上下文。相同的适用于等同性判断
\[
  \jdeqtp\Gamma{a}{b}{A}
\]

然而，这些判断只有在\define{上下文良构 (well-formed)}\index{context!well-formed上下文!良构}时才有意义，这一概念由我们最后的判断表达
\[
  \wfctx{(x_1:A_1, x_2:A_2,\dots,x_n:A_n)}
\]
表示在上下文 $x_1:A_1, x_2:A_2,\dots,x_{i-1}:A_{i-1}$ 中，每个 $A_i$ 都是一个类型。因此，特别地，如果 $\oftp\Gamma aA$ 且 $\wfctx\Gamma$，那么我们知道每个 $A_i$ 仅包含变量 $x_1,\dots,x_{i-1}$，而 $a$ 和 $A$ 仅包含变量 $x_1,\dots,x_n$。
\index{variable!in context变量!在上下文中}

在非正式的数学表述中，上下文是隐含的。在证明的每个阶段，数学家都知道哪些变量是可用的，以及它们的类型是什么，要么是基于历史惯例（$n$ 通常是一个数，$f$ 是一个函数，等等），要么是因为变量是通过类似“设 $x$ 为一个实数”这样的句子明确引入的。我们将在 \cref{sec:more-formal-pi,sec:more-formal-sigma} 中讨论使用显式上下文的一些好处。

我们用 $B[a/x]$ 表示术语 $a$ 代替术语 $B$ 中自由出现的变量 $x$ 的\define{替换 (substitution)}\index{substitution替换}，同时可能会进行避免捕获的绑定变量重命名\index{variable!and substitution变量!与替换}\index{variable!bound变量!绑定的}，如 \cref{sec:function-types} 中所讨论。替换的一般形式
%
\[
  B[a_1,\dots,a_n/x_1,\dots,x_n]
\]
%
将表达式 $a_1,\dots,a_n$ 同时替换为变量 $x_1,\dots,x_n$。

\define{在表达式 $B$ 中绑定变量 $x$ (bind a variable $x$ in an expression $B$)}\indexdef{variable!bound变量!绑定}意味着将两者结合到一个更大的表达式中，称为\define{抽象 (abstraction)}\indexdef{abstraction抽象}，其目的是表达 $x$ 是“局部的”于 $B$，即不应与其他地方出现的 $x$ 混淆。绑定变量对程序员来说是熟悉的，但对数学家来说却不那么熟悉。绑定有各种记法，例如 $x \mapsto B$、$\lam x B$ 和 $x \,.\, B$，具体情况视场景而定。我们可以用 $C[a]$ 表示在抽象表达式中将术语 $a$ 替换为变量的替换，即我们可以定义 $(x.B)[a]$ 为 $B[a/x]$。如 \cref{sec:function-types} 中所讨论的，改变一个表达式内的绑定变量名（“$\alpha$-转换”）\index{alpha-conversion@$\alpha $-conversion $\alpha$-转换}不会改变表达式。因此，非常精确地说，一个表达式是一个语法形式的等价类，它们在绑定变量名上有所不同。

我们还可以认为判断
\[
  x_1:A_1, x_2:A_2,\dots,x_n:A_n \vdash a : A
\]
中的每个变量 $x_i$ 都绑定在其\define{作用域 (scope)}\indexdef{variable!scope of变量!作用域的}\index{scope作用域}中，该作用域由表达式 $A_{i+1}, \ldots, A_n$、$a$ 和 $A$ 组成。
\section{第一次表述 (The First Presentation)}
\label{sec:syntax-informally}

我们的类型论中的对象和类型可以使用以下语法作为术语来表示，这是一种扩展了$\lambda$-演算的语法，包含了\emph{变量} $x, x',\dots$、
\index{variable变量}%
\emph{原始常量 (primitive constants)}
\index{primitive!constant原始!常量}%
\index{constant!primitive常量!原始的}%
$c,c',\dots$、\emph{定义常量 (defined constants)}\index{constant!defined常量!定义的} $f,f',\dots$ 以及术语形成操作：
%
\[
  t \production x \mid \lam{x} t \mid t(t') \mid c \mid f
\]
%
此处使用的符号表示术语 $t$ 要么是变量 $x$，要么是形式为 $\lam{x} t$ 的表达式，其中 $x$ 是一个变量，$t$ 是一个术语；或者它是形式为 $t(t')$ 的表达式，其中 $t$ 和 $t'$ 都是术语；或者它是一个原始常量 $c$；或者它是一个定义常量 $f$。语法标记 '$\lambda$'、'('、')' 和 '.' 是为了指导人的眼睛的标点符号。

我们使用 $t(t_1,\dots,t_n)$ 作为重复应用 $t(t_1)(t_2)\dots (t_n)$ 的缩写。我们还可以使用\emph{中缀 (infix)}\index{infix notation中缀符号}表示法，当 $\star$ 是一个原始或定义的常量时，写作 $t_1\;\star\;t_2$ 表示 $\star(t_1,t_2)$。

每个定义常量有零个、一个或多个\define{定义方程 (defining equations)}。
\index{equation, defining方程, 定义的}%
\index{defining equation定义方程}%
定义常量有两种类型。显式\index{constant!explicit常量!显式的}定义常量 $f$ 具有一个定义方程
\[ f(x_1,\dots,x_n)\defeq t,\]
其中 $t$ 不涉及 $f$。
%
例如，我们可以引入显式定义常量 $\circ$，其定义方程为
\[ \circ (x,y)(z) \defeq x(y(z)),\]
并使用中缀符号 $x\circ y$ 表示 $\circ(x,y)$。当然，这只是函数的复合。

第二种定义常量用于指定一个（参数化的）映射 $f(x_1,\dots,x_n,x)$，其中 $x$ 范围为元素由零个或多个原始常量生成的类型。对于每个这样的原始常量 $c$，都有一个形式为
\[
  f(x_1,\dots,x_n,c(y_1,\dots,y_m)) \defeq t,
\]
的定义方程，其中 $f$ 可以出现在 $t$ 中，但只能以确定方程定义了一个完全定义的函数的方式出现。这类定义函数的范例是自然数上的原始递归定义的函数。我们可以称这种函数的定义为\emph{完全递归定义 (total recursive definition)}。
\index{total!recursive definition完全!递归定义}%
在计算机科学和逻辑学中，这种在递归数据类型上定义函数的方式被称为\define{结构递归定义 (definition by structural recursion)}。
\index{definition!by structural recursion定义!通过结构递归}%
\index{structural!recursion结构!递归}%
\index{recursion!structural递归!结构的}%

\define{术语的可转换性 (Convertibility)}\index{convertibility of terms术语的可转换性}%
\index{term!convertibility of术语!可转换性}%
$t \conv t'$ 是由常量的定义方程、计算规则\index{computation rule!for function types计算规则!函数类型的}生成的等价关系
%
\[
  (\lam{x} t)(u) \defeq t[u/x],
\]
%
以及使其成为应用和$\lambda$-抽象\index{lambda abstraction@$\lambda$-abstraction $\lambda$-抽象}的\emph{同余}的规则生成的等价关系：
%
\begin{itemize}
  \item 如果 $t \conv t'$ 且 $s \conv s'$，则 $t(s) \conv t'(s')$，并且
  \item 如果 $t \conv t'$，则 $(\lam{x} t) \conv (\lam{x} t')$。
\end{itemize}
\noindent
等同性判断 $t \jdeq u : A$ 可以通过以下单一规则得出：
%
\begin{itemize}
  \item 如果 $t:A$，$u:A$，并且 $t \conv u$，那么 $t \jdeq u : A$。
\end{itemize}
%
判断等同性是一个等价关系。

注意，本节中使用的类型论与正文中使用的类型论在不包含函数的判断唯一性原则 $f \jdeq (\lam{x} f(x))$ 方面有所不同。这种等同性要求判断等同性对所涉及术语的类型敏感，因为这种等同性只有在 $f$ 被认为是一个函数时才有意义，而在本节中的可转换关系与类型无关。\cref{sec:syntax-more-formally}中的第二种表述包含了唯一性原则。


\subsection{类型宇宙 (Type Universes)}

我们假设有一个\define{宇宙 (universes)}\index{type!universe类型!宇宙}的层次结构，由原始常量表示
%
\begin{equation*}
  \UU_0, \quad \UU_1, \quad  \UU_2, \quad \ldots
\end{equation*}
%
关于宇宙的前两个规则表明它们形成了一个累积的类型层次结构：
%
\begin{itemize}
  \item $\UU_m : \UU_n$ 对于 $m < n$，
  \item 如果 $A:\UU_m$ 且 $m \le n$，那么 $A:\UU_n$，
\end{itemize}
%
第三个规则表示宇宙中的一个对象可以作为类型并在判断中出现在冒号的右边：
%
\begin{itemize}
  \item 如果 $\Gamma \vdash A : \UU_n$，并且 $x$ 是一个新变量，\footnote{“新”表示它没有出现在 $\Gamma$ 或 $A$ 中。}那么 $\vdash (\Gamma, x:A)\; \ctx$。
\end{itemize}
%
在正文中，类型 $A$ 和 $B$ 之间的等同性判断 $A \jdeq B : \UU_n$ 通常简写为 $A \jdeq B$。这是一种典型的歧义\index{typical ambiguity典型的歧义}，因为我们可以随时切换到更大的宇宙，但这不会影响判断的有效性。

以下转换规则允许我们在类型判断中用一个类型替换为与之等同的类型：
%
\begin{itemize}
  \item 如果 $a:A$ 且 $A \jdeq B$，那么 $a:B$。
\end{itemize}

\subsection{依赖函数类型 (\texorpdfstring{$\Pi$}{Π}-types)}

我们引入一个原始常量 $c_\Pi$，但将 $c_\Pi(A,\lam{x} B)$ 写作 $\tprd{x:A}B$。通过以下规则引入了关于此类表达式和形式为 $\lam{x} b$ 的表达式的判断：
%
\begin{itemize}
  \item 如果 $\Gamma \vdash A:\UU_n$ 且 $\Gamma,x:A \vdash B:\UU_n$，那么 $\Gamma \vdash \tprd{x:A}B : \UU_n$
  \item 如果 $\Gamma, x:A \vdash b:B$，那么 $\Gamma \vdash (\lam{x} b) : (\tprd{x:A} B)$
  \item 如果 $\Gamma\vdash g:\tprd{x:A} B$ 且 $\Gamma\vdash t:A$，那么 $\Gamma\vdash g(t):B[t/x]$
\end{itemize}
%
如果 $x$ 在 $B$ 中不是自由的，我们将 $\tprd{x:A} B$ 简写为非依赖函数类型 $A\rightarrow B$，并推导出以下规则：
%
\begin{itemize}
  \item 如果 $\Gamma\vdash g:A \rightarrow B$ 且 $\Gamma\vdash t:A$，那么 $\Gamma\vdash g(t):B$
\end{itemize}
使用非依赖函数类型并隐式保留上下文 $\Gamma$，可以将上述规则写成以下替代风格，我们将在附录的本节其余部分中使用：
%
\begin{itemize}
  \item 如果 $A:\UU_n$ 且 $B:A\to\UU_n$，那么 $\tprd{x:A}B(x) : \UU_n$
  \item 如果 $x:A \vdash b:B(x)$ 那么 $ \lam{x} b : \tprd{x:A} B(x)$
  \item 如果 $g:\tprd{x:A} B(x)$ 且 $t:A$ 那么 $g(t):B(t)$
\end{itemize}
%

\subsection{依赖对类型 (\texorpdfstring{$\Sigma$}{Σ}-types)}

我们引入原始常量 $c_\Sigma$ 和 $c_{\mathsf{pair}}$。形式为 $c_\Sigma(A,\lam{a} B)$ 的表达式写作 $\sm{a:A}B$，
形式为 $c_{\mathsf{pair}}(a,b)$ 的表达式写作 $\tup a b$。如果 $x$ 在 $B$ 中不是自由的，我们将 $\sm{x:A} B$ 写作 $A\times B$。

通过以下规则引入了关于此类表达式的判断：
%
\begin{itemize}
  \item 如果 $A:\UU_n$ 且 $B: A \rightarrow \UU_n$，那么 $\sm{x:A}B(x) : \UU_n$
  \item 此外，如果 $a:A$ 且 $b:B(a)$，那么 $\tup a b:\sm{x:A}B(x)$
\end{itemize}
%
如果我们有如上的 $A$ 和 $B$，$C : (\sm{x:A}B(x)) \rightarrow \UU_m$，并且
\[
  d:\tprd{x:A}{y:B(x)} C(\tup x y)
\]
我们可以引入一个定义常量
\[
  f:\tprd{p:\sm{x:A}B(x)} C(p)
\]
其定义方程为
\[
  f(\tup x y)\defeq d(x,y)。
\]
%
注意，$C$、$d$、$x$ 和 $y$ 可能包含一些额外的隐式参数 $x_1,\ldots,x_n$，如果它们是在某个非空上下文中获得的；因此，完全显式的递归模式为
%
\begin{narrowmultline*}
  f(x_1,\dots,x_n,\tup{x(x_1,\dots,x_n)}{y(x_1,\dots,x_n)}) \defeq
  \narrowbreak
  d(x_1,\dots,x_n,\tup{x(x_1,\dots,x_n)}{y(x_1,\dots,x_n)})。
\end{narrowmultline*}

\subsection{余积类型 (Coproduct Types)}

我们引入原始常量 $c_+$、$c_\inlsym$ 和 $c_\inrsym$。我们用 $A+B$ 代替 $c_+(A,B)$，用 $\inl(a)$ 代替 $c_\inlsym(a)$，用 $\inr(a)$ 代替 $c_\inrsym(a)$：
%
\begin{itemize}
  \item 如果 $A,B : \UU_n$，则 $A + B : \UU_n$
  \item 此外，$\inl: A \rightarrow A+B$ 和 $\inr: B \rightarrow A+B$
\end{itemize}
%
如果我们有上述的 $A$ 和 $B$，$C : A+B \rightarrow \UU_m$，
$d:\tprd{x:A} C(\inl(x))$ 和 $e:\tprd{y:B} C(\inr(y))$，
那么我们可以引入一个定义常量 $f:\tprd{z:A+B}C(z)$，其定义方程为
%
\begin{equation*}
  f(\inl(x)) \defeq d(x)
  \qquad\text{和}\qquad
  f(\inr(y)) \defeq e(y)。
\end{equation*}

\subsection{有限类型 (The Finite Types)}

我们引入原始常量 $\ttt$、$\emptyt$ 和 $\unit$，满足以下规则：
%
\begin{itemize}
  \item $\emptyt : \UU_0$，$\unit : \UU_0$
  \item $\ttt:\unit$
\end{itemize}

给定 $C : \emptyt \rightarrow \UU_n$，我们可以引入一个定义常量 $f:\tprd{x:\emptyt} C(x)$，没有定义方程。

给定 $C : \unit \rightarrow \UU_n$ 和 $d : C(\ttt)$，我们可以引入一个定义常量 $f:\tprd{x:\unit} C(x)$，其定义方程为 $f(\ttt) \defeq d$。

\subsection{自然数 (Natural Numbers)}

自然数的类型通过引入原始常量 $\N$、$0$ 和 $\suc$ 获得，并满足以下规则：
%
\begin{itemize}
  \item $\N : \UU_0$，
  \item $0:\N$，
  \item $\suc:\N\rightarrow \N$。
\end{itemize}
%
此外，我们可以通过原始递归定义函数。如果我们有 $C : \N \rightarrow \UU_k $，当我们有
%
\begin{align*}
  d & : C(0) \\
  e & : \tprd{x:\N}(C(x)\rightarrow C(\suc (x)))
\end{align*}
%
时，我们可以引入定义常量 $f:\tprd{x:\N}C(x)$，其定义方程为
%
\begin{equation*}
  f(0) \defeq d
  \qquqquad\text{和}\qquad
  f(\suc (x)) \defeq e(x,f(x))。
\end{equation*}

\subsection{\texorpdfstring{$W$}{W}-类型 (\texorpdfstring{$W$}{W}-Types)}

对于 $W$-类型，我们引入原始常量 $c_\wtypesym$ 和 $c_\suppsym$。
形式为 $c_\wtypesym(A,\lam{x} B)$ 的表达式写作
$\wtype{x:A}B$，形式为 $c_\suppsym(x,u)$ 的表达式写作
$\supp(x,u)$：
%
\begin{itemize}
  \item 如果 $A:\UU_n$ 和 $B: A \rightarrow \UU_n$，则 $\wtype{x:A}B(x) : \UU_n$
  \item 此外，如果 $a:A$ 和 $u:B(a)\rightarrow \wtype{x:A}B(x)$，则 $\supp(a,u):\wtype{x:A}B(x)$。
\end{itemize}
%
在这里我们也可以通过完全递归定义函数。如果我们有上述的 $A$ 和 $B$，以及 $C : (\wtype{x:A}B(x)) \rightarrow \UU_m$，那么我们可以引入一个定义常量
$f:\tprd{z:\wtype{x:A}B(x)} C(z)$，当我们有
\[
  d:\tprd{a:A}{u:B(a) \rightarrow \wtype{x:A}B(x)}((\tprd{y:B(a)}C(u(y))) \rightarrow C(\supp(a,u)))
\]
时，定义方程为
\[
  f(\supp(a,u)) \defeq d(a,u,f\circ u)。
\]

\subsection{等同类型 (Identity Types)}

我们引入原始常量 $c_\idsym$ 和 $c_{\refl{}}$。当 $a:A$ 被理解时，我们将 $\id[A] a b$ 写作 $c_\idsym(A,a,b)$，将 $\refl a$ 写作 $c_{\refl{}}(A,a)$：
%
\begin{itemize}
  \item 如果 $A : \UU_n$，$a:A$ 和 $b:A$，那么 $\id[A] a b : \UU_n$。
  \item 如果 $a:A$，那么 $\refl a :\id[A] a a $。
\end{itemize}
%
给定 $a:A$，如果 $y:A, z:\id[A] a y \vdash C : \UU_m$ 和
$\vdash d:C[a,\refl{a}/y,z]$，那么我们可以引入一个定义常量
\[
  f:\tprd{y:A}{z:\id[A] a y} C
\]
其定义方程为
\[
  f(a,\refl{a})\defeq d。
\]

\section{The second presentation}
\label{sec:syntax-more-formally}

In this section, there are three kinds of judgments 
\begin{mathpar}
\wfctx\Gamma
\and
\oftp\Gamma{a}{A}
\and
\jdeqtp\Gamma{a}{a'}{A}
\end{mathpar}
which we specify by providing inference rules for deriving them. A typical \define{inference rule}
\indexsee{inference rule}{rule}%
\indexdef{rule}%
has the form
%
\begin{equation*}
  \inferrule*[right=\textsc{Name}]
  {\mathcal{J}_1 \\ \cdots \\ \mathcal{J}_k}
  {\mathcal{J}}
\end{equation*}
%
It says that we may derive the \define{conclusion} $\mathcal{J}$, provided that we have
already derived the \define{hypotheses} $\mathcal{J}_1, \ldots, \mathcal{J}_k$.
(Note that, being judgments rather than types, these are not hypotheses \emph{internal} to the type theory in the sense of \cref{sec:types-vs-sets}; they are instead hypotheses in the deductive system, i.e.\ the metatheory.)
On the
right we write the \textsc{Name} of the rule, and there may be extra side conditions that
need to be checked before the rule is applicable.

A \define{derivation}
\index{derivation}%
of a judgment is a tree constructed from such inference
rules, with the judgment at the root of the tree. For example, with the rules given below, the following is a derivation of
$\oftp{\emptyctx}{\lamu{x:\unit} x}{\unit\to\unit}$.
%
\begin{mathpar}
\inferrule*[right=$\Pi$-\rintro]
  {\inferrule*[right=$\Vble$]
    {\inferrule*[right=\ctx-\textsc{ext}]
      {\inferrule*[right=$\unit$-\rform]
        {\inferrule*[right=\ctx-\textsc{emp}]
          {\ }
          {\wfctx {\emptyctx}}}
        {\oftp{}{\unit}{\UU_0}}}
      {\wfctx {\tmtp x\unit}}}
   {\oftp{\tmtp x\unit}{x}{\unit}}}
 {\oftp{\emptyctx}{\lamu{x:\unit} x}{\unit\to\unit}}
\end{mathpar}

\subsection{Contexts}
\label{subsec:contexts}

\index{context}%
A context is a list
%
\begin{equation*}
  \tmtp{x_1}{A_1}, \tmtp{x_2}{A_2}, \ldots, \tmtp{x_n}{A_n}
\end{equation*}
%
which indicates that the distinct variables
\index{variable}%
$x_1, \ldots, x_n$ are assumed to have types $A_1, \ldots, A_n$, respectively. The list may be empty. We abbreviate contexts with the letters $\Gamma$ and $\Delta$, and we may juxtapose them to form larger contexts.

The judgment $\wfctx{\Gamma}$ formally expresses the fact that $\Gamma$ is a well-formed context, and is governed by the rules of inference
%
\begin{mathpar}
  \inferrule*[right=\ctx-\textsc{emp}]
  {\ }
  {\wfctx\emptyctx}
\and
  \inferrule*[right=\ctx-\textsc{ext}]
  {\oftp{\tmtp{x_1}{A_1}, \ldots, \tmtp{x_{n-1}}{A_{n-1}}}{A_n}{\UU_i}}
  {\wfctx{(\tmtp{x_1}{A_1}, \ldots, \tmtp{x_n}{A_n})}}
\end{mathpar}
%
with a side condition for the second rule: the variable $x_n$ must be distinct from the variables $x_1, \ldots, x_{n-1}$.
Note that the hypothesis and conclusion of $\ctx$-\textsc{ext} are judgments of different forms: the hypothesis says that in the context of variables $x_1, \ldots, x_{n-1}$, the expression $A_n$ has type $\UU_i$; while the conclusion says that the extended context $(\tmtp{x_1}{A_1}, \ldots, \tmtp{x_n}{A_n})$ is well-formed.

It is a meta-theoretic property of the system that if any judgment of the form $\oftp{\Gamma}{a}{A}$ or $\jdeqtp\Gamma{a}{a'}{A}$ is derivable, then so is the judgment $\wfctx\Gamma$ that the context $\Gamma$ is well-formed.
The premises of all the rules are chosen to include just enough well-formedness hypotheses to make this property provable, but no more.
For instance, it is not necessary for $\ctx$-\textsc{ext} to hypothesize well-formedness of $(\tmtp{x_1}{A_1}, \ldots, \tmtp{x_{n-1}}{A_{n-1}})$, as that will follow from the derivability of its premise; but it is necessary for the $\Vble$ rule in the next section to hypothesize well-formedness of its context.
This choice is only one of the many possible ways to formulate a type theory precisely, but a detailed investigation of such issues is beyond the scope of this appendix.

\subsection{Structural rules}

\index{structural!rules|(}%
\index{rule!structural|(}%

The fact that the context holds assumptions is expressed by the rule which says that we may derive those typing judgments which are listed in the context:
%
\begin{mathpar}
  \inferrule*[right=$\Vble$]
  {\wfctx {(\tmtp{x_1}{A_1}, \ldots, \tmtp{x_n}{A_n})} }
  {\oftp{\tmtp{x_1}{A_1}, \ldots, \tmtp{x_n}{A_n}}{x_i}{A_i}}
\end{mathpar}
%
As with $\ctx$-\textsc{ext}, the hypothesis and conclusion of the rule $\Vble$ are judgments of different forms, only now they are reversed: we start with a well-formed context and derive a typing judgment.

The following important principles, called \define{substitution}
\indexdef{rule!of substitution}%
and
\define{weakening},
\indexdef{rule!of weakening}%
need not be explicitly assumed. Rather, it is possible to
show, by induction on the structure of all possible derivations, that whenever
the hypotheses of these rules are derivable, their conclusion is also
derivable.\footnote{Such rules are called \define{admissible}\indexdef{rule!admissible}\indexsee{admissible!rule}{rule, admissible}.}
For the typing judgments these principles are manifested as
%
\begin{mathpar}
  \inferrule*[right=$\Subst_1$]
  {\oftp\Gamma{a}{A} \\ \oftp{\Gamma,\tmtp xA,\Delta}{b}{B}}
  {\oftp{\Gamma,\Delta[a/x]}{b[a/x]}{B[a/x]}}
\and
  \inferrule*[right=$\Weak_1$]
  {\oftp\Gamma{A}{\UU_i} \\ \oftp{\Gamma,\Delta}{b}{B}}
  {\oftp{\Gamma,\tmtp xA,\Delta}{b}{B}}
\end{mathpar}
and for judgmental equalities they become
\begin{mathpar}
  \inferrule*[right=$\Subst_2$]
  {\oftp\Gamma{a}{A} \\ \jdeqtp{\Gamma,\tmtp xA,\Delta}{b}{c}{B}}
  {\jdeqtp{\Gamma,\Delta[a/x]}{b[a/x]}{c[a/x]}{B[a/x]}}
\and
  \inferrule*[right=$\Subst_3$]
  {\jdeqtp\Gamma{a}{b}{A} \\ \oftp{\Gamma,\tmtp xA,\Delta}{c}{C}}
  {\jdeqtp{\Gamma,\Delta[a/x]}{c[a/x]}{c[b/x]}{C[a/x]}}
\and
  \inferrule*[right=$\Weak_2$]
  {\oftp\Gamma{A}{\UU_i} \\ \jdeqtp{\Gamma,\Delta}{b}{c}{B}}
  {\jdeqtp{\Gamma,\tmtp xA,\Delta}{b}{c}{B}}
\end{mathpar}
%
In addition to the judgmental equality rules given for each type former, we also
assume that judgmental equality is an equivalence relation respected by typing.
\begin{mathparpagebreakable}
  \inferrule*{\oftp\Gamma{a}{A}}{\jdeqtp\Gamma{a}{a}{A}}
\and
  \inferrule*{\jdeqtp\Gamma{a}{b}{A}}{\jdeqtp\Gamma{b}{a}{A}}
\and
  \inferrule*{\jdeqtp\Gamma{a}{b}{A} \\ \jdeqtp\Gamma{b}{c}{A}}{\jdeqtp\Gamma{a}{c}{A}}
\and
  \inferrule*{\oftp\Gamma{a}{A} \\ \jdeqtp\Gamma{A}{B}{\UU_i}}{\oftp\Gamma{a}{B}}
\and
  \inferrule*{\jdeqtp\Gamma{a}{b}{A} \\ \jdeqtp\Gamma{A}{B}{\UU_i}}{\jdeqtp\Gamma{a}{b}{B}}
\end{mathparpagebreakable}
%
Finally, we assume that judgmental equality is a congruence respected by typing,
i.e., that each type and term-former preserves judgmental equality in each of
its arguments. For instance, along with the $\Pi$-\rintro\ rule, we assume the
rule
\[
  \inferrule*[right=$\Pi$-\rintro-eq]
  {\oftp\Gamma{A}{\UU_i} \\
   \oftp{\Gamma,\tmtp xA}{B}{\UU_i} \\
   \jdeqtp{\Gamma,\tmtp xA}{b}{b'}{B}}
  {\jdeqtp\Gamma{\lamu{x:A} b}{\lamu{x:A'} b'}{\tprd{x:A} B}}
\]
Completing the case of dependent function types, two similar rules,
$\Pi$-\textsc{form-eq}\ and $\Pi$-\textsc{elim-eq}, are assumed.
Taken together, these local principles (at every type) imply the global congruence principles
$\Subst_2$ and $\Subst_3$ above. We will omit these local rules for brevity.

\index{rule!structural|)}%
\index{structural!rules|)}%

\subsection{Type universes}

\index{type!universe}%

We postulate an infinite hierarchy of type universes
%
\begin{equation*}
  \UU_0, \quad \UU_1, \quad  \UU_2, \quad \ldots
\end{equation*}
%
Each universe is contained in the next, and any type in $\UU_i$ is also in $\UU_{i+1}$:
%
\begin{mathpar}
\inferrule*[right=\UU-\textsc{intro}]
  {\wfctx \Gamma }
  {\oftp\Gamma{\UU_i}{\UU_{i+1}}}
\and
\inferrule*[right=\UU-\textsc{cumul}]
  {\oftp\Gamma{A}{\UU_i}}
  {\oftp\Gamma{A}{\UU_{i+1}}}
\end{mathpar}
%
We shall set up the rules of type theory in such a way that $\oftp\Gamma{a}{A}$
implies $\oftp\Gamma{A}{\UU_i}$ for some $i$. In other words, if $A$ plays the role of a type then it is in some universe. Another property of our type system is that $\jdeqtp\Gamma{a}{b}{A}$
implies $\oftp\Gamma{a}{A}$ and $\oftp\Gamma{b}{A}$.

\subsection{Dependent function types (\texorpdfstring{$\Pi$}{Π}-types)}
\label{sec:more-formal-pi}

\index{type!dependent function}%
\index{type!function}%

In \cref{sec:function-types}, we introduced non-dependent functions $A\to B$ in
order to define a family of types as a function $\lam{x:A} B:A\to\UU_i$, which
then gives rise to a type of dependent functions $\tprd{x:A} B$. But with explicit contexts
we may replace $\lam{x:A} B:A\to\UU_i$ with the judgment
%
\begin{equation*}
  \oftp{\tmtp xA}{B}{\UU_i}.
\end{equation*}
%
Consequently, we may define dependent functions directly, without reference to non-dependent ones. This way we follow the general principle that each type former, with its constants and rules, should be introduced independently of all other type formers.
%
In fact, henceforth each type former is introduced systematically by:
\begin{itemize}
\item a \define{formation rule}, stating when the type former can be applied;\index{formation rule}\index{rule!formation}
\item some \define{introduction rules}, stating how to inhabit the type;\index{introduction rule}\index{rule!introduction}
\item \define{elimination rules}, or an induction principle, stating how to use an
  element of the type;
  \index{induction principle}\index{eliminator}
\item \define{computation rules}, which are judgmental equalities explaining what happens when elimination rules are applied to results of introduction rules;
  \index{computation rule}
  \indexsee{rule!computation}{computation rule}
\item optional \define{uniqueness principles}, which are judgmental equalities explaining how every element of the type is uniquely determined by the results of elimination rules applied to it.
  \index{uniqueness!principle}
  \indexsee{principle!uniqueness}{uniqueness principle}
\end{itemize}
(See also \cref{rmk:introducing-new-concepts}.)

For the dependent function type these rules are:
%
\begin{mathparpagebreakable}
  \def\premise{\oftp{\Gamma}{A}{\UU_i} \and \oftp{\Gamma,\tmtp xA}{B}{\UU_i}}
  \inferrule*[right=$\Pi$-\rform]
    \premise
    {\oftp\Gamma{\tprd{x:A}B}{\UU_i}}
\and
  \inferrule*[right=$\Pi$-\rintro]
  {\oftp{\Gamma,\tmtp xA}{b}{B}}
  {\oftp\Gamma{\lam{x:A} b}{\tprd{x:A} B}}
\and
  \inferrule*[right=$\Pi$-\relim]
  {\oftp\Gamma{f}{\tprd{x:A} B} \\ \oftp\Gamma{a}{A}}
  {\oftp\Gamma{f(a)}{B[a/x]}}
\and
  \inferrule*[right=$\Pi$-\rcomp]
  {\oftp{\Gamma,\tmtp xA}{b}{B} \\ \oftp\Gamma{a}{A}}
  {\jdeqtp\Gamma{(\lam{x:A} b)(a)}{b[a/x]}{B[a/x]}}
\and
  \inferrule*[right=$\Pi$-\runiq]
  {\oftp\Gamma{f}{\tprd{x:A} B}}
  {\jdeqtp\Gamma{f}{(\lamu{x:A}f(x))}{\tprd{x:A} B}}
\end{mathparpagebreakable}

The expression $\lam{x:A} b$ binds free occurrences of $x$ in $b$, as does $\tprd{x:A} B$ for
$B$.

When $x$ does not occur freely in $B$ so that $B$ does not depend on $A$, we obtain as a
special case the ordinary function type $A\to B \defeq \tprd{x:A} B$. We take this as the \emph{definition} of $\to$.

We may abbreviate an expression $\lam{x:A} b$ as $\lamu{x:A} b$, with the understanding
that the omitted type $A$ should be filled in appropriately before type-checking.

\subsection{Dependent pair types (\texorpdfstring{$\Sigma$}{Σ}-types)}
\label{sec:more-formal-sigma}

\index{type!dependent pair}%
\index{type!product}%

In \cref{sec:sigma-types}, we needed $\to$ and $\prdsym$ types in order to
define the introduction and elimination rules for $\smsym$; as with $\prdsym$, contexts allow us to state the rules for $\smsym$ independently.
Recall that the elimination rule for a positive type such as $\Sigma$ is called \emph{induction} and denoted by $\ind{}$.
%
\begin{mathparpagebreakable}
  \def\premise{\oftp{\Gamma}{A}{\UU_i} \and \oftp{\Gamma,\tmtp xA}{B}{\UU_i}}
  \inferrule*[right=$\Sigma$-\rform]
    \premise
    {\oftp\Gamma{\tsm{x:A} B}{\UU_i}}
  \and
  \inferrule*[right=$\Sigma$-\rintro]
    {\oftp{\Gamma, \tmtp x A}{B}{\UU_i} \\
     \oftp\Gamma{a}{A} \\ \oftp\Gamma{b}{B[a/x]}}
    {\oftp\Gamma{\tup ab}{\tsm{x:A} B}}
  \and
  \inferrule*[right=$\Sigma$-\relim]
    {\oftp{\Gamma, \tmtp z {\tsm{x:A} B}}{C}{\UU_i} \\
     \oftp{\Gamma,\tmtp x A,\tmtp y B}{g}{C[\tup x y/z]} \\
     \oftp\Gamma{p}{\tsm{x:A} B}}
    {\oftp\Gamma{\ind{\tsm{x:A} B}(z.C,x.y.g,p)}{C[p/z]}}
  \and
  \inferrule*[right=$\Sigma$-\rcomp]
    {\oftp{\Gamma, \tmtp z {\tsm{x:A} B}}{C}{\UU_i} \\
     \oftp{\Gamma, \tmtp x A, \tmtp y B}{g}{C[\tup x y/z]} \\\\
     \oftp\Gamma{a}{A} \\ \oftp\Gamma{b}{B[a/x]}}
    {\jdeqtp\Gamma{\ind{\tsm{x:A} B}(z.C,x.y.g,\tup{a}{b})}{g[a,b/x,y]}{C[\tup {a} {b}/z]}}
\end{mathparpagebreakable}
%
The expression $\tsm{x:A} B$ binds free occurrences of $x$ in $B$. Furthermore, because
$\ind{\tsm{x:A} B}$ has some arguments with free variables beyond those in $\Gamma$,
we bind (following the variable names above) $z$ in $C$, and $x$ and $y$ in $g$.
These bindings are written as $z.C$ and $x.y.g$, to indicate the names of the bound
variables.
\index{variable!bound}%
In particular, we treat $\ind{\tsm{x:A} B}$ as a primitive,
two of whose arguments contain binders; this is superficially similar to, but
different from, $\ind{\tsm{x:A} B}$ being a function that takes functions as
arguments.

When $B$ does not contain free occurrences of $x$, we obtain as a special case
the cartesian product $A \times B \defeq \tsm{x:A} B$. We take this
as the \emph{definition} of the cartesian product.

Notice that we don't postulate a judgmental uniqueness principle for $\Sigma$-types, even
though we could have; see \cref{thm:eta-sigma} for a proof of the corresponding
propositional uniqueness principle.

\subsection{Coproduct types}

\index{type!coproduct}%

\begin{mathparpagebreakable}
  \inferrule*[right=$+$-\rform]
  {\oftp\Gamma{A}{\UU_i} \\ \oftp\Gamma{B}{\UU_i}}
  {\oftp\Gamma{A+B}{\UU_i}}
\\
  \inferrule*[right=$+$-\rintro${}_1$]
  {\oftp\Gamma{A}{\UU_i} \\ \oftp\Gamma{B}{\UU_i} \\\\ \oftp\Gamma{a}{A}}
  {\oftp\Gamma{\inl(a)}{A+B}}
\and
  \inferrule*[right=$+$-\rintro${}_2$]
  {\oftp\Gamma{A}{\UU_i} \\ \oftp\Gamma{B}{\UU_i} \\\\ \oftp\Gamma{b}{B}}
  {\oftp\Gamma{\inr(b)}{A+B}}
\\
  \inferrule*[right=$+$-\relim]
  {\oftp{\Gamma,\tmtp z{(A+B)}}{C}{\UU_i} \\\\
   \oftp{\Gamma,\tmtp xA}{c}{C[\inl(x)/z]} \\
   \oftp{\Gamma,\tmtp yB}{d}{C[\inr(y)/z]} \\\\
   \oftp\Gamma{e}{A+B}}
  {\oftp\Gamma{\ind{A+B}(z.C,x.c,y.d,e)}{C[e/z]}}
\and
  \inferrule*[right=$+$-\rcomp${}_1$]
  {\oftp{\Gamma,\tmtp z{(A+B)}}{C}{\UU_i} \\
   \oftp{\Gamma,\tmtp xA}{c}{C[\inl(x)/z]} \\
   \oftp{\Gamma,\tmtp yB}{d}{C[\inr(y)/z]} \\\\
   \oftp\Gamma{a}{A}}
  {\jdeqtp\Gamma{\ind{A+B}(z.C,x.c,y.d,\inl(a))}{c[a/x]}{C[\inl(a)/z]}}
\and
  \inferrule*[right=$+$-\rcomp${}_2$]
  {\oftp{\Gamma,\tmtp z{(A+B)}}{C}{\UU_i} \\
   \oftp{\Gamma,\tmtp xA}{c}{C[\inl(x)/z]} \\
   \oftp{\Gamma,\tmtp yB}{d}{C[\inr(y)/z]} \\\\
   \oftp\Gamma{b}{B}}
  {\jdeqtp\Gamma{\ind{A+B}(z.C,x.c,y.d,\inr(b))}{d[b/y]}{C[\inr(b)/z]}}
\end{mathparpagebreakable}
%
In $\ind{A+B}$, $z$ is bound in $C$, $x$ is bound in $c$, and $y$ is bound in
$d$.

\subsection{The empty type \texorpdfstring{$\emptyt$}{0}}

\index{type!empty|(}%

\begin{mathparpagebreakable}
  \inferrule*[right=$\emptyt$-\rform]
  {\wfctx\Gamma}
  {\oftp\Gamma\emptyt{\UU_i}}
\and
  \inferrule*[right=$\emptyt$-\relim]
  {\oftp{\Gamma,\tmtp x\emptyt}{C}{\UU_i} \\ \oftp\Gamma{a}{\emptyt}}
  {\oftp\Gamma{\ind{\emptyt}(x.C,a)}{C[a/x]}}
\end{mathparpagebreakable}
%
In $\ind{\emptyt}$, $x$ is bound in $C$. The empty type has no introduction rule and no computation rule.

\index{type!empty|)}%

\subsection{The unit type \texorpdfstring{$\unit$}{1}}
\label{sec:more-formal-unit}

\index{type!unit|(}%

\begin{mathparpagebreakable}
  \inferrule*[right=$\unit$-\rform]
  {\wfctx\Gamma}
  {\oftp\Gamma\unit{\UU_i}}
\and
  \inferrule*[right=$\unit$-\rintro]
  {\wfctx\Gamma}
  {\oftp\Gamma{\ttt}{\unit}}
\and
  \inferrule*[right=$\unit$-\relim]
  {\oftp{\Gamma,\tmtp x\unit}{C}{\UU_i} \\
   \oftp{\Gamma}{c}{C[\ttt/x]} \\
   \oftp\Gamma{a}{\unit}}
  {\oftp\Gamma{\ind{\unit}(x.C,c,a)}{C[a/x]}}
\and
  \inferrule*[right=$\unit$-\rcomp]
  {\oftp{\Gamma,\tmtp x\unit}{C}{\UU_i} \\
   \oftp{\Gamma}{c}{C[\ttt/x]}}
  {\jdeqtp\Gamma{\ind{\unit}(x.C,c,\ttt)}{c}{C[\ttt/x]}}
\end{mathparpagebreakable}
%
In $\ind{\unit}$ the variable $x$ is bound in $C$.

Notice that we do not postulate a judgmental uniqueness principle for the unit
type; see \cref{sec:finite-product-types} for a proof of the corresponding
propositional uniqueness statement.

\index{type!unit|)}%

\subsection{The natural number type}

\index{natural numbers|(}%

We give the rules for natural numbers, following \cref{sec:inductive-types}.

\begin{mathparpagebreakable}
  \def\premise{
     \oftp{\Gamma,\tmtp x{\N}}{C}{\UU_i} \\
     \oftp\Gamma{c_0}{C[0/x]} \\
     \oftp{\Gamma,\tmtp{x}\N,\tmtp y C}{c_s}{C[\suc(x)/x]}}
  %
  \inferrule*[right=$\N$-\rform]
  {\wfctx\Gamma}
  {\oftp\Gamma{\N}{\UU_i}}
\and
  \inferrule*[right=$\N$-\rintro${}_1$]
  {\wfctx\Gamma}
  {\oftp\Gamma{0}{\N}}
\and
  \inferrule*[right=$\N$-\rintro${}_2$]
  {\oftp\Gamma{n}{\N}}
  {\oftp\Gamma{\suc(n)}{\N}}
\and
  \inferrule*[right=$\N$-\relim]
  {\premise \\ \oftp\Gamma{n}{\N}}
  {\oftp\Gamma{\ind{\N}(x.C,c_0,x.y.c_s,n)}{C[n/x]}}
\and
  \inferrule*[right=$\N$-\rcomp${}_1$]
  {\premise}
  {\jdeqtp\Gamma{\ind{\N}(x.C,c_0,x.y.c_s,0)}{c_0}{C[0/x]}}
\and
  \inferrule*[right=$\N$-\rcomp${}_2$]
  {\premise \\ \oftp\Gamma{n}{\N}}
  {\Gamma\vdash
    {\begin{aligned}[t]
      &\ind{\N}(x.C,c_0,x.y.c_s,\suc(n)) \\
      &\quad \jdeq c_s[n,\ind{\N}(x.C,c_0,x.y.c_s,n)/x,y] : C[\suc(n)/x]
    \end{aligned}}}
\end{mathparpagebreakable}
%
In $\ind{\N}$, $x$ is bound in $C$, and $x$ and $y$ are bound in $c_s$.

Other inductively defined types follow the same general scheme.

\index{natural numbers|)}%

\subsection{Identity types}

\label{sec:more-formal-identity}

\index{type!identity|(}%

The presentation here corresponds to the (unbased) path induction principle for identity types in
\cref{sec:identity-types}.

\begin{mathparpagebreakable}
  \inferrule*[right=$\idsym$-\rform]
  {\oftp\Gamma{A}{\UU_i} \\ \oftp\Gamma{a}{A} \\ \oftp\Gamma{b}{A}}
  {\oftp\Gamma{\id[A]{a}{b}}{\UU_i}}
\and
  \inferrule*[right=$\idsym$-\rintro]
  {\oftp\Gamma{A}{\UU_i} \\ \oftp\Gamma{a}{A}}
  {\oftp\Gamma{\refl a}{\id[A]aa}}
\and
  \inferrule*[right=$\idsym$-\relim]
  {\oftp{\Gamma,\tmtp xA,\tmtp yA,\tmtp p{\id[A]xy}}{C}{\UU_i} \\
   \oftp{\Gamma,\tmtp zA}{c}{C[z,z,\refl z/x,y,p]} \\
   \oftp\Gamma{a}{A} \\ \oftp\Gamma{b}{A} \\ \oftp\Gamma{p'}{\id[A]ab}}
  {\oftp\Gamma{\indid{A}(x.y.p.C,z.c,a,b,p')}{C[a,b,p'/x,y,p]}}
\and
  \inferrule*[right=$\idsym$-\rcomp]
  {\oftp{\Gamma,\tmtp xA,\tmtp yA,\tmtp p{\id[A]xy}}{C}{\UU_i} \\
   \oftp{\Gamma,\tmtp zA}{c}{C[z,z,\refl z/x,y,p]} \\
   \oftp\Gamma{a}{A}}
  {\jdeqtp\Gamma{\indid{A}(x.y.p.C,z.c,a,a,\refl a)}{c[a/z]}{C[a,a,\refl a/x,y,p]}}
\end{mathparpagebreakable}
%
In $\indid{A}$, $x$, $y$, and $p$ are bound in $C$, and $z$ is bound in
$c$.

\index{type!identity|)}%

\subsection{Definitions}

\index{definition}%

Although the rules we have listed so far allow us to construct everything we need directly, we
would still like to be able to use named constants, such as $\isequiv$, as a matter of
convenience. Informally, we can think of these constants simply as
abbreviations, but the situation is a bit subtler in the formalization.

For example, consider function composition, which takes $f:A\to B$ and
$g:B\to C$ to $g\circ f:A\to C$. Somewhat unexpectedly, to make this work formally, $\circ$ must take as arguments not only $f$ and $g$, but also their types $A$, $B$, $C$:
%
\begin{narrowmultline*}
  {\circ} \defeq \lam{A:\UU_i}{B:\UU_i}{C:\UU_i}
  \narrowbreak
  \lam{g:B\to C}{f:A\to B}{x:A} g(f(x)).
\end{narrowmultline*}
%
From a practical perspective, we do not want to annotate each application of
$\circ$ with $A$, $B$ and $C$, as they are usually quite easily guessed from surrounding information. We would like to simply write $g\circ f$.
Then, strictly speaking, $g \circ f$ is not an abbreviation for $\lam{x : A} g(f(x))$,
because it involves additional \define{implicit arguments} which we want to suppress.
\index{implicit argument}

Inference of implicit arguments, typical ambiguity\index{typical ambiguity} (\cref{sec:universes}),
ensuring that symbols are only defined once, etc., are collectively called
\define{elaboration}. \index{elaboration, in type theory}
Elaboration must take place prior to checking a derivation, and is
thus not usually presented as part of the core type theory. However, it is
essentially impossible to use any implementation of type theory which does not
perform elaboration; see \cite{Coq,norell2007towards} for further discussion.

\section{Homotopy type theory}
\label{sec:hott-features}

In this section we state the additional axioms of homotopy type theory which distinguish it from standard Martin-L\"{o}f type theory: function extensionality, the
univalence axiom, and higher inductive types. We state them in the style
of the second presentation \cref{sec:syntax-more-formally}, although the first presentation \cref{sec:syntax-informally} could be used just as well.

\subsection{Function extensionality and univalence}

There are two basic ways of introducing axioms which do not introduce new syntax or judgmental equalities (function extensionality and univalence are of this form):
either add a primitive constant to inhabit the axiom, or prove all theorems which depend on the axiom by hypothesizing a variable that inhabits the axiom, cf.\ \cref{sec:axioms}.
While these are essentially equivalent, we opt for the former approach because we feel that the axioms of homotopy type theory are an essential part of the core theory.

\index{function extensionality}%
\cref{axiom:funext} is formalized by introduction of a constant $\funext$ which
asserts that $\happly$ is an equivalence:
%
\begin{mathparpagebreakable}
  \inferrule*[right=$\Pi$-\textsc{ext}]
  {\oftp\Gamma{f}{\tprd{x:A} B} \\
   \oftp\Gamma{g}{\tprd{x:A} B}}
  {\oftp\Gamma{\funext(f,g)}{\isequiv(\happly_{f,g})}}
\end{mathparpagebreakable}
%
The definitions of $\happly$ and $\isequiv$ can be found in~\eqref{eq:happly} and
\cref{sec:concluding-remarks}, respectively.

\index{univalence axiom}%
\cref{axiom:univalence} is formalized in a similar fashion, too:
%
\begin{mathparpagebreakable}
  \inferrule*[right=$\UU_i$-\textsc{univ}]
  {\oftp\Gamma{A}{\UU_i} \\
   \oftp\Gamma{B}{\UU_i}}
  {\oftp\Gamma{\univalence(A,B)}{\isequiv(\idtoeqv_{A,B})}}
\end{mathparpagebreakable}
%
The definition of $\idtoeqv$ can be found in~\eqref{eq:uidtoeqv}.

\subsection{The circle}

\index{type!circle}%

Here we give an example of a basic higher inductive type; others follow the same
general scheme, albeit with elaborations.

Note that the rules below do not precisely follow the pattern of the ordinary
inductive types in \cref{sec:syntax-more-formally}: the rules refer to the
notions of transport and functoriality of maps (\cref{sec:functors}), and the
second computation rule is a propositional, not judgmental, equality. These
differences are discussed in \cref{sec:dependent-paths}.

\begin{mathparpagebreakable}
  \inferrule*[right=$\Sn^1$-\rform]
  {\wfctx\Gamma}
  {\oftp\Gamma{\Sn^1}{\UU_i}}
\and
  \inferrule*[right=$\Sn^1$-\rintro${}_1$]
  {\wfctx\Gamma}
  {\oftp\Gamma{\base}{\Sn^1}}
\and
  \inferrule*[right=$\Sn^1$-\rintro${}_2$]
  {\wfctx\Gamma}
  {\oftp\Gamma{\lloop}{\id[\Sn^1]{\base}{\base}}}
\and
  \inferrule*[right=$\Sn^1$-\relim]
  {\oftp{\Gamma,\tmtp x{\Sn^1}}{C}{\UU_i} \\
   \oftp{\Gamma}{b}{C[\base/x]} \\
   \oftp{\Gamma}{\ell}{\dpath C \lloop b b} \\
   \oftp\Gamma{p}{\Sn^1}}
  {\oftp\Gamma{\ind{\Sn^1}(x.C,b,\ell,p)}{C[p/x]}}
\and
  \inferrule*[right=$\Sn^1$-\rcomp${}_1$]
  {\oftp{\Gamma,\tmtp x{\Sn^1}}{C}{\UU_i} \\
   \oftp{\Gamma}{b}{C[\base/x]} \\
   \oftp{\Gamma}{\ell}{\dpath C \lloop b b}}
  {\jdeqtp\Gamma{\ind{\Sn^1}(x.C,b,\ell,\base)}{b}{C[\base/x]}}
\and
  \inferrule*[right=$\Sn^1$-\rcomp${}_2$]
  {\oftp{\Gamma,\tmtp x{\Sn^1}}{C}{\UU_i} \\
   \oftp{\Gamma}{b}{C[\base/x]} \\
   \oftp{\Gamma}{\ell}{\dpath C \lloop b b}}
  {\oftp\Gamma{\Sn^1\text{-}\mathsf{loopcomp}}
    {\id {\apd{(\lamu{y:\Sn^1} \ind{\Sn^1}(x.C,b,\ell,y))}{\lloop}} {\ell}}}
\end{mathparpagebreakable}
%
In $\ind{\Sn^1}$, $x$ is bound in $C$. The notation ${\dpath C \lloop b b}$ for dependent paths was introduced in \cref{sec:dependent-paths}.
\index{rules of type theory|)}%

\section{Basic metatheory}
\index{metatheory|(}%

This section discusses the meta-theoretic properties of the type theory presented in 
\cref{sec:syntax-informally}, and similar results hold for \cref{sec:syntax-more-formally}. Figuring out which of these still hold when we add the features from \cref{sec:hott-features} quickly leads to open questions,\index{open!problem} as discussed at the end of this section.

Recall that \cref{sec:syntax-informally} defines the terms of type theory as
an extension of the untyped $\lambda$-calculus. The $\lambda$-calculus 
has its own notion of computation, namely the computation rule\index{computation rule!for function types}: 
\[
  (\lam{x} t)(u) \defeq t[u/x].
\]
This rule, together with the defining equations for the defined constants form
\emph{rewriting rules}\index{rewriting rule}\index{rule!rewriting} that determine reduction steps for a rewriting 
system. These steps yield a notion of computation in the sense that each rule
has a natural direction: one simplifies $(\lam{x} t)(u)$ by evaluating the
function at its argument.

Moreover, this system is \emph{confluent}\index{confluence}, that is, if $a$ simplifies in some
number of steps to both $a'$ and $a''$, there is some $b$ to which both $a'$ and
$a''$ eventually simplify. Thus we can define $t\conv u$ to mean that $t$ and
$u$ simplify to the same term.

(The situation is similar in \cref{sec:syntax-more-formally}: Although there
we presented the computation rules as undirected equalities $\jdeq$, we can give
an operational semantics by saying that the application of an eliminator to an
introductory form simplifies to its equal, not the other way around.)

Using standard techniques from type theory, it is possible to show that the system in \cref{sec:syntax-informally}
has the following properties:

\begin{thm}\label{thm:conversion-preserves-typing}
If $A : \UU$ and $A \conv A'$ then $A' : \UU$.
If $t:A$ and $t \conv t'$ then $t':A$.
\end{thm}

We say that a term is \define{normalizable}
\indexdef{term!normalizable}%
\index{normalization}%
\indexdef{normalizable term}%
(respectively, \define{strongly
normalizable})
\indexdef{term!strongly normalizable}%
\index{normalization!strong}%
\index{strong!normalization}%
if some (respectively, every), sequence of rewriting steps from the term
terminates.

\begin{thm}\label{thm:strong-normalization}
If $A : \UU$ then $A$ is strongly normalizable.
If $t:A$ then $A$ and $t$ are strongly normalizable.
\end{thm}

We say that a term is in \define{normal form}
\index{normal form}%
\index{term!normal form of}%
if it cannot be further
simplified, and that a term is \define{closed}
\index{closed!term}%
\index{term!closed}%
if no variable occurs freely in
it. A closed normal type has to be a primitive type, i.e., of the form
$c(\vec{v})$ for some primitive constant $c$ (where the list $\vec{v}$ of closed
normal terms may be omitted if empty, for instance, as with $\N$). In fact, we
can explicitly describe all normal forms:

\begin{lem}\label{lem:normal-forms}
  The terms in normal form can be described by the following syntax:
  % 
  \begin{align*}
    v & \production  k \mid \lam{x} v \mid c(\vec{v}) \mid f(\vec{v}), \\
    k &\production x \mid k(v) \mid f(\vec{v})(k),
  \end{align*}
  % 
  where $f(\vec{v})$ represents a partial application of the defined function $f$.
  In particular, a type in normal form is of the form $k$ or $c(\vec{v})$.
\end{lem}

\begin{thm}
  If $A$ is in normal form then the 
  judgment $A : \UU$ is decidable. If $A : \UU$ and $t$ is in normal form then the judgment
  $t:A$ is decidable.
\end{thm}

Logical consistency\index{consistency} (of the system in \cref{sec:syntax-informally}) follows
immediately: if we had $a:\emptyt$ in the empty context, then by
\cref{thm:conversion-preserves-typing,thm:strong-normalization}, $a$
simplifies to a normal term $a':\emptyt$. But by
\cref{lem:normal-forms} no such term exists.

\begin{cor}
 The system in \cref{sec:syntax-informally} is logically consistent.
\end{cor}

Similarly, we have the \emph{canonicity}\indexdef{canonicity} property that if $a:\N$ in the empty
context, then $a$ simplifies to a normal term $\suc^k(0)$ for some numeral $k$.

\begin{cor}
 The system in \cref{sec:syntax-informally} has the canonicity property.
\end{cor}

Finally, if $a,A$ are in normal form, it is \emph{decidable} whether $a:A$; in
other words, because type-checking amounts to verifying the correctness of a
proof, this means we can always ``recognize a correct proof when we see one''.

\begin{cor}
The property of being a proof in the system in \cref{sec:syntax-informally} is decidable.
\end{cor}

\mentalpause

The above results do not apply to the extended system of homotopy type
theory (i.e., the above system extended by \cref{sec:hott-features}), since
occurrences of the univalence axiom and constructors of higher inductive types
never simplify, breaking \cref{lem:normal-forms}. It is an open question\index{open!problem}
whether one can simplify applications of these constants in order to restore
canonicity. We also do not have a schema describing all permissible higher
inductive types, nor are we certain how to correctly formulate their rules
(e.g., whether the computation rules on higher constructors should be judgmental
equalities).

The consistency\index{consistency} of Martin-L\"{o}f type theory extended with univalence and higher
inductive types could be shown by inventing an appropriate normalization procedure, but currently
the only proofs that these systems are consistent are via semantic models---for
univalence, a model in Kan\index{Kan complex} complexes due to Voevodsky \cite{klv:ssetmodel}, and
for higher inductive types, a model due to Lumsdaine and Shulman \cite{ls:hits}.

Other metatheoretic issues, and a summary of our current results, are discussed
in greater length in the ``Constructivity'' and ``Open problems'' sections of
the introduction to this book.

\index{metatheory|)}%

\sectionNotes\label{subsec:general-remarks}

% This presentation is strongly inspired by two  Martin-L\"of 1972 and 1973.

The system of rules with introduction (primitive constants) and elimination
and computation rules (defined constant) is inspired by Gentzen natural
deduction. The possibility of strengthening the elimination rule for
existential quantification was indicated in \cite{howard:pat}. The
strengthening of the axioms for disjunction appears in \cite{Martin-Lof-1972},
and for absurdity elimination and identity type in \cite{Martin-Lof-1973}. The
$W$-types were introduced in \cite{Martin-Lof-1979}. They generalize a notion
of trees introduced by \cite{Tait-1968}.
\index{Martin-L\"of}%

%inspired from unpublished work of Spector.

The generalized form of primitive recursion for natural numbers and ordinals
appear in \cite{Hilbert-1925}. This motivated G\"odel's system $T$,
\cite{Goedel-T-1958}, which was analyzed by \cite{Tait-1966}, who used,
following \cite{Goedel-T-1958}, the terminology ``definitional equality'' for
conversion: two terms are \emph{judgmentally equal} if they reduce to a
common term by means of a sequence of applications of the reduction
rules. This terminology was also used by de Bruijn \cite{deBruijn-1973} in his
presentation of \emph{AUTOMATH}.\index{AUTOMATH}

Our second presentation comprises fairly standard presentation of
intensional Martin-L\"{o}f type theory, with some additional features needed in
homotopy type theory. Compared to a reference presentation of
\cite{hofmann:syntax-and-semantics}, the type theory of this book has a few
non-critical differences:
%
\begin{itemize}
\item universes \`{a} la Russell, in the sense of
\cite{martin-lof:bibliopolis}; and
\item judgmental $\eta$ and function extensionality for $\Pi$ types;
\end{itemize}
and a few features essential for homotopy type theory:
\begin{itemize}
\item the univalence axiom; and
\item higher inductive types.
\end{itemize}
%
As a matter of convenience, the book primarily defines functions by induction
using definition by \emph{pattern matching}.
\index{pattern matching}%
\index{definition!by pattern matching}%
It is possible to formalize the
notion of pattern matching, as done in \cref{sec:syntax-informally}. However, the
standard type-theoretic presentation, adopted in \cref{sec:syntax-more-formally}, is to introduce a single \emph{dependent
eliminator} for each type former, from which functions out of that type must be
defined. This approach is easier to formalize both syntactically and
semantically, as it amounts to the universal property of the type former.
The two approaches are equivalent; see \cref{sec:pattern-matching} for a
longer discussion.

\index{type theory!formal|)}%
\index{formal!type theory|)}%


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "hott-online"
%%% End: 
