\chapter{形式类型论 (Formal Type Theory)}
\label{cha:rules}

\index{formal!type theory|(形式!类型论|(}%
\index{type theory!formal|(类型论!形式|(}%
\index{rules of type theory|(类型论规则|(}%

正如可以在不显式使用策梅洛-弗兰克尔集合论的公理的情况下在集合论中发展数学一样，在本书中，我们在不明确提及同伦类型论形式系统的情况下，在单值基础上发展了数学。然而，\emph{拥有}对同伦类型论作为一个形式系统的精确定义是很重要的，例如，为了

\begin{itemize}
  \item 陈述并证明其元理论性质，包括逻辑一致性，
  \item 构造模型，例如在单纯集合、模型范畴、更高拓扑斯等中，\item 将其在 \Coq 或 \Agda 等证明助手中实现。
  \index{proof!assistant证明!助手}
\end{itemize}
%
即使是同伦类型论的逻辑一致性\index{consistency一致性}，即在空上下文中没有术语 $a:\emptyt$，也是不明显的：如果我们错误地选择了一个定义，使得 $\eqv{\emptyt}{\unit}$，那么单值性将暗示 $\emptyt$ 有一个元素，因为 $\unit$ 有一个元素。我们的 $\Sn^1$ 作为一个高阶归纳类型的定义是否能够表现得像普通的圆，也是不明显的。

在处理这些问题之前，我们必须明确类型论的两个方面。回想一下，在引言中我们提到，类型论包含一组规则，用来规定何时判断 $a:A$ 和 $a\jdeq a':A$ 成立——例如，积的规则是：当 $a:A$ 和 $b:B$ 时，$(a,b):A\times B$。要使这一点精确，我们首先必须精确定义术语的语法——这些判断所涉及的对象 $a,a',A,\dots$；然后，我们必须精确定义判断及其推理规则——即如何从其他判断中推导出判断。

在本附录中，我们将介绍 Martin-L\"{o}f 类型论及构成同伦类型论的扩展的两种表述。第一种表述 (\cref{sec:syntax-informally}) 描述了作为无类型 $\lambda$-演算扩展的术语的语法和判断的形式，而推理规则则保持非正式状态。第二种表述 (\cref{sec:syntax-more-formally}) 以自然演绎的方式递归地定义了术语、判断和推理规则，这在许多类型论文献中是常见的做法。

\section*{预备知识 (Preliminaries)}
\label{sec:formal-prelim}

在 \cref{cha:typetheory} 中，我们介绍了类型论的两个基本\define{判断 (judgments)}\index{judgment判断}。第一个判断 $a:A$ 断言一个术语 $a$ 具有类型 $A$。第二个判断 $a\jdeq b:A$ 断言两个术语 $a$ 和 $b$ 在类型 $A$ 下是\define{判断等同的 (judgmentally equal)}\index{equality!judgmental等同性!判断上的}\index{judgmental equality判断等同性}。这些判断是由 \cref{sec:syntax-more-formally} 中描述的一组推理规则递归定义的。

构造类型 $A$ 的元素 $a$ 就是推导出 $a:A$；在本书中，我们给出了描述 $a$ 构造的非正式论证，但在正式场合中，必须具体指定一个术语 $a$ 以及 $a:A$ 的完整推导。

然而，本书中的类型论表述与本附录中的表述之间的主要区别在于，这里判断是在显式的\define{上下文 (context)}\index{context上下文}中进行表述的，或假设的列表，形式为
\[
  x_1:A_1, x_2:A_2,\dots,x_n:A_n.
\]
上下文中的元素 $x_i : A_i$ 表示变量 $x_i$ 拥有类型 $A_i$ 的假设。上下文中出现的变量 $x_1, \ldots, x_n$ 必须是不同的。我们用字母 $\Gamma$ 和 $\Delta$ 来表示上下文。

上下文 $\Gamma$ 中的判断 $a:A$ 记作
\[ \oftp\Gamma aA \]
表示在 $\Gamma$ 列出的假设下 $a:A$。当假设列表为空时，我们仅写作
\[ \oftp{}aA \]
或
\[ \oftp\emptyctx aA \]
其中 $\emptyctx$ 表示空上下文。相同的适用于等同性判断
\[
  \jdeqtp\Gamma{a}{b}{A}
\]

然而，这些判断只有在\define{上下文良构 (well-formed)}\index{context!well-formed上下文!良构}时才有意义，这一概念由我们最后的判断表达
\[
  \wfctx{(x_1:A_1, x_2:A_2,\dots,x_n:A_n)}
\]
表示在上下文 $x_1:A_1, x_2:A_2,\dots,x_{i-1}:A_{i-1}$ 中，每个 $A_i$ 都是一个类型。因此，特别地，如果 $\oftp\Gamma aA$ 且 $\wfctx\Gamma$，那么我们知道每个 $A_i$ 仅包含变量 $x_1,\dots,x_{i-1}$，而 $a$ 和 $A$ 仅包含变量 $x_1,\dots,x_n$。
\index{variable!in context变量!在上下文中}

在非正式的数学表述中，上下文是隐含的。在证明的每个阶段，数学家都知道哪些变量是可用的，以及它们的类型是什么，要么是基于历史惯例（$n$ 通常是一个数，$f$ 是一个函数，等等），要么是因为变量是通过类似“设 $x$ 为一个实数”这样的句子明确引入的。我们将在 \cref{sec:more-formal-pi,sec:more-formal-sigma} 中讨论使用显式上下文的一些好处。

我们用 $B[a/x]$ 表示术语 $a$ 代替术语 $B$ 中自由出现的变量 $x$ 的\define{替换 (substitution)}\index{substitution替换}，同时可能会进行避免捕获的绑定变量重命名\index{variable!and substitution变量!与替换}\index{variable!bound变量!绑定的}，如 \cref{sec:function-types} 中所讨论。替换的一般形式
%
\[
  B[a_1,\dots,a_n/x_1,\dots,x_n]
\]
%
将表达式 $a_1,\dots,a_n$ 同时替换为变量 $x_1,\dots,x_n$。

\define{在表达式 $B$ 中绑定变量 $x$ (bind a variable $x$ in an expression $B$)}\indexdef{variable!bound变量!绑定}意味着将两者结合到一个更大的表达式中，称为\define{抽象 (abstraction)}\indexdef{abstraction抽象}，其目的是表达 $x$ 是“局部的”于 $B$，即不应与其他地方出现的 $x$ 混淆。绑定变量对程序员来说是熟悉的，但对数学家来说却不那么熟悉。绑定有各种记法，例如 $x \mapsto B$、$\lam x B$ 和 $x \,.\, B$，具体情况视场景而定。我们可以用 $C[a]$ 表示在抽象表达式中将术语 $a$ 替换为变量的替换，即我们可以定义 $(x.B)[a]$ 为 $B[a/x]$。如 \cref{sec:function-types} 中所讨论的，改变一个表达式内的绑定变量名（“$\alpha$-转换”）\index{alpha-conversion@$\alpha $-conversion $\alpha$-转换}不会改变表达式。因此，非常精确地说，一个表达式是一个语法形式的等价类，它们在绑定变量名上有所不同。

我们还可以认为判断
\[
  x_1:A_1, x_2:A_2,\dots,x_n:A_n \vdash a : A
\]
中的每个变量 $x_i$ 都绑定在其\define{作用域 (scope)}\indexdef{variable!scope of变量!作用域的}\index{scope作用域}中，该作用域由表达式 $A_{i+1}, \ldots, A_n$、$a$ 和 $A$ 组成。
\section{第一次表述 (The First Presentation)}
\label{sec:syntax-informally}

我们的类型论中的对象和类型可以使用以下语法作为术语来表示，这是一种扩展了$\lambda$-演算的语法，包含了\emph{变量} $x, x',\dots$、
\index{variable变量}%
\emph{原始常量 (primitive constants)}
\index{primitive!constant原始!常量}%
\index{constant!primitive常量!原始的}%
$c,c',\dots$、\emph{定义常量 (defined constants)}\index{constant!defined常量!定义的} $f,f',\dots$ 以及术语形成操作：
%
\[
  t \production x \mid \lam{x} t \mid t(t') \mid c \mid f
\]
%
此处使用的符号表示术语 $t$ 要么是变量 $x$，要么是形式为 $\lam{x} t$ 的表达式，其中 $x$ 是一个变量，$t$ 是一个术语；或者它是形式为 $t(t')$ 的表达式，其中 $t$ 和 $t'$ 都是术语；或者它是一个原始常量 $c$；或者它是一个定义常量 $f$。语法标记 '$\lambda$'、'('、')' 和 '.' 是为了指导人的眼睛的标点符号。

我们使用 $t(t_1,\dots,t_n)$ 作为重复应用 $t(t_1)(t_2)\dots (t_n)$ 的缩写。我们还可以使用\emph{中缀 (infix)}\index{infix notation中缀符号}表示法，当 $\star$ 是一个原始或定义的常量时，写作 $t_1\;\star\;t_2$ 表示 $\star(t_1,t_2)$。

每个定义常量有零个、一个或多个\define{定义方程 (defining equations)}。
\index{equation, defining方程, 定义的}%
\index{defining equation定义方程}%
定义常量有两种类型。显式\index{constant!explicit常量!显式的}定义常量 $f$ 具有一个定义方程
\[ f(x_1,\dots,x_n)\defeq t,\]
其中 $t$ 不涉及 $f$。
%
例如，我们可以引入显式定义常量 $\circ$，其定义方程为
\[ \circ (x,y)(z) \defeq x(y(z)),\]
并使用中缀符号 $x\circ y$ 表示 $\circ(x,y)$。当然，这只是函数的复合。

第二种定义常量用于指定一个（参数化的）映射 $f(x_1,\dots,x_n,x)$，其中 $x$ 范围为元素由零个或多个原始常量生成的类型。对于每个这样的原始常量 $c$，都有一个形式为
\[
  f(x_1,\dots,x_n,c(y_1,\dots,y_m)) \defeq t,
\]
的定义方程，其中 $f$ 可以出现在 $t$ 中，但只能以确定方程定义了一个完全定义的函数的方式出现。这类定义函数的范例是自然数上的原始递归定义的函数。我们可以称这种函数的定义为\emph{完全递归定义 (total recursive definition)}。
\index{total!recursive definition完全!递归定义}%
在计算机科学和逻辑学中，这种在递归数据类型上定义函数的方式被称为\define{结构递归定义 (definition by structural recursion)}。
\index{definition!by structural recursion定义!通过结构递归}%
\index{structural!recursion结构!递归}%
\index{recursion!structural递归!结构的}%

\define{术语的可转换性 (Convertibility)}\index{convertibility of terms术语的可转换性}%
\index{term!convertibility of术语!可转换性}%
$t \conv t'$ 是由常量的定义方程、计算规则\index{computation rule!for function types计算规则!函数类型的}生成的等价关系
%
\[
  (\lam{x} t)(u) \defeq t[u/x],
\]
%
以及使其成为应用和$\lambda$-抽象\index{lambda abstraction@$\lambda$-abstraction $\lambda$-抽象}的\emph{同余}的规则生成的等价关系：
%
\begin{itemize}
  \item 如果 $t \conv t'$ 且 $s \conv s'$，则 $t(s) \conv t'(s')$，并且
  \item 如果 $t \conv t'$，则 $(\lam{x} t) \conv (\lam{x} t')$。
\end{itemize}
\noindent
等同性判断 $t \jdeq u : A$ 可以通过以下单一规则得出：
%
\begin{itemize}
  \item 如果 $t:A$，$u:A$，并且 $t \conv u$，那么 $t \jdeq u : A$。
\end{itemize}
%
判断等同性是一个等价关系。

注意，本节中使用的类型论与正文中使用的类型论在不包含函数的判断唯一性原则 $f \jdeq (\lam{x} f(x))$ 方面有所不同。这种等同性要求判断等同性对所涉及术语的类型敏感，因为这种等同性只有在 $f$ 被认为是一个函数时才有意义，而在本节中的可转换关系与类型无关。\cref{sec:syntax-more-formally}中的第二种表述包含了唯一性原则。


\subsection{类型宇宙 (Type Universes)}

我们假设有一个\define{宇宙 (universes)}\index{type!universe类型!宇宙}的层次结构，由原始常量表示
%
\begin{equation*}
  \UU_0, \quad \UU_1, \quad  \UU_2, \quad \ldots
\end{equation*}
%
关于宇宙的前两个规则表明它们形成了一个累积的类型层次结构：
%
\begin{itemize}
  \item $\UU_m : \UU_n$ 对于 $m < n$，
  \item 如果 $A:\UU_m$ 且 $m \le n$，那么 $A:\UU_n$，
\end{itemize}
%
第三个规则表示宇宙中的一个对象可以作为类型并在判断中出现在冒号的右边：
%
\begin{itemize}
  \item 如果 $\Gamma \vdash A : \UU_n$，并且 $x$ 是一个新变量，\footnote{“新”表示它没有出现在 $\Gamma$ 或 $A$ 中。}那么 $\vdash (\Gamma, x:A)\; \ctx$。
\end{itemize}
%
在正文中，类型 $A$ 和 $B$ 之间的等同性判断 $A \jdeq B : \UU_n$ 通常简写为 $A \jdeq B$。这是一种典型的歧义\index{typical ambiguity典型的歧义}，因为我们可以随时切换到更大的宇宙，但这不会影响判断的有效性。

以下转换规则允许我们在类型判断中用一个类型替换为与之等同的类型：
%
\begin{itemize}
  \item 如果 $a:A$ 且 $A \jdeq B$，那么 $a:B$。
\end{itemize}

\subsection{依赖函数类型 (\texorpdfstring{$\Pi$}{Π}-types)}

我们引入一个原始常量 $c_\Pi$，但将 $c_\Pi(A,\lam{x} B)$ 写作 $\tprd{x:A}B$。通过以下规则引入了关于此类表达式和形式为 $\lam{x} b$ 的表达式的判断：
%
\begin{itemize}
  \item 如果 $\Gamma \vdash A:\UU_n$ 且 $\Gamma,x:A \vdash B:\UU_n$，那么 $\Gamma \vdash \tprd{x:A}B : \UU_n$
  \item 如果 $\Gamma, x:A \vdash b:B$，那么 $\Gamma \vdash (\lam{x} b) : (\tprd{x:A} B)$
  \item 如果 $\Gamma\vdash g:\tprd{x:A} B$ 且 $\Gamma\vdash t:A$，那么 $\Gamma\vdash g(t):B[t/x]$
\end{itemize}
%
如果 $x$ 在 $B$ 中不是自由的，我们将 $\tprd{x:A} B$ 简写为非依赖函数类型 $A\rightarrow B$，并推导出以下规则：
%
\begin{itemize}
  \item 如果 $\Gamma\vdash g:A \rightarrow B$ 且 $\Gamma\vdash t:A$，那么 $\Gamma\vdash g(t):B$
\end{itemize}
使用非依赖函数类型并隐式保留上下文 $\Gamma$，可以将上述规则写成以下替代风格，我们将在附录的本节其余部分中使用：
%
\begin{itemize}
  \item 如果 $A:\UU_n$ 且 $B:A\to\UU_n$，那么 $\tprd{x:A}B(x) : \UU_n$
  \item 如果 $x:A \vdash b:B(x)$ 那么 $ \lam{x} b : \tprd{x:A} B(x)$
  \item 如果 $g:\tprd{x:A} B(x)$ 且 $t:A$ 那么 $g(t):B(t)$
\end{itemize}
%

\subsection{依赖对类型 (\texorpdfstring{$\Sigma$}{Σ}-types)}

我们引入原始常量 $c_\Sigma$ 和 $c_{\mathsf{pair}}$。形式为 $c_\Sigma(A,\lam{a} B)$ 的表达式写作 $\sm{a:A}B$，
形式为 $c_{\mathsf{pair}}(a,b)$ 的表达式写作 $\tup a b$。如果 $x$ 在 $B$ 中不是自由的，我们将 $\sm{x:A} B$ 写作 $A\times B$。

通过以下规则引入了关于此类表达式的判断：
%
\begin{itemize}
  \item 如果 $A:\UU_n$ 且 $B: A \rightarrow \UU_n$，那么 $\sm{x:A}B(x) : \UU_n$
  \item 此外，如果 $a:A$ 且 $b:B(a)$，那么 $\tup a b:\sm{x:A}B(x)$
\end{itemize}
%
如果我们有如上的 $A$ 和 $B$，$C : (\sm{x:A}B(x)) \rightarrow \UU_m$，并且
\[
  d:\tprd{x:A}{y:B(x)} C(\tup x y)
\]
我们可以引入一个定义常量
\[
  f:\tprd{p:\sm{x:A}B(x)} C(p)
\]
其定义方程为
\[
  f(\tup x y)\defeq d(x,y)。
\]
%
注意，$C$、$d$、$x$ 和 $y$ 可能包含一些额外的隐式参数 $x_1,\ldots,x_n$，如果它们是在某个非空上下文中获得的；因此，完全显式的递归模式为
%
\begin{narrowmultline*}
  f(x_1,\dots,x_n,\tup{x(x_1,\dots,x_n)}{y(x_1,\dots,x_n)}) \defeq
  \narrowbreak
  d(x_1,\dots,x_n,\tup{x(x_1,\dots,x_n)}{y(x_1,\dots,x_n)})。
\end{narrowmultline*}

\subsection{余积类型 (Coproduct Types)}

我们引入原始常量 $c_+$、$c_\inlsym$ 和 $c_\inrsym$。我们用 $A+B$ 代替 $c_+(A,B)$，用 $\inl(a)$ 代替 $c_\inlsym(a)$，用 $\inr(a)$ 代替 $c_\inrsym(a)$：
%
\begin{itemize}
  \item 如果 $A,B : \UU_n$，则 $A + B : \UU_n$
  \item 此外，$\inl: A \rightarrow A+B$ 和 $\inr: B \rightarrow A+B$
\end{itemize}
%
如果我们有上述的 $A$ 和 $B$，$C : A+B \rightarrow \UU_m$，
$d:\tprd{x:A} C(\inl(x))$ 和 $e:\tprd{y:B} C(\inr(y))$，
那么我们可以引入一个定义常量 $f:\tprd{z:A+B}C(z)$，其定义方程为
%
\begin{equation*}
  f(\inl(x)) \defeq d(x)
  \qquad\text{和}\qquad
  f(\inr(y)) \defeq e(y)。
\end{equation*}

\subsection{有限类型 (The Finite Types)}

我们引入原始常量 $\ttt$、$\emptyt$ 和 $\unit$，满足以下规则：
%
\begin{itemize}
  \item $\emptyt : \UU_0$，$\unit : \UU_0$
  \item $\ttt:\unit$
\end{itemize}

给定 $C : \emptyt \rightarrow \UU_n$，我们可以引入一个定义常量 $f:\tprd{x:\emptyt} C(x)$，没有定义方程。

给定 $C : \unit \rightarrow \UU_n$ 和 $d : C(\ttt)$，我们可以引入一个定义常量 $f:\tprd{x:\unit} C(x)$，其定义方程为 $f(\ttt) \defeq d$。

\subsection{自然数 (Natural Numbers)}

自然数的类型通过引入原始常量 $\N$、$0$ 和 $\suc$ 获得，并满足以下规则：
%
\begin{itemize}
  \item $\N : \UU_0$，
  \item $0:\N$，
  \item $\suc:\N\rightarrow \N$。
\end{itemize}
%
此外，我们可以通过原始递归定义函数。如果我们有 $C : \N \rightarrow \UU_k $，当我们有
%
\begin{align*}
  d & : C(0) \\
  e & : \tprd{x:\N}(C(x)\rightarrow C(\suc (x)))
\end{align*}
%
时，我们可以引入定义常量 $f:\tprd{x:\N}C(x)$，其定义方程为
%
\begin{equation*}
  f(0) \defeq d
  \qquqquad\text{和}\qquad
  f(\suc (x)) \defeq e(x,f(x))。
\end{equation*}

\subsection{\texorpdfstring{$W$}{W}-类型 (\texorpdfstring{$W$}{W}-Types)}

对于 $W$-类型，我们引入原始常量 $c_\wtypesym$ 和 $c_\suppsym$。
形式为 $c_\wtypesym(A,\lam{x} B)$ 的表达式写作
$\wtype{x:A}B$，形式为 $c_\suppsym(x,u)$ 的表达式写作
$\supp(x,u)$：
%
\begin{itemize}
  \item 如果 $A:\UU_n$ 和 $B: A \rightarrow \UU_n$，则 $\wtype{x:A}B(x) : \UU_n$
  \item 此外，如果 $a:A$ 和 $u:B(a)\rightarrow \wtype{x:A}B(x)$，则 $\supp(a,u):\wtype{x:A}B(x)$。
\end{itemize}
%
在这里我们也可以通过完全递归定义函数。如果我们有上述的 $A$ 和 $B$，以及 $C : (\wtype{x:A}B(x)) \rightarrow \UU_m$，那么我们可以引入一个定义常量
$f:\tprd{z:\wtype{x:A}B(x)} C(z)$，当我们有
\[
  d:\tprd{a:A}{u:B(a) \rightarrow \wtype{x:A}B(x)}((\tprd{y:B(a)}C(u(y))) \rightarrow C(\supp(a,u)))
\]
时，定义方程为
\[
  f(\supp(a,u)) \defeq d(a,u,f\circ u)。
\]

\subsection{等同类型 (Identity Types)}

我们引入原始常量 $c_\idsym$ 和 $c_{\refl{}}$。当 $a:A$ 被理解时，我们将 $\id[A] a b$ 写作 $c_\idsym(A,a,b)$，将 $\refl a$ 写作 $c_{\refl{}}(A,a)$：
%
\begin{itemize}
  \item 如果 $A : \UU_n$，$a:A$ 和 $b:A$，那么 $\id[A] a b : \UU_n$。
  \item 如果 $a:A$，那么 $\refl a :\id[A] a a $。
\end{itemize}
%
给定 $a:A$，如果 $y:A, z:\id[A] a y \vdash C : \UU_m$ 和
$\vdash d:C[a,\refl{a}/y,z]$，那么我们可以引入一个定义常量
\[
  f:\tprd{y:A}{z:\id[A] a y} C
\]
其定义方程为
\[
  f(a,\refl{a})\defeq d。
\]

\section{第二次表述 (The Second Presentation)}
\label{sec:syntax-more-formally}

在本节中，有三种类型的判断：
\begin{mathpar}
  \wfctx\Gamma
  \and
  \oftp\Gamma{a}{A}
  \and
  \jdeqtp\Gamma{a}{a'}{A}
\end{mathpar}
我们通过提供推理规则来指定它们。一个典型的\define{推理规则 (inference rule)}\indexsee{inference rule}{rule规则}%
\indexdef{rule规则}%
形式如下：
%
\begin{equation*}
  \inferrule*[right=\textsc{Name}]
  {\mathcal{J}_1 \\ \cdots \\ \mathcal{J}_k}
  {\mathcal{J}}
\end{equation*}
%
它表示我们可以得出\define{结论 (conclusion)}$\mathcal{J}$，前提是我们已经得出了\define{前提 (hypotheses)}$\mathcal{J}_1, \ldots, \mathcal{J}_k$。
（注意，由于这些是判断而不是类型，它们不是\emph{内部}于类型论的假设，正如\cref{sec:types-vs-sets}中提到的；它们是推理系统中的假设，即元理论中的假设。）
在右边我们写下规则的\textsc{Name}，并且在应用该规则之前可能需要检查一些额外的附加条件。

判断的\define{推导 (derivation)}\index{derivation推导}%
是一棵由这种推理规则构建的树，树的根节点是判断。例如，使用下面给出的规则，以下是$\oftp{\emptyctx}{\lamu{x:\unit} x}{\unit\to\unit}$的推导过程。
%
\begin{mathpar}
  \inferrule*[right=$\Pi$-\rintro]
  {\inferrule*[right=$\Vble$]
  {\inferrule*[right=\ctx-\textsc{ext}]
  {\inferrule*[right=$\unit$-\rform]
  {\inferrule*[right=\ctx-\textsc{emp}]
  {\ }
  {\wfctx {\emptyctx}}}
  {\oftp{}{\unit}{\UU_0}}}
  {\wfctx {\tmtp x\unit}}}
  {\oftp{\tmtp x\unit}{x}{\unit}}}
  {\oftp{\emptyctx}{\lamu{x:\unit} x}{\unit\to\unit}}
\end{mathpar}

\subsection{上下文 (Contexts)}
\label{subsec:contexts}

\index{context上下文}%
上下文是一个列表：
%
\begin{equation*}
  \tmtp{x_1}{A_1}, \tmtp{x_2}{A_2}, \ldots, \tmtp{x_n}{A_n}
\end{equation*}
%
它表示不同的变量\index{variable变量}%
$x_1, \ldots, x_n$ 分别假设具有类型 $A_1, \ldots, A_n$。该列表可以为空。我们用字母 $\Gamma$ 和 $\Delta$ 来缩写上下文，并且可以通过将它们并置来形成更大的上下文。

判断 $\wfctx{\Gamma}$ 正式表示 $\Gamma$ 是一个良构上下文，并且受以下推理规则的约束：
%
\begin{mathpar}
  \inferrule*[right=\ctx-\textsc{emp}]
  {\ }
  {\wfctx\emptyctx}
  \and
  \inferrule*[right=\ctx-\textsc{ext}]
  {\oftp{\tmtp{x_1}{A_1}, \ldots, \tmtp{x_{n-1}}{A_{n-1}}}{A_n}{\UU_i}}
  {\wfctx{(\tmtp{x_1}{A_1}, \ldots, \tmtp{x_n}{A_n})}}
\end{mathpar}
%
第二个规则的附加条件是：变量 $x_n$ 必须与变量 $x_1, \ldots, x_{n-1}$ 不同。
注意，$\ctx$-\textsc{ext}的前提和结论是不同形式的判断：前提表示在变量 $x_1, \ldots, x_{n-1}$ 的上下文中，表达式 $A_n$ 具有类型 $\UU_i$；而结论表示扩展后的上下文 $(\tmtp{x_1}{A_1}, \ldots, \tmtp{x_n}{A_n})$ 是良构的。

这是系统的元理论性质，即如果可以推导出任何形式为 $\oftp{\Gamma}{a}{A}$ 或 $\jdeqtp\Gamma{a}{a'}{A}$ 的判断，那么也可以推导出上下文 $\Gamma$ 是良构的判断 $\wfctx\Gamma$。
所有规则的前提都被选择为包含足够的良构性假设，以使该性质可证明，但没有更多的假设。
例如，不需要在 $\ctx$-\textsc{ext} 中假设 $(\tmtp{x_1}{A_1}, \ldots, \tmtp{x_{n-1}}{A_{n-1}})$ 是良构的，因为这将从其前提的可推导性中得出；但在下一节中的 $\Vble$ 规则中必须假设上下文是良构的。
这种选择只是精确制定类型论的许多可能方法之一，但详细研究这些问题超出了本附录的范围。

\subsection{结构规则 (Structural Rules)}

\index{structural!rules结构!规则|(}%
\index{rule!structural规则!结构的|(}%

上下文中持有假设的事实通过以下规则表达，该规则表示我们可以推导出上下文中列出的那些类型判断：
%
\begin{mathpar}
  \inferrule*[right=$\Vble$]
  {\wfctx {(\tmtp{x_1}{A_1}, \ldots, \tmtp{x_n}{A_n})} }
  {\oftp{\tmtp{x_1}{A_1}, \ldots, \tmtp{x_n}{A_n}}{x_i}{A_i}}
\end{mathpar}
%
与 $\ctx$-\textsc{ext} 一样，规则 $\Vble$ 的前提和结论是不同形式的判断，只不过现在它们是反过来的：我们从一个良构的上下文开始，并推导出一个类型判断。

以下重要原则，称为\define{替换 (substitution)}\indexdef{rule!of substitution规则!替换的}%
和\define{弱化 (weakening)}\indexdef{rule!of weakening规则!弱化的}%
，不需要显式假设。相反，可以通过对所有可能推导的结构进行归纳证明，每当这些规则的前提是可推导的，其结论也是可推导的。\footnote{这些规则被称为\define{可容许的规则 (admissible)}\indexdef{rule!admissible规则!可容许的}\indexsee{admissible!rule可容许的!规则}{rule, admissible规则, 可容许的}。}
对于类型判断，这些原则表现为：
%
\begin{mathpar}
  \inferrule*[right=$\Subst_1$]
  {\oftp\Gamma{a}{A} \\ \oftp{\Gamma,\tmtp xA,\Delta}{b}{B}}
  {\oftp{\Gamma,\Delta[a/x]}{b[a/x]}{B[a/x]}}
  \and
  \inferrule*[right=$\Weak_1$]
  {\oftp\Gamma{A}{\UU_i} \\ \oftp{\Gamma,\Delta}{b}{B}}
  {\oftp{\Gamma,\tmtp xA,\Delta}{b}{B}}
\end{mathpar}
对于判断等同性，它们表现为：
\begin{mathpar}
  \inferrule*[right=$\Subst_2$]
  {\oftp\Gamma{a}{A} \\ \jdeqtp{\Gamma,\tmtp xA,\Delta}{b}{c}{B}}
  {\jdeqtp{\Gamma,\Delta[a/x]}{b[a/x]}{c[a/x]}{B[a/x]}}
  \and
  \inferrule*[right=$\Subst_3$]
  {\jdeqtp\Gamma{a}{b}{A} \\ \oftp{\Gamma,\tmtp xA,\Delta}{c}{C}}
  {\jdeqtp{\Gamma,\Delta[a/x]}{c[a/x]}{c[b/x]}{C[a/x]}}
  \and
  \inferrule*[right=$\Weak_2$]
  {\oftp\Gamma{A}{\UU_i} \\ \jdeqtp{\Gamma,\Delta}{b}{c}{B}}
  {\jdeqtp{\Gamma,\tmtp xA,\Delta}{b}{c}{B}}
\end{mathpar}
%
除了为每个类型构造器给出的判断等同性规则外，我们还假设判断等同性是一个由类型支持的等价关系。
\begin{mathparpagebreakable}
  \inferrule*{\oftp\Gamma{a}{A}}{\jdeqtp\Gamma{a}{a}{A}}
  \and
  \inferrule*{\jdeqtp\Gamma{a}{b}{A}}{\jdeqtp\Gamma{b}{a}{A}}
  \and
  \inferrule*{\jdeqtp\Gamma{a}{b}{A} \\ \jdeqtp\Gamma{b}{c}{A}}{\jdeqtp\Gamma{a}{c}{A}}
  \and
  \inferrule*{\oftp\Gamma{a}{A} \\ \jdeqtp\Gamma{A}{B}{\UU_i}}{\oftp\Gamma{a}{B}}
  \and
  \inferrule*{\jdeqtp\Gamma{a}{b}{A} \\ \jdeqtp\Gamma{A}{B}{\UU_i}}{\jdeqtp\Gamma{a}{b}{B}}
\end{mathparpagebreakable}
%
最后，我们假设判断等同性是一个由类型支持的同余关系，即每个类型和术语构造器在其所有参数中保持判断等同性。例如，与$\Pi$-\rintro规则一起，我们假设规则
\[
  \inferrule*[right=$\Pi$-\rintro-eq]
  {\oftp\Gamma{A}{\UU_i} \\
  \oftp{\Gamma,\tmtp xA}{B}{\UU_i} \\
  \jdeqtp{\Gamma,\tmtp xA}{b}{b'}{B}}
  {\jdeqtp\Gamma{\lamu{x:A} b}{\lamu{x:A'} b'}{\tprd{x:A} B}}
\]
完成依赖函数类型的情况，另外两条相似的规则为$\Pi$-\textsc{form-eq}和$\Pi$-\textsc{elim-eq}。
这些局部原则（在每个类型上）一起蕴含了上述的全局同余原则$\Subst_2$和$\Subst_3$。为了简洁起见，我们将省略这些局部规则。

\index{rule!structural规则!结构的|)}%
\index{structural!rules结构!规则|)}%

\subsection{类型宇宙 (Type Universes)}

\index{type!universe类型!宇宙}%

我们假设一个无限层级的类型宇宙：
%
\begin{equation*}
  \UU_0, \quad \UU_1, \quad  \UU_2, \quad \ldots
\end{equation*}
%
每个宇宙都包含在下一个宇宙中，$\UU_i$ 中的任何类型也在 $\UU_{i+1}$ 中：
%
\begin{mathpar}
  \inferrule*[right=\UU-\textsc{intro}]
  {\wfctx \Gamma }
  {\oftp\Gamma{\UU_i}{\UU_{i+1}}}
  \and
  \inferrule*[right=\UU-\textsc{cumul}]
  {\oftp\Gamma{A}{\UU_i}}
  {\oftp\Gamma{A}{\UU_{i+1}}}
\end{mathpar}
%
我们将设置类型论的规则，使得 $\oftp\Gamma{a}{A}$ 蕴含 $\oftp\Gamma{A}{\UU_i}$ 对某个 $i$ 成立。换句话说，如果 $A$ 扮演类型的角色，那么它位于某个宇宙中。我们系统的另一个性质是 $\jdeqtp\Gamma{a}{b}{A}$ 蕴含 $\oftp\Gamma{a}{A}$ 和 $\oftp\Gamma{b}{A}$。

\subsection{依赖函数类型 (\texorpdfstring{$\Pi$}{Π}-types)}
\label{sec:more-formal-pi}

\index{type!dependent function类型!依赖函数}%
\index{type!function类型!函数}%

在\cref{sec:function-types}中，我们引入了非依赖函数$A\to B$，以定义类型族作为函数$\lam{x:A} B:A\to\UU_i$，进而产生依赖函数类型$\tprd{x:A} B$。但通过显式上下文，我们可以将$\lam{x:A} B:A\to\UU_i$替换为判断
%
\begin{equation*}
  \oftp{\tmtp xA}{B}{\UU_i}。
\end{equation*}
%
因此，我们可以直接定义依赖函数，而不需要参考非依赖函数。这样我们遵循了每个类型构造器都应独立于其他类型构造器引入的总体原则。
%
实际上，从现在起，每个类型构造器将通过以下方式系统地引入：
\begin{itemize}
  \item \define{构造规则 (formation rule)}，说明何时可以应用类型构造器；
  \index{formation rule构造规则}\index{rule!formation规则!构造}
  \item 一些\define{引入规则 (introduction rules)}，说明如何构造该类型的元素；
  \index{introduction rule引入规则}\index{rule!introduction规则!引入}
  \item \define{消去规则 (elimination rules)}，或归纳原理，说明如何使用该类型的元素；
  \index{induction principle归纳原理}\index{eliminator消去}
  \item \define{计算规则 (computation rules)}，这些是判断等同性，解释当对引入规则的结果应用消去规则时会发生什么；
  \index{computation rule计算规则}
  \indexsee{rule!computation规则!计算}{computation rule计算规则}
  \item 可选的\define{唯一性原则 (uniqueness principles)}，这些是判断等同性，解释如何通过对该类型的元素应用消去规则来唯一地确定它们。
  \index{uniqueness!principle唯一性!原则}
  \indexsee{principle!uniqueness原则!唯一性}{uniqueness principle唯一性原则}
\end{itemize}
（另见\cref{rmk:introducing-new-concepts}。）

对于依赖函数类型，这些规则为：
%
\begin{mathparpagebreakable}
  \def\premise{\oftp{\Gamma}{A}{\UU_i} \and \oftp{\Gamma,\tmtp xA}{B}{\UU_i}}
  \inferrule*[right=$\Pi$-\rform]
  \premise
  {\oftp\Gamma{\tprd{x:A}B}{\UU_i}}
  \and
  \inferrule*[right=$$\Pi$-\rintro]
    {\oftp{\Gamma,\tmtp xA}{b}{B}}
    {\oftp\Gamma{\lam{x:A} b}{\tprd{x:A} B}}
  \and
  \inferrule*[right=$\Pi$-\relim]
    {\oftp\Gamma{f}{\tprd{x:A} B} \\ \oftp\Gamma{a}{A}}
    {\oftp\Gamma{f(a)}{B[a/x]}}
  \and
  \inferrule*[right=$\Pi$-\rcomp]
    {\oftp{\Gamma,\tmtp xA}{b}{B} \\ \oftp\Gamma{a}{A}}
    {\jdeqtp\Gamma{(\lam{x:A} b)(a)}{b[a/x]}{B[a/x]}}
  \and
  \inferrule*[right=$$\Pi$-\runiq]
  {\oftp\Gamma{f}{\tprd{x:A} B}}
  {\jdeqtp\Gamma{f}{(\lamu{x:A}f(x))}{\tprd{x:A} B}}
\end{mathparpagebreakable}

表达式$\lam{x:A} b$在$b$中绑定$x$的自由出现，同样$\tprd{x:A} B$也在$B$中绑定$x$。

当$x$在$B$中不自由出现，从而$B$不依赖于$A$时，我们得到一个特例，即普通函数类型$A\to B \defeq \tprd{x:A} B$。我们将其视为$\to$的\emph{定义}。

我们可以将表达式$\lam{x:A} b$缩写为$\lamu{x:A} b$，理解为在类型检查之前，应该适当地填入省略的类型$A$。

\subsection{依赖对类型 (\texorpdfstring{$\Sigma$}{Σ}-types)}
\label{sec:more-formal-sigma}

\index{type!dependent pair类型!依赖对}%
\index{type!product类型!积}%

在\cref{sec:sigma-types}中，我们需要$\to$和$\prdsym$类型，以定义$\smsym$的引入和消去规则；与$\prdsym$一样，上下文允许我们独立地陈述$\smsym$的规则。回顾一下，对于正类型如$\Sigma$，其消去规则称为\emph{归纳 (induction)}，用$\ind{}$表示。
%
\begin{mathparpagebreakable}
  \def\premise{\oftp{\Gamma}{A}{\UU_i} \and \oftp{\Gamma,\tmtp xA}{B}{\UU_i}}
  \inferrule*[right=$\Sigma$-\rform]
  \premise
  {\oftp\Gamma{\tsm{x:A} B}{\UU_i}}
  \and
  \inferrule*[right=$\Sigma$-\rintro]
  {\oftp{\Gamma, \tmtp x A}{B}{\UU_i} \\
  \oftp\Gamma{a}{A} \\ \oftp\Gamma{b}{B[a/x]}}
  {\oftp\Gamma{\tup ab}{\tsm{x:A} B}}
  \and
  \inferrule*[right=$\Sigma$-\relim]
  {\oftp{\Gamma, \tmtp z {\tsm{x:A} B}}{C}{\UU_i} \\
  \oftp{\Gamma,\tmtp x A,\tmtp y B}{g}{C[\tup x y/z]} \\
  \oftp\Gamma{p}{\tsm{x:A} B}}
  {\oftp\Gamma{\ind{\tsm{x:A} B}(z.C,x.y.g,p)}{C[p/z]}}
  \and
  \inferrule*[right=$\Sigma$-\rcomp]
  {\oftp{\Gamma, \tmtp z {\tsm{x:A} B}}{C}{\UU_i} \\
  \oftp{\Gamma, \tmtp x A, \tmtp y B}{g}{C[\tup x y/z]} \\\\
  \oftp\Gamma{a}{A} \\ \oftp\Gamma{b}{B[a/x]}}
  {\jdeqtp\Gamma{\ind{\tsm{x:A} B}(z.C,x.y.g,\tup{a}{b})}{g[a,b/x,y]}{C[\tup {a} {b}/z]}}
\end{mathparpagebreakable}
%
表达式$\tsm{x:A} B$在$B$中绑定$x$的自由出现。此外，由于$\ind{\tsm{x:A} B}$有一些超出$\Gamma$的自由变量参与的参数，我们在$C$中绑定$z$，在$g$中绑定$x$和$y$。这些绑定写作$z.C$和$x.y.g$，以指示被绑定变量的名称。
\index{variable!bound变量!绑定的}%
特别地，我们将$\ind{\tsm{x:A} B}$视为一个原语，其中的两个参数包含绑定变量；这表面上类似于，但不同于，$\ind{\tsm{x:A} B}$是一个以函数作为参数的函数。

当$B$不包含$x$的自由出现时，我们得到一个特例，即笛卡尔积$A \times B \defeq \tsm{x:A} B$。我们将其视为笛卡尔积的\emph{定义}。

注意，我们没有为$\Sigma$-类型假定一个判断的唯一性原则，即使我们可以这样做；参见\cref{thm:eta-sigma}以获取对应命题唯一性原则的证明。

\subsection{余积类型 (Coproduct Types)}

\index{type!coproduct类型!余积}%

\begin{mathparpagebreakable}
  \inferrule*[right=$+$-\rform]
  {\oftp\Gamma{A}{\UU_i} \\ \oftp\Gamma{B}{\UU_i}}
  {\oftp\Gamma{A+B}{\UU_i}}
  \\
  \inferrule*[right=$+$-\rintro${}_1$]
  {\oftp\Gamma{A}{\UU_i} \\ \oftp\Gamma{B}{\UU_i} \\\\ \oftp\Gamma{a}{A}}
  {\oftp\Gamma{\inl(a)}{A+B}}
  \and
  \inferrule*[right=$+$-\rintro${}_2$]
  {\oftp\Gamma{A}{\UU_i} \\ \oftp\Gamma{B}{\UU_i} \\\\ \oftp\Gamma{b}{B}}
  {\oftp\Gamma{\inr(b)}{A+B}}
  \\
  \inferrule*[right=$+$-\relim]
  {\oftp{\Gamma,\tmtp z{(A+B)}}{C}{\UU_i} \\\\
  \oftp{\Gamma,\tmtp xA}{c}{C[\inl(x)/z]} \\
  \oftp{\Gamma,\tmtp yB}{d}{C[\inr(y)/z]} \\\\
  \oftp\Gamma{e}{A+B}}
  {\oftp\Gamma{\ind{A+B}(z.C,x.c,y.d,e)}{C[e/z]}}
  \and
  \inferrule*[right=$+$-\rcomp${}_1$]
  {\oftp{\Gamma,\tmtp z{(A+B)}}{C}{\UU_i} \\
  \oftp{\Gamma,\tmtp xA}{c}{C[\inl(x)/z]} \\
  \oftp{\Gamma,\tmtp yB}{d}{C[\inr(y)/z]} \\\\
  \oftp\Gamma{a}{A}}
  {\jdeqtp\Gamma{\ind{A+B}(z.C,x.c,y.d,\inl(a))}{c[a/x]}{C[\inl(a)/z]}}
  \and
  \inferrule*[right=$+$-\rcomp${}_2$]
  {\oftp{\Gamma,\tmtp z{(A+B)}}{C}{\UU_i} \\
  \oftp{\Gamma,\tmtp xA}{c}{C[\inl(x)/z]} \\
  \oftp{\Gamma,\tmtp yB}{d}{C[\inr(y)/z]} \\\\
  \oftp\Gamma{b}{B}}
  {\jdeqtp\Gamma{\ind{A+B}(z.C,x.c,y.d,\inr(b))}{d[b/y]}{C[\inr(b)/z]}}
\end{mathparpagebreakable}
%
在$\ind{A+B}$中，$z$在$C$中绑定，$x$在$c$中绑定，$y$在$d$中绑定。

\subsection{空类型 \texorpdfstring{$\emptyt$}{0} (The Empty Type \texorpdfstring{$\emptyt$}{0})}

\index{type!empty类型!空|(}%

\begin{mathparpagebreakable}
  \inferrule*[right=$\emptyt$-\rform]
  {\wfctx\Gamma}
  {\oftp\Gamma\emptyt{\UU_i}}
  \and
  \inferrule*[right=$\emptyt$-\relim]
  {\oftp{\Gamma,\tmtp x\emptyt}{C}{\UU_i} \\ \oftp\Gamma{a}{\emptyt}}
  {\oftp\Gamma{\ind{\emptyt}(x.C,a)}{C[a/x]}}
\end{mathparpagebreakable}
%
在$\ind{\emptyt}$中，$x$在$C$中绑定。空类型没有引入规则和计算规则。

\index{type!empty类型!空|)}%

\subsection{单位类型 \texorpdfstring{$\unit$}{1} (The Unit Type \texorpdfstring{$\unit$}{1})}
\label{sec:more-formal-unit}

\index{type!unit类型!单位|(}%

\begin{mathparpagebreakable}
  \inferrule*[right=$\unit$-\rform]
  {\wfctx\Gamma}
  {\oftp\Gamma\unit{\UU_i}}
  \and
  \inferrule*[right=$\unit$-\rintro]
  {\wfctx\Gamma}
  {\oftp\Gamma{\ttt}{\unit}}
  \and
  \inferrule*[right=$\unit$-\relim]
  {\oftp{\Gamma,\tmtp x\unit}{C}{\UU_i} \\
  \oftp{\Gamma}{c}{C[\ttt/x]} \\
  \oftp\Gamma{a}{\unit}}
  {\oftp\Gamma{\ind{\unit}(x.C,c,a)}{C[a/x]}}
  \and
  \inferrule*[right=$\unit$-\rcomp]
  {\oftp{\Gamma,\tmtp x\unit}{C}{\UU_i} \\
  \oftp{\Gamma}{c}{C[\ttt/x]}}
  {\jdeqtp\Gamma{\ind{\unit}(x.C,c,\ttt)}{c}{C[\ttt/x]}}
\end{mathparpagebreakable}
%
在$\ind{\unit}$中，变量$x$在$C$中绑定。

注意，我们没有为单位类型假设判断的唯一性原则；参见\cref{sec:finite-product-types}以获取对应命题唯一性陈述的证明。

\index{type!unit类型!单位|)}%

\subsection{自然数类型 (The Natural Number Type)}

\index{natural numbers自然数|(}%

我们给出自然数的规则，遵循\cref{sec:inductive-types}。

\begin{mathparpagebreakable}
  \def\premise{
    \oftp{\Gamma,\tmtp x{\N}}{C}{\UU_i} \\
    \oftp\Gamma{c_0}{C[0/x]} \\
    \oftp{\Gamma,\tmtp{x}\N,\tmtp y C}{c_s}{C[\suc(x)/x]}}
  %
  \inferrule*[right=$\N$-\rform]
  {\wfctx\Gamma}
  {\oftp\Gamma{\N}{\UU_i}}
  \and
  \inferrule*[right=$\N$-\rintro${}_1$]
  {\wfctx\Gamma}
  {\oftp\Gamma{0}{\N}}
  \and
  \inferrule*[right=$\N$-\rintro${}_2$]
  {\oftp\Gamma{n}{\N}}
  {\oftp\Gamma{\suc(n)}{\N}}
  \and
  \inferrule*[right=$\N$-\relim]
  {\premise \\ \oftp\Gamma{n}{\N}}
  {\oftp\Gamma{\ind{\N}(x.C,c_0,x.y.c_s,n)}{C[n/x]}}
  \and
  \inferrule*[right=$\N$-\rcomp${}_1$]
  {\premise}
  {\jdeqtp\Gamma{\ind{\N}(x.C,c_0,x.y.c_s,0)}{c_0}{C[0/x]}}
  \and
  \inferrule*[right=$$\N$-\rcomp${}_2$]
    {\premise \\ \oftp\Gamma{n}{\N}}
    {\Gamma\vdash
  {\begin{aligned}[t]
     &\ind{\N}(x.C,c_0,x.y.c_s,\suc(n)) \\
     &\quad \jdeq c_s[n,\ind{\N}(x.C,c_0,x.y.c_s,n)/x,y] : C[\suc(n)/x]
  \end{aligned}}}
\end{mathparpagebreakable}
%
在$\ind{\N}$中，$x$在$C$中绑定，$x$和$y$在$c_s$中绑定。

其他归纳定义的类型遵循相同的通用方案。

\index{natural numbers自然数|)}%

\subsection{恒等类型 (Identity Types)}

\label{sec:more-formal-identity}

\index{type!identity类型!恒等|(}%

这里的表述对应于\cref{sec:identity-types}中恒等类型的（非基）路径归纳原理。

\begin{mathparpagebreakable}
\inferrule*[right=$\idsym$-\rform]
{\oftp\Gamma{A}{\UU_i} \\ \oftp\Gamma{a}{A} \\ \oftp\Gamma{b}{A}}
{\oftp\Gamma{\id[A]{a}{b}}{\UU_i}}
\and
\inferrule*[right=$\idsym$-\rintro]
{\oftp\Gamma{A}{\UU_i} \\ \oftp\Gamma{a}{A}}
{\oftp\Gamma{\refl a}{\id[A]aa}}
\and
\inferrule*[right=$\idsym$-\relim]
{\oftp{\Gamma,\tmtp xA,\tmtp yA,\tmtp p{\id[A]xy}}{C}{\UU_i} \\
\oftp{\Gamma,\tmtp zA}{c}{C[z,z,\refl z/x,y,p]} \\
\oftp\Gamma{a}{A} \\ \oftp\Gamma{b}{A} \\ \oftp\Gamma{p'}{\id[A]ab}}
{\oftp\Gamma{\indid{A}(x.y.p.C,z.c,a,b,p')}{C[a,b,p'/x,y,p]}}
\and
\inferrule*[right=$$\idsym$-\rcomp]
{\oftp{\Gamma,\tmtp xA,\tmtp yA,\tmtp p{\id[A]xy}}{C}{\UU_i} \\
\oftp{\Gamma,\tmtp zA}{c}{C[z,z,\refl z/x,y,p]} \\
\oftp\Gamma{a}{A}}
{\jdeqtp\Gamma{\indid{A}(x.y.p.C,z.c,a,a,\refl a)}{c[a/z]}{C[a,a,\refl a/x,y,p]}}
\end{mathparpagebreakable}
%
在$\indid{A}$中，$x$，$y$，和$p$在$C$中绑定，$z$在$c$中绑定。

\index{type!identity类型!恒等|)}%

\subsection{定义 (Definitions)}

\index{definition定义}%

尽管我们列出的规则已经允许我们直接构造所需的一切，但我们仍然希望能够使用命名常量，如$\isequiv$，作为便利手段。非正式地，我们可以将这些常量视为简写，但在形式化中情况稍微复杂一些。

例如，考虑函数组合，它将$f:A\to B$和$g:B\to C$映射到$g\circ f:A\to C$。有些出乎意料的是，为了使这种形式化工作，$\circ$必须不仅接受$f$和$g$，还要接受它们的类型$A$，$B$，$C$作为参数：
%
\begin{narrowmultline*}
{\circ} \defeq \lam{A:\UU_i}{B:\UU_i}{C:\UU_i}
\narrowbreak
\lam{g:B\to C}{f:A\to B}{x:A} g(f(x))。
\end{narrowmultline*}
%
从实际角度看，我们不希望每次应用$\circ$时都注释上$A$，$B$和$C$，因为它们通常可以很容易地从上下文中推断出来。我们希望简单地写$g\circ f$。
然后，严格来说，$g \circ f$并不是$\lam{x : A} g(f(x))$的简写，因为它涉及我们希望省略的附加\define{隐含参数 (implicit arguments)}。
\index{implicit argument隐含参数}

隐含参数的推断、典型模糊性\index{typical ambiguity典型模糊性}（\cref{sec:universes}）、确保符号只定义一次等，统称为\define{精炼 (elaboration)}。\index{elaboration, in type theory类型论中的精炼}
精炼必须在检查推导之前进行，因此通常不被作为核心类型论的一部分来介绍。然而，几乎不可能使用不进行精炼的类型论实现；参见\cite{Coq,norell2007towards}获取进一步讨论。


\section{Homotopy type theory}
\label{sec:hott-features}

In this section we state the additional axioms of homotopy type theory which distinguish it from standard Martin-L\"{o}f type theory: function extensionality, the
univalence axiom, and higher inductive types. We state them in the style
of the second presentation \cref{sec:syntax-more-formally}, although the first presentation \cref{sec:syntax-informally} could be used just as well.

\subsection{Function extensionality and univalence}

There are two basic ways of introducing axioms which do not introduce new syntax or judgmental equalities (function extensionality and univalence are of this form):
either add a primitive constant to inhabit the axiom, or prove all theorems which depend on the axiom by hypothesizing a variable that inhabits the axiom, cf.\ \cref{sec:axioms}.
While these are essentially equivalent, we opt for the former approach because we feel that the axioms of homotopy type theory are an essential part of the core theory.

\index{function extensionality}%
\cref{axiom:funext} is formalized by introduction of a constant $\funext$ which
asserts that $\happly$ is an equivalence:
%
\begin{mathparpagebreakable}
  \inferrule*[right=$\Pi$-\textsc{ext}]
  {\oftp\Gamma{f}{\tprd{x:A} B} \\
   \oftp\Gamma{g}{\tprd{x:A} B}}
  {\oftp\Gamma{\funext(f,g)}{\isequiv(\happly_{f,g})}}
\end{mathparpagebreakable}
%
The definitions of $\happly$ and $\isequiv$ can be found in~\eqref{eq:happly} and
\cref{sec:concluding-remarks}, respectively.

\index{univalence axiom}%
\cref{axiom:univalence} is formalized in a similar fashion, too:
%
\begin{mathparpagebreakable}
  \inferrule*[right=$\UU_i$-\textsc{univ}]
  {\oftp\Gamma{A}{\UU_i} \\
   \oftp\Gamma{B}{\UU_i}}
  {\oftp\Gamma{\univalence(A,B)}{\isequiv(\idtoeqv_{A,B})}}
\end{mathparpagebreakable}
%
The definition of $\idtoeqv$ can be found in~\eqref{eq:uidtoeqv}.

\subsection{The circle}

\index{type!circle}%

Here we give an example of a basic higher inductive type; others follow the same
general scheme, albeit with elaborations.

Note that the rules below do not precisely follow the pattern of the ordinary
inductive types in \cref{sec:syntax-more-formally}: the rules refer to the
notions of transport and functoriality of maps (\cref{sec:functors}), and the
second computation rule is a propositional, not judgmental, equality. These
differences are discussed in \cref{sec:dependent-paths}.

\begin{mathparpagebreakable}
  \inferrule*[right=$\Sn^1$-\rform]
  {\wfctx\Gamma}
  {\oftp\Gamma{\Sn^1}{\UU_i}}
\and
  \inferrule*[right=$\Sn^1$-\rintro${}_1$]
  {\wfctx\Gamma}
  {\oftp\Gamma{\base}{\Sn^1}}
\and
  \inferrule*[right=$\Sn^1$-\rintro${}_2$]
  {\wfctx\Gamma}
  {\oftp\Gamma{\lloop}{\id[\Sn^1]{\base}{\base}}}
\and
  \inferrule*[right=$\Sn^1$-\relim]
  {\oftp{\Gamma,\tmtp x{\Sn^1}}{C}{\UU_i} \\
   \oftp{\Gamma}{b}{C[\base/x]} \\
   \oftp{\Gamma}{\ell}{\dpath C \lloop b b} \\
   \oftp\Gamma{p}{\Sn^1}}
  {\oftp\Gamma{\ind{\Sn^1}(x.C,b,\ell,p)}{C[p/x]}}
\and
  \inferrule*[right=$\Sn^1$-\rcomp${}_1$]
  {\oftp{\Gamma,\tmtp x{\Sn^1}}{C}{\UU_i} \\
   \oftp{\Gamma}{b}{C[\base/x]} \\
   \oftp{\Gamma}{\ell}{\dpath C \lloop b b}}
  {\jdeqtp\Gamma{\ind{\Sn^1}(x.C,b,\ell,\base)}{b}{C[\base/x]}}
\and
  \inferrule*[right=$\Sn^1$-\rcomp${}_2$]
  {\oftp{\Gamma,\tmtp x{\Sn^1}}{C}{\UU_i} \\
   \oftp{\Gamma}{b}{C[\base/x]} \\
   \oftp{\Gamma}{\ell}{\dpath C \lloop b b}}
  {\oftp\Gamma{\Sn^1\text{-}\mathsf{loopcomp}}
    {\id {\apd{(\lamu{y:\Sn^1} \ind{\Sn^1}(x.C,b,\ell,y))}{\lloop}} {\ell}}}
\end{mathparpagebreakable}
%
In $\ind{\Sn^1}$, $x$ is bound in $C$. The notation ${\dpath C \lloop b b}$ for dependent paths was introduced in \cref{sec:dependent-paths}.
\index{rules of type theory|)}%

\section{Basic metatheory}
\index{metatheory|(}%

This section discusses the meta-theoretic properties of the type theory presented in 
\cref{sec:syntax-informally}, and similar results hold for \cref{sec:syntax-more-formally}. Figuring out which of these still hold when we add the features from \cref{sec:hott-features} quickly leads to open questions,\index{open!problem} as discussed at the end of this section.

Recall that \cref{sec:syntax-informally} defines the terms of type theory as
an extension of the untyped $\lambda$-calculus. The $\lambda$-calculus 
has its own notion of computation, namely the computation rule\index{computation rule!for function types}: 
\[
  (\lam{x} t)(u) \defeq t[u/x].
\]
This rule, together with the defining equations for the defined constants form
\emph{rewriting rules}\index{rewriting rule}\index{rule!rewriting} that determine reduction steps for a rewriting 
system. These steps yield a notion of computation in the sense that each rule
has a natural direction: one simplifies $(\lam{x} t)(u)$ by evaluating the
function at its argument.

Moreover, this system is \emph{confluent}\index{confluence}, that is, if $a$ simplifies in some
number of steps to both $a'$ and $a''$, there is some $b$ to which both $a'$ and
$a''$ eventually simplify. Thus we can define $t\conv u$ to mean that $t$ and
$u$ simplify to the same term.

(The situation is similar in \cref{sec:syntax-more-formally}: Although there
we presented the computation rules as undirected equalities $\jdeq$, we can give
an operational semantics by saying that the application of an eliminator to an
introductory form simplifies to its equal, not the other way around.)

Using standard techniques from type theory, it is possible to show that the system in \cref{sec:syntax-informally}
has the following properties:

\begin{thm}\label{thm:conversion-preserves-typing}
If $A : \UU$ and $A \conv A'$ then $A' : \UU$.
If $t:A$ and $t \conv t'$ then $t':A$.
\end{thm}

We say that a term is \define{normalizable}
\indexdef{term!normalizable}%
\index{normalization}%
\indexdef{normalizable term}%
(respectively, \define{strongly
normalizable})
\indexdef{term!strongly normalizable}%
\index{normalization!strong}%
\index{strong!normalization}%
if some (respectively, every), sequence of rewriting steps from the term
terminates.

\begin{thm}\label{thm:strong-normalization}
If $A : \UU$ then $A$ is strongly normalizable.
If $t:A$ then $A$ and $t$ are strongly normalizable.
\end{thm}

We say that a term is in \define{normal form}
\index{normal form}%
\index{term!normal form of}%
if it cannot be further
simplified, and that a term is \define{closed}
\index{closed!term}%
\index{term!closed}%
if no variable occurs freely in
it. A closed normal type has to be a primitive type, i.e., of the form
$c(\vec{v})$ for some primitive constant $c$ (where the list $\vec{v}$ of closed
normal terms may be omitted if empty, for instance, as with $\N$). In fact, we
can explicitly describe all normal forms:

\begin{lem}\label{lem:normal-forms}
  The terms in normal form can be described by the following syntax:
  % 
  \begin{align*}
    v & \production  k \mid \lam{x} v \mid c(\vec{v}) \mid f(\vec{v}), \\
    k &\production x \mid k(v) \mid f(\vec{v})(k),
  \end{align*}
  % 
  where $f(\vec{v})$ represents a partial application of the defined function $f$.
  In particular, a type in normal form is of the form $k$ or $c(\vec{v})$.
\end{lem}

\begin{thm}
  If $A$ is in normal form then the 
  judgment $A : \UU$ is decidable. If $A : \UU$ and $t$ is in normal form then the judgment
  $t:A$ is decidable.
\end{thm}

Logical consistency\index{consistency} (of the system in \cref{sec:syntax-informally}) follows
immediately: if we had $a:\emptyt$ in the empty context, then by
\cref{thm:conversion-preserves-typing,thm:strong-normalization}, $a$
simplifies to a normal term $a':\emptyt$. But by
\cref{lem:normal-forms} no such term exists.

\begin{cor}
 The system in \cref{sec:syntax-informally} is logically consistent.
\end{cor}

Similarly, we have the \emph{canonicity}\indexdef{canonicity} property that if $a:\N$ in the empty
context, then $a$ simplifies to a normal term $\suc^k(0)$ for some numeral $k$.

\begin{cor}
 The system in \cref{sec:syntax-informally} has the canonicity property.
\end{cor}

Finally, if $a,A$ are in normal form, it is \emph{decidable} whether $a:A$; in
other words, because type-checking amounts to verifying the correctness of a
proof, this means we can always ``recognize a correct proof when we see one''.

\begin{cor}
The property of being a proof in the system in \cref{sec:syntax-informally} is decidable.
\end{cor}

\mentalpause

The above results do not apply to the extended system of homotopy type
theory (i.e., the above system extended by \cref{sec:hott-features}), since
occurrences of the univalence axiom and constructors of higher inductive types
never simplify, breaking \cref{lem:normal-forms}. It is an open question\index{open!problem}
whether one can simplify applications of these constants in order to restore
canonicity. We also do not have a schema describing all permissible higher
inductive types, nor are we certain how to correctly formulate their rules
(e.g., whether the computation rules on higher constructors should be judgmental
equalities).

The consistency\index{consistency} of Martin-L\"{o}f type theory extended with univalence and higher
inductive types could be shown by inventing an appropriate normalization procedure, but currently
the only proofs that these systems are consistent are via semantic models---for
univalence, a model in Kan\index{Kan complex} complexes due to Voevodsky \cite{klv:ssetmodel}, and
for higher inductive types, a model due to Lumsdaine and Shulman \cite{ls:hits}.

Other metatheoretic issues, and a summary of our current results, are discussed
in greater length in the ``Constructivity'' and ``Open problems'' sections of
the introduction to this book.

\index{metatheory|)}%

\sectionNotes\label{subsec:general-remarks}

% This presentation is strongly inspired by two  Martin-L\"of 1972 and 1973.

The system of rules with introduction (primitive constants) and elimination
and computation rules (defined constant) is inspired by Gentzen natural
deduction. The possibility of strengthening the elimination rule for
existential quantification was indicated in \cite{howard:pat}. The
strengthening of the axioms for disjunction appears in \cite{Martin-Lof-1972},
and for absurdity elimination and identity type in \cite{Martin-Lof-1973}. The
$W$-types were introduced in \cite{Martin-Lof-1979}. They generalize a notion
of trees introduced by \cite{Tait-1968}.
\index{Martin-L\"of}%

%inspired from unpublished work of Spector.

The generalized form of primitive recursion for natural numbers and ordinals
appear in \cite{Hilbert-1925}. This motivated G\"odel's system $T$,
\cite{Goedel-T-1958}, which was analyzed by \cite{Tait-1966}, who used,
following \cite{Goedel-T-1958}, the terminology ``definitional equality'' for
conversion: two terms are \emph{judgmentally equal} if they reduce to a
common term by means of a sequence of applications of the reduction
rules. This terminology was also used by de Bruijn \cite{deBruijn-1973} in his
presentation of \emph{AUTOMATH}.\index{AUTOMATH}

Our second presentation comprises fairly standard presentation of
intensional Martin-L\"{o}f type theory, with some additional features needed in
homotopy type theory. Compared to a reference presentation of
\cite{hofmann:syntax-and-semantics}, the type theory of this book has a few
non-critical differences:
%
\begin{itemize}
\item universes \`{a} la Russell, in the sense of
\cite{martin-lof:bibliopolis}; and
\item judgmental $\eta$ and function extensionality for $\Pi$ types;
\end{itemize}
and a few features essential for homotopy type theory:
\begin{itemize}
\item the univalence axiom; and
\item higher inductive types.
\end{itemize}
%
As a matter of convenience, the book primarily defines functions by induction
using definition by \emph{pattern matching}.
\index{pattern matching}%
\index{definition!by pattern matching}%
It is possible to formalize the
notion of pattern matching, as done in \cref{sec:syntax-informally}. However, the
standard type-theoretic presentation, adopted in \cref{sec:syntax-more-formally}, is to introduce a single \emph{dependent
eliminator} for each type former, from which functions out of that type must be
defined. This approach is easier to formalize both syntactically and
semantically, as it amounts to the universal property of the type former.
The two approaches are equivalent; see \cref{sec:pattern-matching} for a
longer discussion.

\index{type theory!formal|)}%
\index{formal!type theory|)}%


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "hott-online"
%%% End: 
