\chapter{同伦 $n$-类型 (Homotopy \texorpdfstring{$n$}{n}-types)}
\label{cha:hlevels}

\index{n-type@$n$-type|(}%
\indexsee{h-level}{$n$-type}

同伦理论 (Homotopy Theory) 中的一个基本概念是\emph{同伦 $n$-类型 (Homotopy $n$-type)}：它是一个在维度 $n$ 之上不包含有趣的同伦的空间。例如，一个同伦 $0$-类型 (Homotopy $0$-type) 本质上是一个集合，不包含非平凡路径 (Nontrivial Paths)，而同伦 $1$-类型 (Homotopy $1$-type) 可能包含非平凡路径，但不包含路径之间的非平凡路径。同伦 $n$-类型 (Homotopy $n$-types) 也被称为\emph{$n$-截断空间 ($n$-truncated spaces)}。我们已经在 \cref{sec:basics-sets} 提到了这个概念；我们本章的第一个目标是在同伦类型论 (Homotopy Type Theory) 中给出它的精确定义。

截断性 (Truncatedness) 的对偶概念是连通性 (Connectedness)：一个空间是\emph{$n$-连通 (n-connected)}的，如果它在维度 $n$ 及其以下没有有趣的同伦。例如，一个空间是 $0$-连通 (0-connected) 的（也称为``连通 (Connected)''），如果它只有一个连通分量，而 $1$-连通 (1-connected) 的（也称为``单连通 (Simply Connected)''），如果它也没有非平凡循环 (Nontrivial Loops)（尽管它可能有循环之间的非平凡高阶循环 (Higher Loops)）。

截断性 (Truncatedness) 和连通性 (Connectedness) 之间的对偶性最容易通过扩展这两种概念到映射 (Maps) 来看。我们称一个映射为\emph{$n$-截断 (n-truncated)}或\emph{$n$-连通 (n-connected)}的，如果它的所有纤维 (Fibers) 都是如此。那么 $n$-连通和 $n$-截断映射 (Maps) 形成一个\emph{正交分解系统 (Orthogonal Factorization System)}，即每个映射都唯一地分解为一个 $n$-连通映射和一个 $n$-截断映射。

在 $n={-1}$ 的情况下，$n$-截断映射 (n-truncated maps) 是嵌入 (Embeddings)，而 $n$-连通映射 (n-connected maps) 是满射 (Surjections)，如 \cref{sec:mono-surj} 中所定义。因此，$n$-连通分解系统 (n-connected factorization system) 是函数之间标准的图像分解的一个重大推广，它将集合之间的函数分解为一个满射和一个单射。在本章的最后，我们将简要地概述一个更一般的理论：任何类型理论中的\emph{模态性 (Modality)} 都会产生一个类似的分解系统。

\section{$n$-类型的定义 (Definition of \texorpdfstring{$n$}{n}-types)}
\label{sec:n-types}

如 \cref{sec:basics-sets,sec:contractibility} 所述，从零以下两个级别开始定义 $n$-类型是方便的，其中 $(-1)$-类型是纯命题 (Mere Propositions)，$(-2)$-类型是可收缩的 (Contractible)。

\begin{defn}\label{def:hlevel}
定义谓词 (Predicate) $\istype{n} : \type \to \type$ 对于 $n \geq -2$，其递归定义如下：
\[ \istype{n}(X) \defeq
\begin{cases}
    \iscontr(X) & \text{当 } n = -2 \text{ 时}, \\
    \prd{x,y : X} \istype{n'}(\id[X]{x}{y}) & \text{当 } n = n'+1 \text{ 时}.
\end{cases}
\]
我们称 $X$ 是一个\define{$n$-类型 (n-type)}，有时也称它是\emph{$n$-截断的 ($n$-truncated)}，
\indexdef{n-type@$n$-type}%
\indexsee{n-truncated@$n$-truncated!type}{$n$-type}%
\indexsee{type!n-type@$n$-type}{$n$-type}%
\indexsee{type!n-truncated@$n$-truncated}{$n$-type}%
如果 $\istype{n}(X)$ 是居留的 (Inhabited)。
\end{defn}

\begin{rmk}
    在 \cref{def:hlevel} 中，$n$ 的取值范围包括所有大于或等于 $-2$ 的整数。我们可以通过定义类型 $\Z_{{\geq}-2}$ 这样的整数类型来正式理解这一点（该类型的归纳原理与 $\nat$ 的归纳原理相同），或者定义谓词 $\istype{(k-2)}$ 对于 $k : \nat$。无论哪种方式，我们都可以通过对 $n$ 进行归纳来证明关于 $n$-类型的定理，其中 $n = -2$ 是基本情况。
\end{rmk}

\begin{eg}
    \index{set}
    我们在 \cref{thm:prop-minusonetype} 中已经看到，$X$ 是一个 $(-1)$-类型当且仅当它是一个纯命题 (Mere Proposition)。因此，$X$ 是一个 $0$-类型当且仅当它是一个集合 (Set)。
\end{eg}

我们还看到有些类型不是集合 (\cref{thm:type-is-not-a-set})。然而，到目前为止，我们还没有展示对于任何 $n>0$ 的类型，它们不是 $n$-类型。在 \cref{cha:homotopy} 中，我们将展示 $(n+1)$-球体 $\Sn^{n+1}$ 不是 $n$-类型。（Kraus 还展示了第 $n$ 层嵌套的单值宇宙 (Nested Univalent Universe) 也不是 $n$-类型，而没有使用任何高阶归纳类型 (Higher Inductive Types)）。此外，在 \cref{sec:whitehead} 中，我们将给出一个类型，它不是任何有限数 $n$ 的 $n$-类型。

我们从展示 $n$-类型在某些操作和构造下是封闭的开始，来展开 $n$-类型的一般理论。

\begin{thm}\label{thm:h-level-retracts}
\index{retract!of a type}%
\index{retraction}%
令 $p : X \to Y$ 是一个缩回 (Retraction)，并且假设 $X$ 是一个 $n$-类型，对于任何 $n\geq -2$。那么 $Y$ 也是一个 $n$-类型。
\end{thm}

\begin{proof}
    我们通过对 $n$ 进行归纳来证明。基本情况 $n=-2$ 由 \cref{thm:retract-contr} 处理。

    对于归纳步骤，假设任何 $n$-类型的缩回也是 $n$-类型，并且 $X$ 是一个 $\nplusone$-类型。令 $y, y' : Y$；我们必须证明 $\id{y}{y'}$ 是一个 $n$-类型。令 $s$ 是 $p$ 的一个截面 (Section)，并令 $\epsilon$ 是一个同伦 $\epsilon : p \circ s \htpy 1$。由于 $X$ 是一个 $\nplusone$-类型，$\id[X]{s(y)}{s(y')}$ 是一个 $n$-类型。我们声称 $\id{y}{y'}$ 是 $\id[X]{s(y)}{s(y')}$ 的一个缩回。对于截面，我们取
    \[ \apfunc s : (y=y') \to (s(y)=s(y')) \]
    对于缩回，我们定义 $t:(s(y)=s(y'))\to(y=y')$ 为
    \[ t(q) \defeq  \opp{\epsilon_y} \ct \ap p q \ct \epsilon_{y'} \]
    为了证明 $t$ 是 $\apfunc s$ 的缩回，我们必须证明
    \[ \opp{\epsilon_y} \ct \ap p {\ap sr} \ct \epsilon_{y'} = r \]
    对于任意 $r:y=y'$。但这由 \cref{lem:htpy-natural} 推出。
\end{proof}

作为一个直接的推论，我们得到 $n$-类型在等价 (Equivalence) 下的稳定性（这也是由单值性 (Univalence) 直接得到的）：

\begin{cor}\label{cor:preservation-hlevels-weq}
如果 $\eqv{X}{Y}$ 且 $X$ 是一个 $n$-类型，那么 $Y$ 也是。
\end{cor}

还记得在 \cref{sec:mono-surj} 中的嵌入 (Embedding) 的概念。

\begin{thm}\label{thm:isntype-mono}
\index{function!embedding}
如果 $f:X\to Y$ 是一个嵌入 (Embedding)，并且 $Y$ 是一个 $n$-类型，对于某个 $n\ge -1$，那么 $X$ 也是。
\end{thm}
\begin{proof}
    令 $x,x':X$；我们必须证明 $\id[X]{x}{x'}$ 是一个 $\nminusone$-类型。但是由于 $f$ 是一个嵌入，我们有 $(\id[X]{x}{x'}) \eqvsym (\id[Y]{f(x)}{f(x')})$，而后者根据假设是一个 $\nminusone$-类型。
\end{proof}

注意，当 $n=-2$ 时，这个定理是不成立的：映射 $\emptyt \to \unit$ 是一个嵌入，但 $\unit$ 是一个 $(-2)$-类型，而 $\emptyt$ 不是。

\begin{thm}\label{thm:hlevel-cumulative}
$n$-类型的层次结构是累积的，在以下意义上：给定一个数 $n \geq -2$，如果 $X$ 是一个 $n$-类型，那么它也是一个 $\nplusone$-类型。
\end{thm}

\begin{proof}
    我们通过对 $n$ 进行归纳来证明。

    对于 $n = -2$，我们需要证明一个可收缩类型 (Contractible Type)，例如 $A$，具有可收缩的路径空间 (Path Spaces)。令 $a_0: A$ 为 $A$ 的收缩中心 (Center of Contraction)，并令 $x, y : A$。我们证明 $\id[A]{x}{y}$ 是可收缩的。由于 $A$ 的可收缩性，我们有一条路径 $\contr_x \ct \opp{\contr_y} : x = y$，我们选择它作为 $\id{x}{y}$ 的收缩中心。给定任何路径 $p : x = y$，我们需要证明 $p = \contr_x \ct \opp{\contr_y}$。通过路径归纳 (Path Induction)，只需证明 $\refl{x} = \contr_x \ct \opp{\contr_x}$，这是显然的。

    对于归纳步骤，我们需要证明 $\id[X]{x}{y}$ 是一个 $\nplusone$-类型，前提是 $X$ 是一个 $\nplusone$-类型。将归纳假设应用于 $\id[X]{x}{y}$，即可得出所需结论。
\end{proof}

% \section{Preservation under constructors}
% \label{sec:ntype-pres}

现在我们展示 $n$-类型在大多数类型构造操作下的保留性。

\begin{thm}\label{thm:ntypes-sigma}
设 $n \geq -2$，并令 $A : \type$ 和 $B : A \to \type$。如果 $A$ 是一个 $n$-类型，并且对于所有 $a : A$，$B(a)$ 是一个 $n$-类型，那么 $\sm{x : A} B(x)$ 也是一个 $n$-类型。
\end{thm}

\begin{proof}
    我们通过对 $n$ 进行归纳来证明。

    对于 $n = -2$，我们选择 $\sm{x : A} B(x)$ 的收缩中心为 $(a_0, b_0)$，其中 $a_0 : A$ 是 $A$ 的收缩中心，$b_0 : B(a_0)$ 是 $B(a_0)$ 的收缩中心。给定 $\sm{x : A} B(x)$ 的任何其他元素 $(a,b)$，我们通过分别对 $A$ 和 $B(a_0)$ 的收缩性提供路径 $\id{(a, b)}{(a_0,b_0)}$。

    对于归纳步骤，假设 $A$ 是一个 $\nplusone$-类型，并且对于任意 $a : A$，$B(a)$ 是一个 $\nplusone$-类型。我们证明 $\sm{x : A} B(x)$ 是一个 $\nplusone$-类型：固定 $\sm{x : A} B(x)$ 中的 $(a_1, b_1)$ 和 $(a_2,b_2)$，我们需要证明 $\id{(a_1, b_1)}{(a_2,b_2)}$ 是一个 $n$-类型。根据 \cref{thm:path-sigma}，我们有
    \[ \eqvspaced{(\id{(a_1, b_1)}{(a_2,b_2)})}{\sm{p : \id{a_1}{a_2}} (\id[B(a_2)]{\trans{p}{b_1}}{b_2})} \]
    并且根据等价下 $n$-类型的保留性 (\cref{cor:preservation-hlevels-weq})，我们只需证明后者是一个 $n$-类型。这可以通过归纳假设得到。
\end{proof}

作为一个特例，如果 $A$ 和 $B$ 是 $n$-类型，那么 $A\times B$ 也是。还要注意，\cref{thm:hlevel-cumulative} 意味着如果 $A$ 是一个 $n$-类型，那么对于任意 $x,y:A$，$\id[A]xy$ 也是一个 $n$-类型。将此与 \cref{thm:ntypes-sigma} 结合，我们可以看到，对于 $n$-类型的函数 $f:A\to C$ 和 $g:B\to C$，它们的纤维积 (Pullback)
\[ A\times_C B \defeq \sm{x:A}{y:B} (f(x)=g(y)) \]
（参见 \cref{ex:pullback}）也是一个 $n$-类型。更一般地说，$n$-类型在所有\emph{极限 (Limits)}下是封闭的。

\begin{thm}\label{thm:hlevel-prod}
令 $n\geq -2$，并令 $A : \type$ 和 $B : A \to \type$。如果对于所有 $a : A$，$B(a)$ 是一个 $n$-类型，那么 $\prd{x : A} B(x)$ 也是一个 $n$-类型。
\end{thm}

\begin{proof}
    我们通过对 $n$ 进行归纳来证明。对于 $n = -2$，结果就是 \cref{thm:contr-forall}。

    对于归纳步骤，假设结果对于 $n$-类型成立，并且每个 $B(a)$ 都是一个 $\nplusone$-类型。令 $f, g : \prd{a:A}B(a)$。我们需要证明 $\id{f}{g}$ 是一个 $n$-类型。通过函数扩展性 (Function Extensionality) 和等价下 $n$-类型的封闭性，证明 $\prd{a : A} (\id[B(a)]{f(a)}{g(a)})$ 是一个 $n$-类型即可。这个结论可通过归纳假设得到。
\end{proof}

作为上述定理的一个特例，函数空间 $A \to B$ 是一个 $n$-类型，前提是 $B$ 是一个 $n$-类型。我们现在可以推广在 \cref{cha:basics} 中关于 $\isset(A)$ 和 $\isprop(A)$ 是纯命题的观察。

\begin{thm}\label{thm:isaprop-isofhlevel}
对于任何 $n \geq -2$ 和任何类型 $X$，类型 $\istype{n}(X)$ 是一个纯命题。
\end{thm}
\begin{proof}
    我们通过对 $n$ 进行归纳来证明。

    对于基本情况，我们需要证明对于任何 $X$，类型 $\iscontr(X)$ 是一个纯命题。这是 \cref{thm:isprop-iscontr}。

    对于归纳步骤，我们需要证明
    \[\prd{X : \type} \isprop (\istype{n}(X)) \to \prd{X : \type} \isprop (\istype{\nplusone}(X))。\]
    要证明这个推论的结论，我们需要证明对于任何类型 $X$，类型
    \[\prd{x, x' : X}\istype{n}(x = x')\]
    是一个纯命题。根据 \cref{thm:isprop-forall} 或 \cref{thm:hlevel-prod}，只需证明对于任何 $x, x' : X$，类型 $\istype{n}(x =_X x')$ 是一个纯命题即可。这可由归纳假设应用于类型 $(x =_X x')$ 得到。
\end{proof}

最后，我们展示 $n$-类型的类型本身是一个 $\nplusone$-类型。我们将其定义为：
\symlabel{universe-of-ntypes}
\[\ntype{n} \defeq \sm{X : \type} \istype{n}(X)。\]
如有必要，我们可以通过写成 $\ntypeU{n}$ 来指定宇宙 $\UU$。特别地，我们有 $\prop \defeq \ntype{(-1)}$ 和 $\set \defeq \ntype{0}$，如 \cref{cha:basics} 中定义的。注意，由于 $\istype{n}(X)$ 是一个纯命题，根据 \cref{thm:path-subset} 对于任何 $(X,p), (X',p'):\ntype{n}$，我们有
\begin{align*}
    \Big(\id[\ntype{n}]{(X, p)}{(X', p')}\Big) &\eqvsym (\id[\type] X X')\\
    &\eqvsym (\eqv{X}{X'})。
\end{align*}

\begin{thm}\label{thm:hleveln-of-hlevelSn}
对于任何 $n \geq -2$，类型 $\ntype{n}$ 是一个 $\nplusone$-类型。
\end{thm}
\begin{proof}%[Proof of \cref{thm:hleveln-of-hlevelSn}]
    令 $(X, p), (X', p') : \ntype{n}$；我们需要证明 $\id{(X, p)}{(X', p')}$ 是一个 $n$-类型。根据上述观察，这个类型等价于 $\eqv{X}{X'}$。接下来，我们观察到投影
    \[(\eqv{X}{X'}) \to (X \rightarrow X').\]
    是一个嵌入，因此如果 $n\geq -1$，根据 \cref{thm:isntype-mono}，只需证明 $X \rightarrow X'$ 是一个 $n$-类型即可。但是，由于 $n$-类型在箭头类型下是封闭的，这归结为假设 $X'$ 是一个 $n$-类型。

    在 $n=-2$ 的情况下，这个论证表明 $\eqv{X}{X'}$ 是一个 $(-1)$-类型——但它也是居留的，因为任何两个可收缩类型都等价于 \unit，因此彼此等价。因此，$\eqv{X}{X'}$ 也是一个 $(-2)$-类型。
\end{proof}

\section{同一性证明的唯一性与 Hedberg 定理 (Uniqueness of identity proofs and Hedberg's theorem)}
\label{sec:hedberg}

\index{set|(}%

在 \cref{sec:basics-sets} 中，我们定义了一个类型 $X$ 是\emph{集合 (Set)}，如果对于所有 $x, y : X$ 和 $p, q : x =_X y$ 我们有 $p = q$。在传统类型论中，这个属性称为\define{同一性证明的唯一性 (Uniqueness of Identity Proofs, UIP)}。
\indexdef{uniqueness!of identity proofs}%
我们还看到它等价于上一节中 $0$-类型的定义。这里是另一个等价的刻画，涉及到 Streicher 的``公理 K (Axiom K)'' \cite{Streicher93}：

\begin{thm}\label{thm:h-set-uip-K}
一个类型 $X$ 是集合 (Set)，当且仅当它满足\define{公理 K (Axiom K)}：对于所有 $x : X$ 和 $p : (x =_A x)$ 我们有 $p = \refl{x}$。
\indexdef{axiom!Streicher's Axiom K}%
\end{thm}

\begin{proof}
    显然，公理 K 是 UIP 的特例。反之，如果 $X$ 满足公理 K，则令 $x, y : X$ 和 $p, q : (\id{x}{y})$；我们想要证明 $p=q$。但是对 $q$ 进行归纳 (Induction) 将这个目标精简为公理 K。
\end{proof}

我们强调，\emph{我们}并不假设 UIP 或 K 原理作为公理！它们只是某一特定类型可能或可能不满足的属性（它们等价于集合）。回忆 \cref{thm:type-is-not-a-set}，并非所有类型都是集合。

下面的定理是另一个证明类型为集合的有用方法。

\begin{thm}\label{thm:h-set-refrel-in-paths-sets}
\index{relation!reflexive}%
假设 $R$ 是一个在类型 $X$ 上的反身纯关系 (Reflexive Mere Relation)，它暗含了同一性 (Identity)。那么 $X$ 是集合，并且对于所有 $x,y:X$，$R(x,y)$ 等价于 $\id[X]{x}{y}$。
\end{thm}

\begin{proof}
    令 $\rho : \prd{x:X} R(x,x)$ 证明 $R$ 的反身性，并令 \narrowequation{f : \prd{x,y:X} R(x,y) \to (\id[X]{x}{y})} 证明 $R$ 暗含同一性。首先，定理中的两个陈述是等价的。一方面，如果 $X$ 是一个集合，那么 $\id[X]xy$ 是一个纯命题，并且由于它在逻辑上等价于纯命题 $R(x,y)$，根据假设，它也必须等价于它。另一方面，如果 $\id[X]xy$ 等价于 $R(x,y)$，那么与后者一样，对于所有 $x,y:X$，它是一个纯命题，因此 $X$ 是一个集合。

    我们给出两种证明这个定理的方法。第一种直接证明 $X$ 是一个集合；第二种直接证明 $R(x,y)\eqvsym (x=y)$。

    \emph{第一种证明：} 我们证明 $X$ 是一个集合。这个思路与 \cref{thm:prop-set} 相同：函数 $f$ 必须在其参数 $x$ 和 $y$ 中是连续的。然而，由于我们必须处理额外的 $R(x,y)$ 类型的参数，符号表达上稍微复杂一些。

    首先，对于任何 $x:X$ 和 $p:\id[X]xx$，考虑 $\apdfunc{f(x)}(p)$。这是一个从 $f(x,x)$ 到它自身的依赖路径 (Dependent Path)。由于 $f(x,x)$ 仍然是一个函数 $R(x,x) \to (\id[X]xx)$，根据 \cref{thm:dpath-arrow}，这给出了对于任何 $r:R(x,x)$ 的路径
    \[\trans{p}{f(x,x,r)} = f(x,x,\trans{p}r)。\]
    在左侧，我们有同一类型中的传输 (Transport)，即连接。在右侧，我们有 $\trans{p}r = r$，因为它们都属于纯命题 $R(x,x)$。因此，替代 $r\defeq \rho(x)$，我们得到
    \[ f(x,x,\rho(x)) \ct p = f(x,x,\rho(x))。\]
    通过消去得到 $p=\refl{x}$。所以 $X$ 满足公理 K，因此是一个集合。

    \emph{第二种证明：} 我们证明每个 $f(x,y) : R(x,y) \to \id[X]{x}{y}$ 是一个等价 (Equivalence)。根据 \cref{thm:total-fiber-equiv}，我们只需证明 $f$ 在总空间 (Total Space) 上诱导了一个等价：
    \begin{equation*}
        \eqv{\Parens{\sm{y:X}R(x,y)}}{\Parens{\sm{y:X}\id[X]{x}{y}}}。
    \end{equation*}
    根据 \cref{thm:contr-paths}，右侧的类型是可收缩的，因此只需证明左侧的类型是可收缩的。我们选择对 $(x,\rho(x))$ 的对作为收缩中心。剩下的就是对每个 ${y:X}$ 和每个 ${H:R(x,y)}$ 证明
    \begin{equation*}
        \id{\pairr{x,\rho(x)}}{\pairr{y,H}}。
    \end{equation*}
    但由于 $R(x,y)$ 是一个纯命题，根据 \cref{thm:path-sigma}，我们只需证明 $\id[X]{x}{y}$，这是从 $f(H)$ 得到的。
\end{proof}

\begin{cor}\label{notnotstable-equality-to-set}
如果一个类型 $X$ 具有属性 $\neg\neg(x=y)\to(x=y)$ 对于任何 $x,y:X$，那么 $X$ 是一个集合。
\end{cor}

另一种方便的方法来证明一个类型是集合如下。回忆 \cref{sec:intuitionism}，一个类型 $X$ 被认为具有\emph{可判定等同性 (Decidable Equality)}，如果对于所有 $x, y : X$ 我们有
\[(x =_X y) + \neg (x =_X y)。\]
\index{continuity of functions in type theory@``continuity'' of functions in type theory}%
\index{functoriality of functions in type theory@``functoriality'' of functions in type theory}%
这是一种非常强的条件：它意味着当路径存在时，$x=y$ 可以在 $x$ 和 $y$ 中连续（或可计算，或函子化）地选择出来。通过 \cref{thm:h-set-refrel-in-paths-sets} 和下面的引理，这最终会导致 $X$ 是一个集合。

\begin{lem}\label{lem:hedberg-helper}
对于任何类型 $A$，我们有 $(A+\neg A)\to(\neg\neg A\to A)$。
\end{lem}

\begin{proof}
    这在本质上已经在 \cref{thm:not-lem} 中证明过了，但我们重复这个论证。假设 $x:A+\neg A$。我们有两个情况需要考虑。如果 $x$ 是某个 $a:A$ 的 $\inl(a)$，那么我们有一个常函数 $\neg\neg A \to A$，它将所有内容映射到 $a$。如果 $x$ 是某个 $t:\neg A$ 的 $\inr(t)$，我们有 $g(t):\emptyt$ 对于每个 $g:\neg\neg A$。因此，我们可以使用\emph{从错误中推出任何结论}，即 $\rec{\emptyt}$，对任意 $g:\neg\neg A$ 得到一个 $A$ 的元素。
\end{proof}

\index{anger}
\begin{thm}[Hedberg]\label{thm:hedberg}
\index{Hedberg's theorem}%
\index{theorem!Hedberg's}%
如果 $X$ 具有可判定等同性 (Decidable Equality)，那么 $X$ 是一个集合。
\end{thm}

\begin{proof}
    如果 $X$ 具有可判定等同性，则对于任何 $x,y:X$，$\neg\neg(x=y)\to(x=y)$ 成立。因此，Hedberg 定理从 \cref{notnotstable-equality-to-set} 推出。
\end{proof}

当然，这个定理与 \cref{thm:not-lem} 有很强的联系。被 \cref{thm:not-lem} 否定的 \LEM{\infty} 陈述显然意味着每个类型都有可判定等同性，因此是一个集合，这我们知道并非如此。
\index{excluded middle}%
请注意，一致的公理 \LEM{} 从 \cref{sec:intuitionism} 推出仅意味着每个类型具有\emph{仅仅是可判定等同性 (Merely Decidable Equality)}，即对于任何 $A$ 我们有
\indexdef{equality!merely decidable}%
\indexdef{merely!decidable equality}%
\[ \prd{a,b:A} (\brck{a=b} + \neg\brck{a=b})。\]

\index{decidable!equality|)}%

作为 \cref{thm:hedberg} 的一个应用实例，回忆在 \cref{thm:nat-set} 中我们观察到 $\nat$ 是一个集合，通过 \cref{sec:compute-nat} 中我们对其等同性类型的刻画。
更传统的证明这个定理的方法仅使用~\eqref{eq:zero-not-succ} 和~\eqref{eq:suc-injective}，而不是 \cref{thm:path-nat} 的完整刻画，使用 \cref{thm:hedberg} 来填补空白。

\begin{thm}\label{prop:nat-is-set}
自然数类型 $\nat$ 具有可判定等同性，因此是一个集合。
\end{thm}

\begin{proof}
    令 $x, y : \nat$ 被给定；我们通过对 $x$ 进行归纳和对 $y$ 进行情况分析来证明 $(x=y)+\neg(x=y)$。如果 $x \jdeq 0$ 且 $y \jdeq 0$，我们取 $\inl(\refl0)$。如果 $x \jdeq 0$ 且 $y \jdeq \suc(n)$，则根据~\eqref{eq:zero-not-succ} 我们得到 $\neg (0 = \suc (n))$。

    对于归纳步骤，令 $x \jdeq \suc (n)$。如果 $y \jdeq 0$，我们再次使用~\eqref{eq:zero-not-succ}。最后，如果 $y \jdeq \suc (m)$，归纳假设给出 $(m = n)+\neg(m = n)$。在第一种情况下，如果 $p:m=n$，那么 $\ap \suc p:\suc(m)=\suc(n)$。在第二种情况下，~\eqref{eq:suc-injective} 导致 $\neg(\suc(m)=\suc(n))$。
\end{proof}

\index{set|)}%

\index{axiom!Streicher's Axiom K!generalization to n-types@generalization to $n$-types}%
尽管 Hedberg 定理看起来对集合（$0$-类型）特别适用，``公理 K (Axiom K)'' 自然地推广到 $n$-类型。请注意，普通的公理 K（作为类型 $X$ 的属性）陈述为对于所有 $x:X$，环空间 (Loop Space) $\Omega(X,x)$（见 \cref{def:loopspace}）是可收缩的 (Contractible)。由于 $\Omega(X,x)$ 总是居留的（通过 $\refl{x}$），这等价于它是一个纯命题（一个 $(-1)$-类型）。由于 $0 = (-1)+1$，这提出了以下推广。

\begin{thm}\label{thm:hlevel-loops}
对于任何 $n\geq -1$，类型 $X$ 是一个 $\nplusone$-类型，当且仅当对于所有 $x : X$，类型 $\Omega(X, x)$ 是一个 $n$-类型。
\end{thm}

在证明此之前，我们先证明一个辅助引理：

\begin{lem}\label{lem:hlevel-if-inhab-hlevel}
给定 $n \geq -1$ 和 $X : \type$。如果给定 $X$ 的任何居留元素就能推出 $X$ 是一个 $n$-类型，那么 $X$ 是一个 $n$-类型。
\end{lem}
\begin{proof}
    令 $f : X \to \istype{n}(X)$ 是给定的映射。我们需要证明对于任何 $x, x' : X$，类型 $\id{x}{x'}$ 是一个 $\nminusone$-类型。但是 $f(x)$ 表明 $X$ 是一个 $n$-类型，因此它的所有路径空间 (Path Spaces) 都是 $\nminusone$-类型。
\end{proof}

\begin{proof}[Proof of \cref{thm:hlevel-loops}]
    ``如果''的方向是显然的，因为 $\Omega(X,x)\defeq (\id[X]xx)$。反之，为了证明 $X$ 是一个 $\nplusone$-类型，我们需要证明对于任何 $x, x' : X$，类型 $\id{x}{x'}$ 是一个 $n$-类型。根据 \cref{lem:hlevel-if-inhab-hlevel}，只需给出一个映射
    \[ (\id{x}{x'}) \to \istype{n}(\id{x}{x'})。\]
    通过路径归纳 (Path Induction)，只需证明当 $x\jdeq x'$ 时，这来自于假设 $\Omega(X, x)$ 是一个 $n$-类型。
\end{proof}

\index{whiskering}
通过归纳和一些巧妙的刷操作 (Whiskering)，我们可以将 K 属性推广到 $n>0$。

\begin{thm}\label{thm:ntype-nloop}
\index{loop space!iterated}%
对于每个 $n\ge -1$，一个类型 $A$ 是一个 $n$-类型，当且仅当对于所有 $a:A$，$\Omega^{n+1}(A,a)$ 是可收缩的。
\end{thm}
\begin{proof}
    回忆 $\Omega^0(A,a) = (A,a)$，$n=-1$ 的情况是 \cref{ex:prop-inhabcontr}。$n=0$ 的情况是 \cref{thm:h-set-uip-K}。现在我们使用归纳法；假设该陈述对 $n:\N$ 成立。根据 \cref{thm:hlevel-loops}，$A$ 是一个 $(n+1)$-类型，当且仅当对于所有 $a:A$，$\Omega(A,a)$ 是一个 $n$-类型。根据归纳假设，后者等价于 $\Omega^{n+1}(\Omega(A,a),p)$ 对于所有 $p:\Omega(A,a)$ 是可收缩的。

    由于 $\Omega^{n+2}(A,a) \defeq \Omega^{n+1}(\Omega(A,a),\refl{a})$，并且 $\Omega^{n+1} = \Omega^n \circ \Omega$，它将足以证明 $\Omega(\Omega(A,a),p)$ 等于 $\Omega(\Omega(A,a),\refl{a})$，在类型 $\pointed\type$ 中。为此，只需给出一个等价
    \[ g : \Omega(\Omega(A,a),p) \eqvsym \Omega(\Omega(A,a),\refl{a}) \]
    它将基点 (Basepoint) $\refl{p}$ 映射到基点 $\refl{\refl{a}}$。对于 $q:p=p$，定义 $g(q):\refl{a} = \refl{a}$ 为以下复合：
    \[ \refl{a} = p\ct \opp p \overset{q}{=} p\ct\opp p = \refl{a}，\]
    其中标有 ``$q$'' 的路径实际上是 $\apfunc{\lam{r} r\ct\opp p} (q)$。然后 $g$ 是一个等价，因为它是等价的复合
    \[ (p=p) \xrightarrow{\apfunc{\lam{r} r\ct\opp p}} (p\ct \opp p = p\ct \opp p) \xrightarrow{i\ct - \ct \opp i} (\refl{a} = \refl{a})。\]
    使用 \cref{eg:concatequiv,thm:paths-respects-equiv}，其中 $i:\refl{a} = p\ct \opp p$ 是规范等价。显然，$g(\refl{p}) = \refl{\refl{a}}$。
\end{proof}

\section{截断 (Truncations)}
\label{sec:truncations}

\indexsee{n-truncation@$n$-truncation}{truncation}%
\index{truncation!n-truncation@$n$-truncation|(defstyle}%

在 \cref{subsec:prop-trunc} 中，我们介绍了命题截断 (Propositional Truncation)，它提供了某个类型作为一个纯命题（即 $(-1)$-类型）的``最佳近似''。在 \cref{sec:hittruncations} 中，我们将此截断构造为一个高阶归纳类型 (Higher Inductive Type)，并给出了将其推广为 0-截断的一种方法。现在，我们将解释一种更好的推广方式，它将任意类型截断为任意 $n\geq -2$ 的 $n$-类型；在经典同伦理论中，这被称为其 \define{$n^{\mathrm{th}}$ Postnikov 截断 (Postnikov section)}。\index{Postnikov tower}

其思想是利用 \cref{thm:ntype-nloop}，该定理表明 $A$ 是一个 $n$-类型，当且仅当 $\Omega^{n+1}(A,a)$ \index{loop space!iterated}%
对于所有 $a:A$ 是可收缩的，并且利用 \cref{lem:susp-loop-adj}，该引理暗示 \narrowequation{\Omega^{n+1}(A,a) \eqvsym \Map_{*}(\Sn^{n+1},(A,a))}，其中 $\Sn^{n+1}$ 配备了一些基点 (Basepoint)，我们不妨称其为 \base。然而，通过给出路径构造子，可以直接确保 $\Map_*(\Sn^{n+1},(A,a))$ 的可收缩性。

\index{hub and spoke}%
我们将使用 ``轮毂和辐条'' 构造 (Hub and Spoke Construction)，如 \cref{sec:hubs-spokes} 所述。因此，对于 $n\ge -1$，我们将 $\trunc nA$ 视为由以下构造生成的高阶归纳类型：
\begin{itemize}
    \item 一个函数 $\tprojf n : A \to \trunc n A$，
    \item 对于每个 $r:\Sn^{n+1} \to \trunc n A$，一个\emph{轮毂 (Hub)} 点 $h(r):\trunc n A$，以及
    \item 对于每个 $r:\Sn^{n+1} \to \trunc n A$ 和每个 $x:\Sn^{n+1}$，一个\emph{辐条 (Spoke)} 路径 $s_r(x):r(x) = h(r)$。
\end{itemize}

\noindent 这些构造子的存在足以证明：

\begin{lem}
    $\trunc n A$ 是一个 $n$-类型。
\end{lem}
\begin{proof}
    根据 \cref{thm:ntype-nloop}，只需证明 $\Omega ^{n+1}(\trunc nA,b)$ 对于所有 $b:\trunc nA$ 是可收缩的，根据 \cref{lem:susp-loop-adj} 这等价于 \narrowequation{\Map_*(\Sn^{n+1},(\trunc nA,b))}。作为后者的收缩中心，我们选择常数为 $b$ 的函数 $c_b:\Sn^{n+1} \to \trunc nA$，以及 $\refl b : c_b(\base) = b$。

    现在，$\Map_*(\Sn^{n+1},(\trunc nA,b))$ 的任意元素由一个映射 $r:\Sn^{n+1} \to \trunc n A$ 以及一个路径 $p:r(\base)=b$ 组成。根据函数外延性 (Function Extensionality)，为了证明 $r = c_b$，只需给出每个 $x:\Sn^{n+1}$ 的路径 $r(x)=c_b(x) \jdeq b$。我们选择它为复合路径 $s_r(x) \ct \opp{s_r(\base)} \ct p$，其中 $s_r(x)$ 是 $x$ 处的辐条路径。

    最后，我们必须证明当沿着这个等式 $r=c_b$ 进行传递时，路径 $p$ 变为 $\refl b$。通过路径类型中的传递，这意味着我们需要
    \[\opp{(s_r(\base) \ct \opp{s_r(\base)} \ct p)} \ct p = \refl b。\]
    但这是通过路径运算立即得出的。
\end{proof}

（这种构造对 $n=-2$ 失效，但在这种情况下我们可以简单地定义 $\trunc{-2}{A}\defeq \unit$ 对于所有 $A$。从现在起我们假设 $n\ge -1$。）

\index{induction principle!for truncation}%
为了展示 $n$-截断的预期通用性质 (Universal Property)，我们需要归纳原理 (Induction Principle)。我们按照通常的方式从构造子中提取它；它表明，给定 $P:\trunc nA\to\type$ 以及以下内容：
\begin{itemize}
    \item 对于每个 $a:A$，一个元素 $g(a) : P(\tproj na)$，
    \item 对于每个 $r:\Sn^{n+1} \to \trunc n A$ 和 $r':\prd{x:\Sn^{n+1}} P(r(x))$，一个元素 $h'(r,r'):P(h(r))$，
    \item 对于每个 $r:\Sn^{n+1} \to \trunc n A$ 和 $r':\prd{x:\Sn^{n+1}} P(r(x))$，以及每个 $x:\Sn^{n+1}$，一个依赖路径 $\dpath{P}{s_r(x)}{r'(x)}{h'(r,r')}$，
\end{itemize}
存在一个截面 $f:\prd{x:\trunc n A} P(x)$，其中 $f(\tproj n a) \jdeq g(a)$ 对于所有 $a:A$ 成立。为了使其更有用，我们将其重新表述如下。

\begin{thm}\label{thm:truncn-ind}
对于任意类型族 $P:\trunc n A \to \type$，使得每个 $P(x)$ 是一个 $n$-类型，并且任意函数 $g : \prd{a:A} P(\tproj n a)$，存在一个截面 $f:\prd{x:\trunc n A} P(x)$，使得 $f(\tproj n a)\defeq g(a)$ 对于所有 $a:A$ 成立。
\end{thm}
\begin{proof}
    只需构造上述列出的第二个和第三个数据，因为 $g$ 的类型与第一个数据完全一致。给定 $r:\Sn^{n+1} \to \trunc n A$ 和 $r':\prd{x:\Sn^{n+1}} P(r(x))$，我们有 $h(r):\trunc n A$ 和 $s_r :\prd{x:\Sn^{n+1}} (r(x) = h(r))$。定义 $t:\Sn^{n+1} \to P(h(r))$ 为 $t(x) \defeq \trans{s_r(x)}{r'(x)}$。然后由于 $P(h(r))$ 是 $n$-截断的，因此存在一个点 $u:P(h(r))$ 和一个收缩 $v:\prd{x:\Sn^{n+1}} (t(x) = u)$。定义 $h'(r,r') \defeq u$，提供了第二个数据。然后（回忆依赖路径的定义），$v$ 正好具有第三个数据所需的类型。
\end{proof}

特别地，如果 $E$ 是某个 $n$-类型，我们可以考虑在 $A$ 的每个点上等于 $E$ 的常数类型族 (Constant Family of Types)。\symlabel{extend} \index{recursion principle!for truncation}%
因此，每个映射 $f:A\to{}E$ 都可以扩展为映射 $\extend{f}:\trunc nA\to{}E$，定义为 $\extend{f}(\tproj na)\defeq f(a)$；这是 $\trunc n A$ 的\emph{递归原理 (Recursion Principle)}。

归纳原理还暗示了这种形式的函数的唯一性原理。\index{uniqueness!principle, propositional!for functions on a truncation}%
也就是说，如果 $E$ 是一个 $n$-类型，并且 $g,g':\trunc nA\to{}E$ 满足 $g(\tproj na)=g'(\tproj na)$ 对于每个 $a:A$，那么 $g(x)=g'(x)$ 对于所有 $x:\trunc nA$ 成立，因为类型 $g(x)=g'(x)$ 是一个 $n$-类型。因此，$g=g'$。（实际上，当 $E$ 是一个 $(n+1)$-类型时，这个唯一性原理在更广泛的情况下也是成立的。）这产生了以下通用性质。

\begin{lem}[截断的通用性质 (Universal Property of Truncations)]\label{thm:trunc-reflective}
\index{universal!property!of truncation}%
设 $n\ge-2$，$A:\type$ 和 $B:\typele{n}$。以下映射是一个等价：
\[\function{(\trunc nA\to{}B)}{(A\to{}B)}{g}{g\circ\tprojf n}\]
\end{lem}

\begin{proof}
    考虑到 $B$ 是 $n$-截断的，任意 $f:A\to{}B$ 可以扩展为映射 $\extend{f}:\trunc nA\to{}B$。映射 $\extend{f}\circ\tprojf n$ 等于 $f$，因为对于每个 $a:A$，我们有 $\extend{f}(\tproj na)=f(a)$ 根据定义。而映射 $\extend{g\circ\tprojf n}$ 等于 $g$，因为它们都将 $\tproj na$ 映射到 $g(\tproj na)$。
\end{proof}

在范畴语言中，这意味着 $n$-类型形成了类型范畴 (Category of Types) 的一个\emph{反射子范畴 (Reflective Subcategory)}。\index{reflective!subcategory}%
（为了完全精确地陈述这一点，应使用 $(\infty,1)$-范畴的语言。）
\index{.infinity1-category@$(\infty,1)$-category}%
特别地，这意味着 $n$-截断是函子性的：给定 $f:A\to B$，将递归原理应用于复合 $A\xrightarrow{f} B \to \trunc n B$ 产生映射 $\trunc n f: \trunc n A \to \trunc n B$。根据定义，我们有一个同伦
\begin{equation}
    \mathsf{nat}^f_n : \prd{a:A} \trunc n f(\tproj n a) = \tproj n {f(a)},\label{eq:trunc-nat}
\end{equation}
表达了映射 $\tprojf n$ 的\emph{自然性 (Naturality)}。

唯一性暗示了函子性定律 (Functoriality Laws)，例如 $\trunc n {g\circ f} = \trunc n g \circ \trunc n f$ 和 $\trunc n{\idfunc[A]} = \idfunc[\trunc n A]$，以及随附的相干性定律 (Coherence Laws)。我们还有更高的函子性，例如：

\begin{lem}\label{thm:trunc-htpy}
给定 $f,g:A\to B$ 和一个同伦 $h:f\htpy g$，存在一个诱导的同伦 $\trunc n h : \trunc n f \htpy \trunc n g$，使得复合
\begin{equation}
    \xymatrix@C=3.6pc{\tproj n{f(a)} \ar@{=}[r]^-{\opp{\mathsf{nat}^f_n(a)}} &
    \trunc n f(\tproj n a) \ar@{=}[r]^-{\trunc n h(\tproj na)} &
    \trunc n g(\tproj n a) \ar@{=}[r]^-{\mathsf{nat}^g_n(a)} &
    \tproj n{g(a)}}\label{eq:trunc-htpy}
\end{equation}
等于 $\apfunc{\tprojf n}(h(a))$。
\end{lem}
\begin{proof}
    首先，我们确实有一个同伦，其分量为 $\apfunc{\tprojf n}(h(a)) : \tproj n{f(a)} = \tproj n{g(a)}$。在两侧复合由 $\trunc n f$ 和 $\trunc ng$ 的定义产生的路径 $\tproj n{f(a)} = \trunc n f(\tproj n a)$ 和 $\tproj n{g(a)} = \trunc n g(\tproj n a)$，我们获得了一个同伦 $(\trunc n f \circ \tprojf n) \htpy (\trunc n g \circ \tprojf n)$，因此根据函数外延性有一个等式。但是由于 $(\blank\circ \tprojf n)$ 是一个等价，必须有一个路径 $\trunc nf = \trunc ng$ 来诱导它，并且函数外延性的相干性定律暗示了~\eqref{eq:trunc-htpy}。
\end{proof}

关于反射子范畴的以下观察也是标准的。

\begin{cor}
    一个类型 $A$ 是一个 $n$-类型，当且仅当 $\tprojf n : A \to \trunc n A$ 是一个等价。
\end{cor}
\begin{proof}
    ``如果'' 这一点是由等价下的 $n$-类型的封闭性 (Closure of $n$-types under equivalence) 得出的。另一方面，如果 $A$ 是一个 $n$-类型，我们可以定义 $\ext(\idfunc[A]):\trunc n A\to{}A$。然后我们有 $\ext(\idfunc[A])\circ\tprojf n=\idfunc[A]:A\to{}A$ 根据定义。为了证明 $\tprojf n\circ\ext(\idfunc[A])=\idfunc[\trunc nA]$，我们只需要证明 $\tprojf n\circ\ext(\idfunc[A])\circ\tprojf n= \idfunc[\trunc nA]\circ\tprojf n$。这再次成立：
    \[\raisebox{\depth-\height+1em}{\xymatrix{
        A \ar^-{\tprojf n}[r] \ar_{\idfunc[A]}[rd] &
        \trunc nA \ar^>>>{\ext(\idfunc[A])}[d] \ar@/^40pt/^{\idfunc[\trunc nA]}[dd] \\
        & A \ar_{\tprojf n}[d] \\
        & \trunc nA}}
    \qedhere\]
\end{proof}

$n$-类型范畴 (Category of $n$-types) 还具有一些其他反射子范畴所不具备的特殊属性。例如，反射器 (Reflector) $\trunc n-$ 保持有限积 (Finite Products)。

\begin{thm}\label{cor:trunc-prod}
对于任意类型 $A$ 和 $B$，诱导映射 $\trunc n{A\times B} \to \trunc nA \times \trunc nB$ 是一个等价。
\end{thm}
\begin{proof}
    只需证明 $\trunc nA \times \trunc nB$ 具有与 $\trunc n{A\times B}$ 相同的通用性质即可。因此，设 $C$ 是一个 $n$-类型；我们有
    \begin{align*}
    (\trunc nA \times \trunc nB \to C)
        &= (\trunc nA \to (\trunc nB \to C))\\
        &= (\trunc nA \to (B \to C))\\
        &= (A \to (B \to C))\\
        &= (A \times B \to C)
    \end{align*}
    使用 $\trunc nB$ 和 $\trunc nA$ 的通用性质，以及 $B\to C$ 是一个 $n$-类型，因为 $C$ 是。可以很容易地验证，此等价通过与 $\tprojf n \times \tprojf n$ 的复合给出，这是所需要的。
\end{proof}

以下关于依赖和 (Dependent Sum) 的相关事实通常也很有用。

\begin{thm}\label{thm:trunc-in-truncated-sigma}
令 $P:A\to\type$ 为一个类型族。则存在等价
\begin{equation*}
    \eqv{\Trunc n{\sm{x:A}\trunc n{P(x)}}}{\Trunc n{\sm{x:A}P(x)}}。
\end{equation*}
\end{thm}

\begin{proof}
    我们多次使用 $n$-截断的归纳原理来构造函数
    \begin{align*}
        \varphi & : \Trunc n{\sm{x:A}\trunc n{P(x)}}\to\Trunc n{\sm{x:A}P(x)}\\
        \psi & : \Trunc n{\sm{x:A}P(x)}\to \Trunc n{\sm{x:A} \trunc n{P(x)}}
    \end{align*}
    以及将它们作为准逆 (Quasi-inverses) 展示的同伦 $H:\varphi\circ\psi\htpy \idfunc$ 和 $K:\psi\circ\varphi\htpy \idfunc$。我们通过设定 $\varphi(\tproj n{\pairr{x,\tproj nu}})\defeq\tproj n{\pairr{x,u}}$ 来定义 $\varphi$。我们通过设定 $\psi(\tproj n{\pairr{x,u}})\defeq\tproj n{\pairr{x,\tproj nu}}$ 来定义 $\psi$。然后我们定义 $H(\tproj n{\pairr{x,u}})\defeq \refl{\tproj n{\pairr{x,u}}}$ 和 $K(\tproj n{\pairr{x,\tproj nu}})\defeq \refl{\tproj n{\pairr{x,\tproj nu}}}$。
\end{proof}

\begin{cor}\label{thm:refl-over-ntype-base}
如果 $A$ 是一个 $n$-类型且 $P:A\to\type$ 是任意类型族，那么
\[ \eqv{\sm{a:A} \trunc n{P(a)}}{\Trunc n{\sm{a:A}P(a)}} \]
\end{cor}
\begin{proof}
    如果 $A$ 是一个 $n$-类型，则上面的左侧类型已经是一个 $n$-类型，因此等价于其 $n$-截断；因此这是由 \cref{thm:trunc-in-truncated-sigma} 推导出的。
\end{proof}

我们可以使用与 \cref{sec:compute-coprod,sec:compute-nat} 中计算余积 (Coproduct) 和自然数时使用的相同方法（我们将在 \cref{cha:homotopy} 中用来计算同伦群）来描述截断的路径空间 (Path Spaces)。不出所料，$A$ 的 $(n+1)$-截断的路径空间是 $A$ 的路径空间的 $n$-截断。实际上，对于任意 $x,y:A$，存在一个标准映射
\begin{equation}
    f:\ttrunc n{x=_Ay}\to \Big(\tproj {n+1}x=_{\trunc{n+1}A}\tproj {n+1}y\Big)\label{eq:path-trunc-map}
\end{equation}
定义为
\[f(\tproj n{p})\defeq \apfunc{\tprojf {n+1}}(p)。\]
此定义使用了 $\truncf n$ 的递归原理，这是正确的，因为 $\trunc {n+1}A$ 是 $(n+1)$-截断的，因此 $f$ 的余域是 $n$-截断的。

\begin{thm} \label{thm:path-truncation}
对于任意 $A$ 和 $x,y:A$ 以及 $n\ge -2$，映射~\eqref{eq:path-trunc-map} 是一个等价；因此我们有
\[ \eqv{\ttrunc n{x=_Ay}}{\Big(\tproj {n+1}x=_{\trunc{n+1}A}\tproj {n+1}y\Big)}。\]
\end{thm}

\begin{proof}
    证明是一个简单的编码-解码方法的应用 (Encode-decode method)：
    在以前的情形中，我们不能直接定义映射~\eqref{eq:path-trunc-map} 的准逆 (Quasi-inverse)，因为没有办法对 $\tproj {n+1}x$ 和 $\tproj {n+1}y$ 之间的等式进行归纳。
    因此，相反，我们在广义其类型后，再有广义的 $\trunc{n+1}A$ 的一般元素，而不是 $\tproj {n+1}x$ 和 $\tproj {n+1}y$。
    定义 $P:\trunc {n+1}A\to\trunc {n+1}A\to\typele{n}$ 为
    \[P(\tproj {n+1}x,\tproj {n+1}y)\defeq \trunc n{x=_Ay}\]
    此定义是正确的，因为 $\trunc n{x=_Ay}$ 是 $n$-截断的，而 \typele{n} 是 $(n+1)$-截断的根据 \cref{thm:hleveln-of-hlevelSn}。
    现在对于每个 $u,v:\trunc{n+1}A$，存在一个映射
    \[\decode:P(u,v) \to \big(u=_{\trunc{n+1}A}v\big)\]
    对于 $u=\tproj {n+1}x$ 和 $v=\tproj {n+1}y$ 和 $p:x=y$ 定义为
    \[\decode(\tproj n{p})\defeq \apfunc{\tprojf{n+1}} (p)。\]
    由于 $\decode$ 的余域是 $n$-截断的，只需对 $u$ 和 $v$ 进行此形式的定义，然后它就是与以前相同的定义。我们还定义了一个函数
    \[ r : \prd{u:\trunc{n+1} A} P(u,u) \]
    通过对 $u$ 的归纳，其中 $r(\tproj{n+1} x) \defeq \tproj n {\refl x}$。

    现在我们可以定义逆映射 (Inverse map)
    \[\encode: (u=_{\trunc{n+1}A}v) \to P(u,v)\]
    通过
    \[\encode(p) \defeq \transfib{v\mapsto P(u,v)}{p}{r(u)}。\]
    要证明复合映射
    \[ (u=_{\trunc{n+1}A}v) \xrightarrow{\encode} P(u,v) \xrightarrow{\decode} (u=_{\trunc{n+1}A}v) \]
    是恒等函数 (Identity function)，通过路径归纳法，只需检查它对于 $\refl u : u=u$ 的情况，在这种情况下，我们需要知道的是 $\decode(r(u)) = \refl{u}$。
    但是由于这是一个 $(n-1)$-类型，因此也是一个 $(n+1)$-类型，我们可以假设 $u\jdeq \tproj {n+1} x$，在这种情况下，按照 $r$ 和 $\decode$ 的定义，它得以成立。
    最后，要证明
    \[ P(u,v) \xrightarrow{\decode} (u=_{\trunc{n+1}A}v) \xrightarrow{\encode} P(u,v) \]
    是恒等函数，由于该目标再次是一个 $(n-1)$-类型，我们可以假设 $u=\tproj {n+1}x$ 和 $v=\tproj {n+1}y$ 并且我们正在考虑某些 $p:x=y$ 的 $P(\tproj{n+1}x,\tproj{n+1}y)$。
    然后我们有
    \begin{align*}
        \encode(\decode(\tproj n p)) &= \encode(\apfunc{\tprojf{n+1}}(p))\\
        &= \transfib{v\mapsto P(\tproj{n+1}x,v)}{\apfunc{\tprojf{n+1}}(p)}{\tproj n {\refl x}}\\
        &= \transfib{y\mapsto \trunc n{x=y}}{p}{\tproj n {\refl x}}\\
        &= \tproj n {\transfib{y \mapsto (x=y)}{p}{\refl x}}\\
        &= \tproj n p,
    \end{align*}
    使用 \cref{thm:transport-compose,thm:ap-transport}。
    （或者，我们可以在 $p$ 上进行路径归纳；在这种情况下，所需的等式将是判断上的 (Judgmentally)。）
    这就完成了 \decode 和 \encode 是准逆的证明。给出的结果是 $u=\tproj {n+1}x$ 和 $v=\tproj {n+1}y$ 的特例。
\end{proof}

\begin{cor}
    令 $n\ge-2$ 并且 $(A,a)$ 是一个基点类型 (Pointed Type)。那么
    \[\ttrunc n{\Omega(A,a)}=\Omega\mathopen{}\left(\trunc{n+1}{(A,a)}\right)\]
\end{cor}
\begin{proof}
    这是前述引理的一个特例，其中 $x=y=a$。
\end{proof}

\begin{cor}
    令 $n\ge -2$ 和 $k\ge 0$ 并且 $(A,a)$ 为一个基点类型。那么
    \[\ttrunc n{\Omega^k(A,a)} = \Omega^k\mathopen{}\left(\trunc{n+k}{(A,a)}\right)。\]
\end{cor}
\begin{proof}
    通过对 $k$ 进行归纳，使用 $\Omega^k$ 的递归定义。
\end{proof}

我们还观察到``截断是累积的 (Cumulative)''：如果我们截断为 $n$-类型，然后再截断为 $k$-类型，其中 $k\le n$，那么我们可能也可以直接截断为 $k$-类型。

\begin{lem} \label{lem:truncation-le}
令 $k,n\ge-2$ 并且 $k\le{}n$ 和 $A:\type$。那么
$\trunc k{\trunc nA}=\trunc kA$。
\end{lem}
\begin{proof}
    我们定义两个映射 $f:\trunc k{\trunc nA}\to\trunc kA$ 和 $g:\trunc kA\to\trunc k{\trunc nA}$ 通过
    %
    \[
        f(\tproj k{\tproj na}) \defeq \tproj ka
        \qquad\text{和}\qquad
        g(\tproj ka) \defeq \tproj k{\tproj na}。
    \]
    %
    映射 $f$ 是良好定义的，因为 $\trunc kA$ 是 $k$-截断的，并且也是 $n$-截断的（因为 $k\le{}n$），映射 $g$ 是良好定义的，因为 $\trunc k{\trunc nA}$ 是 $k$-截断的。

    复合 $f\circ{}g:\trunc kA\to\trunc kA$ 满足 $(f\circ{}g)(\tproj ka)=\tproj ka$，因此 $f\circ{}g=\idfunc[\trunc kA]$。同样地，我们有 $(g\circ{}f)(\tproj k{\tproj na})=\tproj k{\tproj na}$，因此 $g\circ{}f=\idfunc[\trunc k{\trunc nA}]$。
\end{proof}

% \begin{lem}
%   我们有 $\trunc n{\unit}=\unit$。
% \end{lem}
% \begin{proof}
%   确实，$\unit$ 对于每个 $n$ 都是 $n$-截断的，因此 $\trunc n{\unit}=\unit$ 通过
%   \cref{reflectPequiv}。
% \end{proof}

\index{truncation!n-truncation@$n$-truncation|)}%

\section{n-类型的余极限 (Colimits of \texorpdfstring{$n$}{n}-types)}
\label{sec:pushouts}

回忆一下，在\cref{sec:colimits}中，我们使用了高阶归纳类型 (higher inductive types) 来定义类型的推挤 (pushouts)，并证明了它们的泛性质 (universal property)。通常，一个$n$-类型的（同伦）余极限 (homotopy colimit) 可能不再是$n$-类型（参见\cref{ex:s2-colim-unit}中的极端反例）。然而，如果我们对其进行$n$-截断 (truncation)，我们将获得一个$n$-类型，它满足相对于其他$n$-类型的正确的泛性质。

在本节中，我们将证明这一点，特别是对于推挤（pushouts），这是余极限中最重要和最复杂的情况。回忆\cref{sec:colimits}中的以下定义。

\begin{defn}
    一个\define{广义图 (span)}% in $\P$
    \indexdef{span}%
    是一个五元组$\Ddiag=(A,B,C,f,g)$，其中% $A,B,C:\P$ 和
    $f:C\to{}A$ 和 $g:C\to{}B$。
    \[\Ddiag=\quad\vcenter{\xymatrix{C \ar^g[r] \ar_f[d] & B \\ A & }}\]
\end{defn}

\begin{defn}
    给定一个广义图$\Ddiag=(A,B,C,f,g)$和一个类型$D$，一个\define{在以$D$为基底的广义图$\Ddiag$下的余锥 (cocone under $\Ddiag$ with base $D$)} 是一个三元组$(i, j, h)$
    \index{cocone}%
    其中$i:A\to{}D$，$j:B\to{}D$，以及$h : \prd{c:C}i(f(c))=j(g(c))$：
    \[\uppercurveobject{{ }}\lowercurveobject{{ }}\twocellhead{{ }}
    \xymatrix{C \ar^g[r] \ar_f[d] \drtwocell{^h} & B \ar^j[d] \\ A \ar_i[r] & D
    }\]
    我们用$\cocone{\Ddiag}{D}$表示所有此类余锥的类型。
\end{defn}

余锥的类型是（协变）函子性 (functorial) 的。例如，给定$D,E$ % $D,E:\P$
和一个映射$t:D\to{}E$，有一个映射
\[\function{\cocone{\Ddiag}{D}}{\cocone{\Ddiag}{E}}{c}{\composecocone{t}c}\]
由以下定义：
\[\composecocone{t}(i,j,h)=(t\circ{}i,t\circ{}j,\mapfunc{t}\circ{}h).\]
并且，给定$D,E,F$， %$:\P$,
映射$t:D\to{}E$，$u:E\to{}F$ 和 $c:\cocone{\Ddiag}{D}$，我们有
\begin{align}
    \composecocone{\idfunc[D]}c &= c \label{eq:composeconeid}\\
    \composecocone{(u\circ{}t)}c&=\composecocone{u}(\composecocone{t}c). \label{eq:composeconefunc}
\end{align}

\begin{defn}
    给定一个$n$-类型的广义图$\Ddiag$，一个$n$-类型$D$，以及一个余锥
    $c:\cocone{\Ddiag}{D}$，如果对于每个$n$-类型$E$，映射
    \[\function{(D\to{}E)}{\cocone{\Ddiag}{E}}{t}{\composecocone{t}c}\]
    是一个等价 (equivalence)，则称对$(D,c)$是一个\define{$n$-类型中的推挤 (pushout
    of $\Ddiag$ in $n$-types)}。
    \indexdef{pushout!in ntypes@in $n$-types}%
\end{defn}

\begin{comment}
    我们在\cref{thm:pushout-ump}中展示了当$\P$是类型 (type) 时，推挤的存在性，通过使用高阶归纳类型 (higher inductive types) 进行了直接构造。
    对于一般的$\P$，推挤可能存在也可能不存在，但如果存在，它们是唯一的。

    \begin{lem}
        如果$(D,c)$ 和 $(D',c')$ 是$\P$中的两个推挤 (pushouts) ，那么$(D,c)=(D',c')$。
    \end{lem}
    \begin{proof}
        我们首先证明这两种类型$D$和$D'$是等价的。

        使用$D'$的泛性质 (universal property) 作用于$D$，我们可以看到以下映射是等价的
        %
        \[
            \function{(D\to{}D')}{\cocone{\Ddiag}{D'}}{t}{\composecocone{t}c}
        \]
        %
        特别地，存在一个映射$f:D\to{}D'$使得$\composecocone{f}c=c'$。同样地，存在一个映射$g:D'\to{}D$使得$\composecocone{g}c'=c$。

        为了证明$g\circ{}f=\idfunc[D]$，我们使用$D$的泛性质 (universal property) 作用于$D$，它表明以下映射是等价的：
        %
        \[
            \function{(D\to{}D)}{\cocone{\Ddiag}{D}}{t}{\composecocone{t}c}
        \]
        %
        使用函子性 (functoriality) $t\mapsto{}\composecocone{t}c$我们看到
        \begin{align*}
            \composecocone{(g\circ{}f)}c &= \composecocone{g}(\composecocone{f}c) \\
            &= \composecocone{g}c' \\
            &= c \\
            &= \composecocone{\idfunc[D]}c
        \end{align*}
        因此$g\circ{}f=\idfunc[D]$，因为等价映射是单射 (injective) 的。同样的论证
        对$D'$也适用，证明$f\circ{}g=\idfunc[D']$。

        因此$D$和$D'$是相等的，并且$(D,c)=(D',c')$这一事实源于我们定义的$D$和$D'$之间的等价映射将$c$映射到$c'$。
    \end{proof}

    \begin{cor}
        $\P$中的推挤类型 (type of pushouts) 是一个纯命题 (mere proposition)。特别地，如果
        推挤 (pushouts) 仅仅存在，那么它们实际上存在。
    \end{cor}

    就像在纤维积 (pullbacks) 的情况下，如果$\P$是反射子范畴 (reflective subcategory)，则$\P$中的推挤总是存在。然而，与纤维积 (pullbacks) 不同，$\P$中的推挤不是类型 (type) 中的推挤：它们是通过应用反射子范畴 (reflector) 获得的。
\end{comment}

为了构造$n$-类型的推挤 (pushouts)，我们需要解释如何反射广义图 (spans) 和余锥 (cocones)。

\bgroup
\def\reflect(#1){\trunc n{#1}}

\begin{defn}
    令
    \[\Ddiag=\quad\vcenter{\xymatrix{C \ar^g[r] \ar_f[d] & B \\ A & }}\]
    为一个广义图 (span)。我们将以下$n$-类型的广义图称为$\reflect(\Ddiag)$：
    \[\reflect(\Ddiag)\defeq\quad \vcenter{\xymatrix{\reflect(C) \ar^{\reflect(g)}[r]
        \ar_{\reflect(f)}[d] & \reflect(B) \\ \reflect(A) & }}\]
\end{defn}

\begin{defn}
    令$D:\type$ 和 $c=(i,j,h):\cocone{\Ddiag}{D}$。
    我们定义
    \[\reflect(c)=(\reflect(i),\reflect(j),k):
    \cocone{\reflect(\Ddiag)}{\reflect(D)}\]
    其中$k$是复合同伦 (composite homotopy)
    \[ \reflect(i) \circ \reflect(f) \htpy \reflect(i\circ f) \htpy \reflect(j\circ g) \htpy \reflect(j) \circ \reflect(g) \]
    使用了\cref{thm:trunc-htpy} 和$\reflect(\blank)$的函子性 (functoriality)。
    % \[\reflect(h):\prd{c:\reflect(C)}\reflect(i)(\reflect(f)(c))=\reflect(j)(\reflect(g)(c))\]
    % 以以下方式定义：
\end{defn}

\egroup

我们现在观察到，从每个类型到其$n$-截断的映射组合成了一个广义图的映射，其含义如下。

\begin{defn}
    令
    \[\Ddiag=\quad\vcenter{\xymatrix{C \ar^g[r] \ar_f[d] & B \\ A & }}
    \qquad\text{and}\qquad
    \Ddiag'=\quad\vcenter{\xymatrix{C' \ar^{g'}[r] \ar_{f'}[d] & B' \\ A' & }}
    \]
    是两个广义图 (spans)。
    一个\define{广义图的映射 (map of spans)}
    \indexdef{map!of spans}%
    $\Ddiag \to \Ddiag'$由函数$\alpha:A\to A'$，$\beta:B\to B'$和$\gamma:C\to C'$以及同伦$\phi: \alpha\circ f \htpy f'\circ \gamma$ 和 $\psi:\beta\circ g \htpy g' \circ \gamma$组成。
\end{defn}

因此，对于任意广义图$\Ddiag$，我们有一个广义图的映射$\tprojf[\Ddiag] n : \Ddiag \to \trunc n\Ddiag$，由$\tprojf[A]n$、$\tprojf[B]n$、$\tprojf[C]n$以及~\eqref{eq:trunc-nat}中的自然同伦$\mathsf{nat}^f_n$ 和 $\mathsf{nat}^g_n$组成。

我们还需要知道广义图的映射是如何函子性地 (functorially) 表现的。
即，如果$(\alpha,\beta,\gamma,\phi,\psi):\Ddiag \to \Ddiag'$是广义图的映射，并且$D$是任意类型，那么我们有
\[ \function{\cocone{\Ddiag'}{D}}{\cocone{\Ddiag}{D}}{(i,j,h)}{(i\circ \alpha,j\circ\beta, k)} \]
其中$k: \prd{z:C} i(\alpha(f(z))) = j(\beta(g(z)))$是复合
\begin{equation}\label{eq:mapofspans-htpy}
\xymatrix{
    i(\alpha(f(z))) \ar@{=}[r]^{\apfunc{i}(\phi)} &
    i(f'(\gamma(z))) \ar@{=}[r]^{h(\gamma(z))} &
    j(g'(\gamma(z))) \ar@{=}[r]^{\apfunc{j}(\psi)} &
    j(\beta(g(z)))。}
\end{equation}
我们将此余锥表示为$(i,j,h) \circ (\alpha,\beta,\gamma,\phi,\psi)$。
此外，这种余锥的函子性行为与其他余锥的函子性是相容的：

\begin{lem}\label{thm:conemap-funct}
设$(\alpha,\beta,\gamma,\phi,\psi):\Ddiag \to \Ddiag'$ 和 $t:D\to E$，则以下图表是交换的：
\begin{equation*}
    \vcenter{\xymatrix{
        \cocone{\Ddiag'}{D}\ar[r]^{t \circ {\blank}}\ar[d] &
        \cocone{\Ddiag'}{E}\ar[d]\\
        \cocone{\Ddiag}{D}\ar[r]_{t \circ {\blank}} &
        \cocone{\Ddiag}{E}
    }}
\end{equation*}
\end{lem}
\begin{proof}
    给定$(i,j,h):\cocone{\Ddiag'}{D}$，注意到两个复合都产生一个余锥，其前两个分量是$t\circ i\circ \alpha$ 和 $t\circ j\circ\beta$。
    因此，剩下的就是验证同伦是相同的。
    对于右上复合，同伦是~\eqref{eq:mapofspans-htpy}，其中$(i,j,h)$替换为$(t\circ i, t\circ j, \apfunc{t}\circ h)$：
    \begin{equation*}
        \xymatrix@+2.8em{
                {t \, i \, \alpha \, f \, z} \ar@{=}[r]^{\apfunc{t\circ i}(\phi)} &
                {t \, i \, f' \, \gamma \, z} \ar@{=}[r]^{\apfunc{t}(h(\gamma(z)))} &
                {t \, j \, g' \, \gamma \, z} \ar@{=}[r]^{\apfunc{t\circ j}(\psi)} &
                {t \, j \, \beta \, g \, z}。
        }
    \end{equation*}
    （为了简洁，我们省略了函数参数周围的括号。）
    另一方面，对于左下复合，同伦是应用于~\eqref{eq:mapofspans-htpy}的$\apfunc{t}$。
    由于$\apfunc{}$尊重路径的连接，这是等同于
    \begin{equation*}
        \xymatrix@+2.8em{
                {t \, i \, \alpha \, f \, z} \ar@{=}[r]^{\apfunc{t}(\apfunc{i}(\phi))} &
                {t \, i \, f' \, \gamma \, z} \ar@{=}[r]^{\apfunc{t}(h(\gamma(z)))} &
                {t \, j \, g' \, \gamma \, z} \ar@{=}[r]^{\apfunc{t}(\apfunc{j}(\psi))} &
                {t \, j \, \beta \, g \, z}。}
    \end{equation*}
    但是$\apfunc{t}\circ \apfunc{i} = \apfunc{t\circ i}$，$j$的情况也是类似的，所以这两个同伦是相等的。
\end{proof}

最后，请注意，由于我们使用\cref{thm:trunc-htpy}定义了$\trunc nc : \cocone{\trunc n \Ddiag}{\trunc n D}$，附加条件~\eqref{eq:trunc-htpy}意味着
\begin{equation}
    \tprojf[D] n \circ c = \trunc n c \circ \tprojf[\Ddiag]n. \label{eq:conetrunc}
\end{equation}
对于任意$c:\cocone{\Ddiag}{D}$。
现在我们可以证明所需的定理。

\begin{thm}
    \label{reflectcommutespushout}
    \index{推挤的泛性质 (universal!property!of pushout)}%
    设$\Ddiag$是一个广义图，$(D,c)$是其推挤。
    那么$(\trunc nD,\trunc n c)$是$n$-类型中的$\trunc n\Ddiag$的推挤。
\end{thm}
\begin{proof}
    设$E$是一个$n$-类型，并考虑下图：
    \bgroup
    \def\reflect(#1){\trunc n{#1}}
    \begin{equation*}
        \vcenter{\xymatrix{
            (\trunc nD \to E)\ar[r]^-{\blank\circ \tprojf[D] n}\ar[d]_{\blank\circ \trunc nc} &
            (D\to E)\ar[d]^{\blank\circ c}\\
            \cocone{\trunc n \Ddiag}{E}\ar[r]^-{\blank\circ \tprojf[\Ddiag]n}\ar@{<-}[d]_{\ell_1} &
            \cocone{\Ddiag}{E}\ar@{<-}[d]^{\ell_2}\\
            (\reflect(A)\to{}E)\times_{(\reflect(C)\to{}E)}(\reflect(B)\to{}E)\ar[r] &
            (A\to{}E)\times_{(C\to{}E)}(B\to{}E)
        }}
    \end{equation*}
    \egroup
    上面的水平箭头是等价的，因为$E$是一个$n$-类型，而$\blank\circ c$是等价的，因为$c$是一个推挤余锥。
    因此，通过三者取二性质 (2-out-of-3 property)，为了证明$\blank\circ \trunc nc$是等价的，足以证明上方的方形是交换的，并且中间的水平箭头是等价的。
    要证明上方的方形是交换的，令$t:\trunc nD \to E$；那么
    \begin{align}
        \big(t \circ \trunc n c\big) \circ \tprojf[\Ddiag] n
        &= t \circ \big(\trunc n c \circ \tprojf[\Ddiag] n\big)
        \tag{by \cref{thm:conemap-funct}}\\
        &= t\circ \big(\tprojf[D]n \circ c\big)
        \tag{by~\eqref{eq:conetrunc}}\\
        &= \big(t\circ \tprojf[D]n\big) \circ c
        \tag{by~\eqref{eq:composeconefunc}}。
    \end{align}
    为了证明中间的水平箭头是等价的，考虑下方的方形。
    两个下方的垂直箭头只是$\happly$的应用：
    \begin{align*}
        \ell_1(i,j,p) &\defeq (i,j,\happly(p))\\
        \ell_2(i,j,p) &\defeq (i,j,\happly(p))。
    \end{align*}
    因此，由函数外延性 (function extensionality) 可知，它们是等价的。
    最低的水平箭头定义为
    \[ (i,j,p) \mapsto \big( i\circ \tprojf[A]n,\;\; j \circ \tprojf[B] n,\;\; q\big) \]
    其中$q$是复合
    \begin{align}
        i\circ \tprojf[A]n \circ f
        &= i\circ \trunc nf \circ \tprojf[C]n
        \tag{by $\funext(\lam{z} \apfunc{i}(\mathsf{nat}^f_n(z)))$}\\
        &= j\circ \trunc ng \circ \tprojf[C]n
        \tag{by $\apfunc{\blank\circ \tprojf[C] n}(p)$}\\
        &= j\circ \tprojf[B]n \circ g。
        \tag{by $\funext(\lam{z} \apfunc{j}(\mathsf{nat}^g_n(z)))$}
    \end{align}
    这是一个等价的映射，因为它是由广义图的等价诱导而来的。
    因此，由三者取二性质 (2-out-of-3)，足以证明下方的方形是交换的。
    但是，下方的两个复合在前两个分量上定义性地一致，因此足以证明，对于左下角的$(i,j,p)$和$C$中的$z$，路径
    \[ \happly(q,z) : i(\tproj n{f(z)}) = j(\tproj n{g(z)}) \]
    （其中$q$如上所述）
    等于复合
    \begin{align}
        i(\tproj n{f(z)})
        &= i(\trunc nf(\tproj nz))
        \tag{by $\apfunc{i}(\mathsf{nat}^f_n(z))$}\\
        &= j(\trunc ng(\tproj nz))
        \tag{by $\happly(p,\tproj nz)$}\\
        &= j(\tproj n{g(z)})。
        \tag{by $\apfunc{j}(\mathsf{nat}^g_n(z))$}
    \end{align}
    然而，由于$\happly$是函子性的，因此检查三个分量路径的等同性就足够了：
    \begin{align*}
        \happly({\funext(\lam{z} \apfunc{i}(\mathsf{nat}^f_n(z)))},z)
        &= {\apfunc{i}(\mathsf{nat}^f_n(z))}\\
        \happly(\apfunc{\blank\circ \tprojf[C] n}(p), z)
        &= {\happly(p,\tproj nz)}\\
        \happly({\funext(\lam{z} \apfunc{j}(\mathsf{nat}^g_n(z)))},z)
        &= {\apfunc{j}(\mathsf{nat}^g_n(z))}。
    \end{align*}
    其中第一个和第三个只是$\happly$是$\funext$的拟逆，而第二个是关于$\happly$和预合成 (precomposition) 的简单泛定理。
\end{proof}

\section{Connectedness (连通性)}
\label{sec:connectivity}

一个$n$-类型是指其在$n$维以上没有有趣信息的类型。
相对地，一个\emph{$n$-连通的类型} (n-connected type) 是指其在$n$维以下没有有趣信息的类型。
事实证明，研究函数的更一般的概念也是自然的。

\begin{defn}
    一个函数$f:A\to B$ 被称为\define{$n$-连通的} ($n$-connected)
    \indexdef{function!n-connected@$n$-connected}%
    \indexsee{n-connected@$n$-connected!function}{function, $n$-connected}%
    如果对所有$b:B$，类型$\trunc n{\hfiber f b}$是收缩的 (contractible)：
    \begin{equation*}
        \mathsf{conn}_n(f)\defeq \prd{b:B}\iscontr(\trunc n{\hfiber{f}b})。
    \end{equation*}
    一个类型$A$ 被称为\define{$n$-连通的} ($n$-connected)
    \indexsee{n-connected@$n$-connected!type}{type, $n$-connected}%
    \indexdef{type!n-connected@$n$-connected}%
    当且仅当唯一的函数$A\to\unit$是$n$-连通的，即$\trunc nA$是收缩的。
\end{defn}
\indexsee{connected!function}{function, $n$-connected}

因此，一个函数$f:A\to B$是$n$-连通的，当且仅当对每个$b:B$，$\hfib{f}b$是$n$-连通的。
当然，每个函数都是$(-2)$-连通的。
在下一个层级上，我们有：

\begin{lem}\label{thm:minusoneconn-surjective}
\index{function!surjective}%
一个函数$f$是$(-1)$-连通的，当且仅当它在\cref{sec:mono-surj}的意义下是满射 (surjective)。
\end{lem}
\begin{proof}
    我们定义$f$为满射，如果对所有$b$，$\trunc{-1}{\hfiber f b}$是可居住的 (inhabited)。
    但由于它是一个单纯命题 (mere proposition)，可居住性等价于收缩性。
\end{proof}

因此，$n$-连通性可以被看作是一个强形式的满射性。
在范畴论中，$(-1)$-连通性对应于对象上的本质满射性 (essential surjectivity)，而$n$-连通性对应于对所有$k\le n+1$的$k$-态射 (k-morphisms) 的本质满射性。

\cref{thm:minusoneconn-surjective}还意味着一个类型$A$是$(-1)$-连通的，当且仅当它是可居住的。
当一个类型是$0$-连通时，我们可以简单地说它是\define{连通的} (connected)，
\indexdef{connected!type}%
\indexdef{type!connected}%
当它是$1$-连通时，我们说它是\define{单连通的} (simply connected)。
\indexdef{simply connected type}%
\indexdef{type!simply connected}%

\begin{rmk}\label{rmk:connectedness-indexing}
尽管我们对类型的$n$-连通性的定义与同伦理论中的标准概念一致，但我们对\emph{函数}的$n$-连通性概念与经典同伦理论中的一种常见索引方式差一位。
虽然我们说一个函数$f$是$n$-连通的，如果它的所有纤维 (fibers) 是$n$-连通的，一些经典同伦理论家会称这样的函数为$(n+1)$-连通的。
（这归因于历史上对\emph{余纤维 (cofibers)} 而非纤维的关注。）
\end{rmk}

现在我们观察一些关于连通映射 (connected maps) 的闭合性质。
\index{function!n-connected@$n$-connected}

\begin{lem}
    \index{retract!of a function}%
    假设$g$是一个$n$-连通函数$f$的收缩 (retract)。那么$g$是$n$-连通的。
\end{lem}
\begin{proof}
    这是\cref{lem:func_retract_to_fiber_retract}的直接推论。
\end{proof}

\begin{cor}
    如果$g$与一个$n$-连通函数$f$是同伦的，那么$g$是$n$-连通的。
\end{cor}

\begin{lem}\label{lem:nconnected_postcomp}
假设$f:A\to B$是$n$-连通的。那么$g:B\to C$是$n$-连通的，当且仅当$g\circ f$是$n$-连通的。
\end{lem}

\begin{proof}
    对于任意$c:C$，我们有
    \begin{align*}
        \trunc n{\hfib{g\circ f}c}
        & \eqvsym \Trunc n{ \sm{w:\hfib{g}c}\hfib{f}{\proj1 w}}
        \tag{by \cref{ex:unstable-octahedron}}\\
        & \eqvsym \Trunc n{\sm{w:\hfib{g}c} \trunc n{\hfib{f}{\proj1 w}}}
        \tag{by \cref{thm:trunc-in-truncated-sigma}}\\
        & \eqvsym \trunc n{\hfib{g}c}。
        \tag{since $\trunc n{\hfib{f}{\proj1 w}}$ is contractible}
    \end{align*}
    因此，如果并且仅当$\trunc n{\hfib{g\circ f}c}$是收缩的，$\trunc n{\hfib{g}c}$也是收缩的。
\end{proof}

重要的是，$n$-连通函数可以等价地被表述为那些满足关于$n$-类型归纳原理的函数。\index{induction principle!for connected maps}
这一想法将直接引出我们在\cref{sec:freudenthal}中对Freudenthal悬吊定理的证明。

\begin{lem}\label{prop:nconnected_tested_by_lv_n_dependent types}
对于函数$f:A\to B$和类型族$P:B\to\type$，考虑以下函数：
\begin{equation*}
    \lam{s} s\circ f :\Parens{\prd{b:B} P(b)}\to\Parens{\prd{a:A}P(f(a))}。
\end{equation*}
对于固定的$f$和$n\ge -2$，以下条件等价。
\begin{enumerate}
    \item $f$是$n$-连通的。\label{item:conntest1}
    \item 对于每个$P:B\to\ntype{n}$，映射$\lam{s} s\circ f$是一个等价。\label{item:conntest2}
    \item 对于每个$P:B\to\ntype{n}$，映射$\lam{s} s\circ f$有一个截面 (section)。\label{item:conntest3}
\end{enumerate}
\end{lem}

\begin{proof}
    假设$f$是$n$-连通的，并且令$P:B\to\ntype{n}$。那么我们有以下等价关系：
    \begin{align}
        \prd{b:B} P(b) & \eqvsym \prd{b:B} \Parens{\trunc n{\hfib{f}b} \to P(b)}
        \tag{since $\trunc n{\hfib{f}b}$ is contractible}\\
        & \eqvsym \prd{b:B} \Parens{\hfib{f}b\to P(b)}
        \tag{since $P(b)$ is an $n$-type}\\
        & \eqvsym \prd{b:B}{a:A}{p:f(a)= b} P(b)
        \tag{by the left universal property of $\Sigma$-types}\\
        & \eqvsym \prd{a:A} P(f(a))。
        \tag{by the left universal property of path types}
    \end{align}
    我们省略了证明此等价关系确实由$\lam{s} s\circ f$给出。
    因此，\ref{item:conntest1}$\Rightarrow$\ref{item:conntest2}显然，\ref{item:conntest2}$\Rightarrow$\ref{item:conntest3}也显然成立。
    为了证明\ref{item:conntest3}$\Rightarrow$\ref{item:conntest1}，考虑类型族
    \begin{equation*}
        P(b)\defeq \trunc n{\hfib{f}b}。
    \end{equation*}
    那么\ref{item:conntest3}给出了一个映射$c:\prd{b:B} \trunc n{\hfib{f}b}$，使得$c(f(a))=\tproj n{\pairr{a,\refl{f(a)}}}$。
    为了证明每个$\trunc n{\hfib{f}b}$都是收缩的，我们将找到一个类型为
    \begin{equation*}
        \prd{b:B}{w:\trunc n{\hfib{f}b}} w= c(b)。
    \end{equation*}
    的函数。
    根据\cref{thm:truncn-ind}，为此目的，我们只需找到一个类型为
    \begin{equation*}
        \prd{b:B}{a:A}{p:f(a)= b} \tproj n{\pairr{a,p}}= c(b)。
    \end{equation*}
    的函数。
    但通过变量重新安排和路径归纳，这等价于类型
    \begin{equation*}
        \prd{a:A} \tproj n{\pairr{a,\refl{f(a)}}}= c(f(a))。
    \end{equation*}
    该属性通过我们对$c(f(a))$的选择成立。
\end{proof}

\begin{cor}\label{cor:totrunc-is-connected}
对于任意$A$，从类型到其$n$-截断 (truncation) 的标准函数$\tprojf n:A\to\trunc n A$是$n$-连通的。
\end{cor}
\begin{proof}
    根据\cref{thm:truncn-ind}及其相关的唯一性原则，\cref{prop:nconnected_tested_by_lv_n_dependent types}中的条件成立。
\end{proof}

例如，当$n=-1$时，\cref{cor:totrunc-is-connected}表明从一个类型到其命题截断 (propositional truncation) 的映射$A\to \brck A$是满射的。

\begin{cor}\label{thm:nconn-to-ntype-const}\label{connectedtotruncated}
一个类型$A$是$n$-连通的，当且仅当映射
\begin{equation*}
    \lam{b}{a} b: B \to (A\to B)
\end{equation*}
对于每个$n$-类型$B$都是一个等价关系。
换句话说，“从$A$到$n$-类型的每个映射都是常数”。
\end{cor}
\begin{proof}
    通过应用\cref{prop:nconnected_tested_by_lv_n_dependent types}到以$\unit$为终端类型的函数。
\end{proof}

\begin{lem}\label{lem:nconnected_to_leveln_to_equiv}
设$B$是一个$n$-类型，并且$f:A\to B$是一个函数。那么诱导的函数$g:\trunc n A\to B$是一个等价关系，当且仅当$f$是$n$-连通的。
\end{lem}

\begin{proof}
    根据\cref{cor:totrunc-is-connected}，$\tprojf n$是$n$-连通的。
    因此，由于$f = g\circ \tprojf n$，根据\cref{lem:nconnected_postcomp}，如果且仅当$g$是$n$-连通的，$f$才是$n$-连通的。
    但由于$g$是一个$n$-类型之间的函数，其纤维 (fiber) 也是$n$-类型。
    因此，$g$是$n$-连通的，当且仅当它是一个等价关系。
\end{proof}

我们还可以通过包含其基点 (basepoint) 的连通性来表征连通的指点类型 (pointed types)。

\begin{lem}\label{thm:connected-pointed}
\index{basepoint}%
设$A$是一个类型，$a_0:\unit\to A$是一个基点，且$n\ge -1$。
那么$A$是$n$-连通的，当且仅当映射$a_0$是$(n-1)$-连通的。
\end{lem}
\begin{proof}
    首先假设$a_0:\unit\to A$是$(n-1)$-连通的，并且令$B$是一个$n$-类型；我们将使用\cref{thm:nconn-to-ntype-const}。
    映射$\lam{b}{a} b: B \to (A\to B)$有一个回缩 (retraction)，即$f\mapsto f(a_0)$，因此只需证明它也有一个截面 (section)，即对于任何$f:A\to B$，存在$b:B$使得$f = \lam{a}b$。
    我们选择$b\defeq f(a_0)$。
    定义$P:A\to\type$为$P(a) \defeq (f(a)=f(a_0))$。
    然后$P$是一个$(n-1)$-类型族，并且我们有$P(a_0)$；因此我们有$\prd{a:A} P(a)$，因为$a_0:\unit\to A$是$(n-1)$-连通的。
    因此，$f = \lam{a} f(a_0)$，如所需。

    现在假设$A$是$n$-连通的，并且给定$P:A\to\ntype{(n-1)}$和$u:P(a_0)$。
    通过\cref{prop:nconnected_tested_by_lv_n_dependent types}，我们将构造一个$f:\prd{a:A} P(a)$，使得$f(a_0)=u$。
    现在，$\ntype{(n-1)}$是一个$n$-类型，并且$A$是$n$-连通的，因此通过\cref{thm:nconn-to-ntype-const}，存在一个$n$-类型$B$使得$P = \lam{a} B$。
    因此，我们有一组等价关系$g:\prd{a:A} (\eqv{P(a)}{B})$。
    定义$f(a) \defeq \opp{g_a}(g_{a_0}(u))$；那么$f:\prd{a:A} P(a)$并且$f(a_0) = u$，如所需。
\end{proof}

特别地，一个指点类型$(A,a_0)$是$0$-连通的，当且仅当$a_0:\unit\to A$是满射的，也就是说$\prd{x:A} \brck{x=a_0}$。
对于非指点情况的类似结果，请参见\cref{ex:connectivity-inductively}。

\cref{lem:nconnected_postcomp}的一个有用变体是：

\begin{lem}\label{lem:nconnected_postcomp_variation}
设$f:A\to B$是一个函数，并且$P:A\to\type$和$Q:B\to\type$是类型族。假设$g:\prd{a:A} P(a)\to Q(f(a))$
是一个纤维上 (fiberwise) 的$n$-连通函数族，亦即每个函数$g_a : P(a) \to Q(f(a))$都是$n$-连通的。
如果$f$也是$n$-连通的，那么函数
\begin{align*}
    \varphi &:\Parens{\sm{a:A} P(a)}\to\Parens{\sm{b:B} Q(b)}\\
    \varphi(a,u) &\defeq \pairr{f(a),g_a(u)}。
\end{align*}
也是$n$-连通的。
反之，如果$\varphi$和每个$g_a$都是$n$-连通的，并且此外$Q$在纤维上是单射的（即我们有$\brck{Q(b)}$对于所有$b:B$），那么$f$是$n$-连通的。
\end{lem}

\begin{proof}
    对于任意$b:B$和$v:Q(b)$，我们有
        {\allowdisplaybreaks
    \begin{align*}
        \trunc n{\hfib{\varphi}{\pairr{b,v}}} & \eqvsym \Trunc n{ \sm{w:\hfib{f}b}{u:P(\proj1(w))} g_{\proj 1 w}(u)= \trans{\opp{\proj2(w)}}{v}}\\
        & \eqvsym \Trunc n{ \sm{w:\hfib{f}b} \trunc n{\hfib{g(\proj1 w)}{\trans{\opp{\proj 2(w)}}{v}}}}\\
        & \eqvsym \trunc n{\hfib{f}b}
    \end{align*}}%
    其中传输 (transportation) 是沿着$f(p)$和$f(p)^{-1}$关于$Q$进行的。
    因此，如果其中任何一个是可收缩的，那么另一个也是可收缩的。

    特别地，如果$f$是$n$-连通的，那么对于所有的$b:B$，$\trunc n{\hfib{f}b}$是可收缩的，因此对于所有$(b,v):\sm{b:B} Q(b)$，$\trunc n{\hfib{\varphi}{\pairr{b,v}}}$也是可收缩的。
    另一方面，如果$\varphi$是$n$-连通的，那么对于所有$(b,v)$，$\trunc n{\hfib{\varphi}{\pairr{b,v}}}$是可收缩的，因此对于任何存在$v:Q(b)$的$b:B$，$\trunc n{\hfib{f}b}$也是可收缩的。
    最后，由于可收缩性是一个单纯命题，因此我们只需拥有这样的$v$。
\end{proof}

\cref{lem:nconnected_postcomp_variation}的逆向结论如果$Q$在纤维上不是单射的可能不成立。
例如，如果$P$和$Q$都恒为$\emptyt$，那么$\varphi$和每个$g_a$都是等价关系，但$f$可能是任意的。

另一方面，我们有

\begin{lem}\label{prop:nconn_fiber_to_total}
设$P,Q:A\to\type$是类型族，并且考虑从$P$到$Q$的纤维转换\index{fiberwise!transformation}
\begin{equation*}
    f:\prd{a:A} \Parens{P(a)\to Q(a)}
\end{equation*}
则诱导的映射$\total f: \sm{a:A}P(a) \to \sm{a:A} Q(a)$是$n$-连通的，当且仅当每个$f(a)$是$n$-连通的。
\end{lem}

当然，“仅当”的方向也是\cref{lem:nconnected_postcomp_variation}的一个特例。

\begin{proof}
    根据\cref{fibwise-fiber-total-fiber-equiv}，我们有
    $\hfib{\total f}{\pairr{x,v}}\eqvsym\hfib{f(x)}v$
    对于每个$x:A$和$v:Q(x)$。因此，$\trunc n{\hfib{\total f}{\pairr{x,v}}}$是可收缩的，当且仅当$\trunc n{\hfib{f(x)}v}$是可收缩的。
\end{proof}

关于连通映射的另一个有用事实是它们在$n$-截断上诱导了等价关系：

\begin{lem} \label{lem:connected-map-equiv-truncation}
如果$f : A \to B$是$n$-连通的，那么它诱导了一个等价关系$\eqv{\trunc{n}{A}}{\trunc{n}{B}}$。
\end{lem}
\begin{proof}
    设$c$是证明$f$是$n$-连通的证明。从左到右，我们使用映射$\trunc{n}{f} : \trunc{n}{A} \to \trunc{n}{B}$。
    为了定义从右到左的映射，根据截断的通用性质，我们只需给出一个映射$\mathsf{back} : B \to {\trunc{n}{A}}$。
    我们可以如下定义此映射：
    \[
        \mathsf{back}(y) \defeq \trunc{n}{\proj{1}}{(\proj{1}{(c(y))})}。
    \]
    根据定义，$c(y)$的类型是$\iscontr(\trunc n {\hfiber{f}y})$，所以它的第一个分量的类型是$\trunc n{\hfiber{f}y}$，我们可以通过投影从中获得$\trunc n A$的一个元素。

    接下来，我们证明复合是恒等映射。在两个方向上，由于目标是在一个$n$-截断类型中的路径，因此只需处理构造函数$\tprojf{n}$。

    在一个方向上，我们必须证明对于所有$x:A$，
    \[
        \trunc{n}{\proj{1}}{(\proj{1}{(c(f(x)))})} = \tproj{n}{x}。
    \]
    但是$\tproj{n}{(x, \refl{f(x)})}$的类型是$\trunc n{\hfiber{f}{f(x)}}$，并且$c(f(x))$表明该类型是可收缩的，所以
    \[
        \proj{1}{(c(f(x)))} = \tproj{n}{(x, \refl{})}。
    \]
    将$\trunc{n}{\proj{1}}$应用于此等式的两边给出所需的结果。

    在另一个方向上，我们必须证明对于所有$y:B$，
    \[
        \trunc{n}{f}(\trunc{n}{\proj{1}} (\proj{1}{(c(y))})) = \tproj{n}{y}。
    \]
    $\proj{1}{(c(y))}$的类型是$\trunc n {\hfiber{f}y}$，并且我们想要的路径基本上是$\hfiber{f}y$的第二个分量，但我们需要确保截断结果正确。

    一般来说，假设我们给定了$p:\trunc{n}{\sm{x:A} B(x)}$并且希望证明$P(\trunc{n}{\proj{1}{}}(p))$。
    通过截断归纳，只需证明对于所有$a:A$和$b:B(a)$，$P(\tproj{n}{a})$成立。
    在此情况下应用这一原则，只需证明
    \[
        \trunc{n}{f}(\tproj{n}{a}) = \tproj{n}{y}
    \]
    给定$a:A$和$b:f (a) = y$。但左边等于$\tproj{n}{f (a)}$，所以将$\tprojf{n}$应用于$b$的两边给出所需的结果。
\end{proof}

人们可能会猜测这个事实刻画了$n$-连通映射，但实际上，成为$n$-连通的条件比这更强。
例如，包含映射$\bfalse:\unit \to\bool$在$(-1)$-截断上诱导了一个等价关系，但并不是满射的（即$(-1)$-连通的）。
在\cref{sec:long-exact-sequence-homotopy-groups}中，我们将看到一般情况下的区别类似于额外的满射性。

\section{正交分解 (Orthogonal Factorization)}
\label{sec:image-factorization}

\index{唯一!分解系统|(unique factorization system)}%
\index{正交分解系统|(orthogonal factorization system)}%

在集合论中，满射 (surjection) 和单射 (injection) 组成了一个唯一的分解系统：每个函数都可以实质上唯一地分解为一个满射后接一个单射。我们已经看到，满射可以自然地推广为 $n$-连通 (n-connected) 映射，因此我们自然要探讨这些映射是否也参与到一个分解系统中。下面是关于单射的对应推广。

\begin{defn}
    一个函数 $f:A\to B$ 是 \define{$n$-截断的 ($n$-truncated)}
    \indexdef{n-截断的@$n$-truncated!函数 (function)}%
    \indexdef{函数!n-截断的@$n$-truncated}%
    如果对所有 $b:B$，纤维 $\hfib f b$ 是一个 $n$-类型 (n-type)。
\end{defn}

特别地，$f$ 是 $(-2)$-截断的当且仅当它是一个等价 (equivalence)。并且，$A$ 是一个 $n$-类型当且仅当 $A\to\unit$ 是 $n$-截断的。此外，$n$-截断映射也可以递归地定义，类似于 $n$-类型。

\begin{lem}\label{thm:modal-mono}
对于任何 $n\ge -2$，一个函数 $f:A\to B$ 是 $(n+1)$-截断的当且仅当对所有 $x,y:A$，映射 $\apfunc{f}:(x=y) \to (f(x)=f(y))$ 是 $n$-截断的。
\index{函数!嵌入 (embedding)}%
\index{函数!单射 (injective)}%
特别地，$f$ 是 $(-1)$-截断的当且仅当它是 \cref{sec:mono-surj} 中定义的嵌入。
\end{lem}
\begin{proof}
    注意，对于 $\hfib f b$ 中的任意 $(x,p),(y,q)$，我们有
    \begin{align*}
        \big((x,p) = (y,q)\big)
        &= \sm{r:x=y} (p = \apfunc f(r)\ct q)\\
        &= \sm{r:x=y} (\apfunc f (r) = p\ct \opp q)\\
        &= \hfib{\apfunc{f}}{p\ct \opp q}.
    \end{align*}
    因此，$f$ 的任何纤维中的任何路径空间都是 $\apfunc{f}$ 的一个纤维。另一方面，通过选择 $b\defeq f(y)$ 和 $q\defeq \refl{f(y)}$ 我们可以看到 $\apfunc f$ 的任何纤维都是 $f$ 的某个纤维中的路径空间。结果由此得出，因为如果 $f$ 的所有纤维的路径空间都是 $n$-类型，那么 $f$ 是 $(n+1)$-截断的。
\end{proof}

现在我们可以通过一种显而易见的方式来构造分解。

\begin{defn}\label{defn:modal-image}
令 $f:A\to B$ 是一个函数。$f$ 的 \define{$n$-像 ($n$-image)}
\indexdef{像 (image)}%
\indexdef{像!n-像@$n$-image}%
\indexdef{n-像@$n$-image}%
\indexdef{函数!n-像@$n$-image of}%
定义为
\begin{equation*}
    \im_n(f)\defeq \sm{b:B} \trunc n{\hfib{f}b}.
\end{equation*}
当 $n=-1$ 时，我们简单地写作 $\im(f)$ 并称其为 $f$ 的 \define{像 (image)}。
\end{defn}

\begin{lem}\label{prop:to_image_is_connected}
对于任何函数 $f:A\to B$，规范函数 $\tilde{f}:A\to\im_n(f)$ 是 $n$-连通的。因此，任何函数都可以分解为一个 $n$-连通的函数后接一个 $n$-截断的函数。
\end{lem}

\begin{proof}
    注意 $A\eqvsym\sm{b:B}\hfib{f}b$。函数 $\tilde{f}$ 是由规范的纤维变换
    \begin{equation*}
        \prd{b:B} \Parens{\hfib{f}b\to\trunc n{\hfib{f}b}}
    \end{equation*}
    在总空间上诱导出的函数。由于每个映射 $\hfib{f}b\to\trunc n{\hfib{f}b}$ 通过 \cref{cor:totrunc-is-connected} 是 $n$-连通的，$\tilde{f}$ 通过 \cref{prop:nconn_fiber_to_total} 也是 $n$-连通的。最后，投影 $\proj1:\im_n(f) \to B$ 是 $n$-截断的，因为它的纤维与 $f$ 的纤维的 $n$-截断是等价的。
\end{proof}

在下面的引理中，我们设置了一些机制来证明唯一分解定理。

\begin{lem}\label{prop:factor_equiv_fiber}
假设我们有一个函数的交换图
\begin{equation*}
    \xymatrix{
            {A} \ar[r]^{g_1} \ar[d]_{g_2} &
            {X_1} \ar[d]^{h_1} &
        \\
        {X_2} \ar[r]_{h_2}
        &
            {B}
    }
\end{equation*}
其中 $H:h_1\circ g_1\htpy h_2\circ g_2$，$g_1$ 和 $g_2$ 是 $n$-连通的，$h_1$ 和 $h_2$ 是 $n$-截断的。那么存在一个等价
\begin{equation*}
    E(H,b):\hfib{h_1}b\eqvsym\hfib{h_2}b
\end{equation*}
对于任意 $b:B$，使得对于任何 $a:A$ 我们有一个同一性
\[\overline{E}(H,a) :  E(H,h_1(g_1(a)))({g_1(a),\refl{h_1(g_1(a))}}) = \pairr{g_2(a),\opp{H(a)}}。\]
\end{lem}

\begin{proof}
    令 $b:B$。然后我们有以下等价：
    \begin{align}
        \hfib{h_1}b
        & \eqvsym \sm{w:\hfib{h_1}b} \trunc n{ \hfib{g_1}{\proj1 w}}
        \tag{因为 $g_1$ 是 $n$-连通的}\\
        & \eqvsym \Trunc n{\sm{w:\hfib{h_1}b}\hfib{g_1}{\proj1 w}}
        \tag{由 \cref{thm:refl-over-ntype-base}，因为 $h_1$ 是 $n$-截断的}\\
        & \eqvsym \trunc n{\hfib{h_1\circ g_1}b}
        \tag{由 \cref{ex:unstable-octahedron}}
    \end{align}
    对 $h_2$ 和 $g_2$ 也同样成立。此外，由于我们有一个同伦 $H:h_1\circ g_1\htpy h_2\circ g_2$，存在一个显然的等价 $\hfib{h_1\circ g_1}b\eqvsym\hfib{h_2\circ g_2}b$。因此我们得到
    \begin{equation*}
        \hfib{h_1}b\eqvsym\hfib{h_2}b
    \end{equation*}
    对于任何 $b:B$。通过分析底层函数，我们得出在应用每个等价 $E$ 组成的映射后，$\pairr{g_1(a),\refl{h_1(g_1(a))}}$ 发生的变化。一些同一性是定义上的，但其他的（在下面用 $=$ 标记）是命题上的；将它们组合在一起，我们得到了 $\overline E(H,a)$。
        {\allowdisplaybreaks
    \begin{align*}
        \pairr{g_1(a),\refl{h_1(g_1(a))}} &
        \overset{=}{\mapsto} \Pairr{\pairr{g_1(a),\refl{h_1(g_1(a))}}, \tproj n{ \pairr{a,\refl{g_1(a)}}}}\\
        & \mapsto \tproj n { \pairr{\pairr{g_1(a),\refl{h_1(g_1(a))}}, \pairr{a,\refl{g_1(a)}} }}\\
        & \mapsto \tproj n { \pairr{a,\refl{h_1(g_1(a))}}}\\
        & \overset{=}{\mapsto} \tproj n { \pairr{a,\opp{H(a)}}}\\
        & \mapsto \tproj n { \pairr{\pairr{g_2(a),\opp{H(a)}},\pairr{a,\refl{g_2(a)}}} }\\
        & \mapsto \Pairr{\pairr{g_2(a),\opp{H(a)}}, \tproj n {\pairr{a,\refl{g_2(a)}}} }\\
        & \mapsto \pairr{g_2(a),\opp{H(a)}}
    \end{align*}}
    第一个等式是因为对于一般的 $b$，映射
    \narrowequation{ \hfib{h_1}b \to \sm{w:\hfib{h_1}b} \trunc n{ \hfib{g_1}{\proj1 w}} }
    插入了通过假设 $g_1$ 是 $n$-截断的来提供的 $\trunc n{ \hfib{g_1}{\proj1 w}}$ 的收缩中心；而在这种情况下，该类型有一个显而易见的居留元 $\tproj n{ \pairr{a,\refl{g_1(a)}}}$，通过收缩性必须等于该中心。第二个命题等式是因为等价 $\hfib{h_1\circ g_1}b\eqvsym\hfib{h_2\circ g_2}b$ 将第二个分量与 $\opp{H(a)}$ 连接在一起，而我们有 $\opp{H(a)} \ct \refl{} = \opp{H(a)}$。读者可以检查其他的等式是定义上的（假设 \cref{ex:unstable-octahedron} 有合理的解）。
\end{proof}

% 这些等价 $E(H,b)$ 满足 $E(H^{-1},b)= E(H,b)^{-1}$。

结合 \cref{prop:to_image_is_connected,prop:factor_equiv_fiber}，我们有以下唯一分解结果：

\begin{thm}\label{thm:orth-fact}
对于每个函数 $f:A\to B$，空间 $\fact_n(f)$ 定义为
\begin{equation*}
    \sm{X:\type}{g:A\to X}{h:X\to B} (h\circ g\htpy f)\times\mathsf{conn}_n(g)\times\mathsf{trunc}_n(h)
\end{equation*}
是收缩的。
它的收缩中心是由 \cref{prop:to_image_is_connected} 得到的元素
\begin{equation*}
    \pairr{\im_n(f),\tilde{f},\proj1,\theta,\varphi,\psi}:\fact_n(f)
\end{equation*}
其中 $\theta:\proj1\circ\tilde{f}\htpy f$ 是规范的同伦，$\varphi$ 是 \cref{prop:to_image_is_connected} 的证明，$\psi$ 是证明 $\proj1:\im_n(f)\to B$ 的纤维是 $n$-截断的显然的证明。
\end{thm}

\begin{proof}
    通过 \cref{prop:to_image_is_connected} 我们知道存在 $\fact_n(f)$ 的一个元素，因此只需证明 $\fact_n(f)$ 是一个纯命题。假设我们有两个 $n$-分解
    \begin{equation*}
        \pairr{X_1,g_1,h_1,H_1,\varphi_1,\psi_1}\qquad\text{和}\qquad\pairr{X_2,g_2,h_2,H_2,\varphi_2,\psi_2}
    \end{equation*}
    那么我们有点按连接的同伦
    \[ H\defeq (\lam{a} H_1(a) \ct H_2^{-1}(a)) \,:\, (h_1\circ g_1\htpy h_2\circ g_2)。\]
    通过一致性和在 $\Sigma$ 类型、函数类型和路径类型中的路径和运输的特性，证明以下四点即可：
    \begin{enumerate}
        \item 存在一个等价 $e:X_1\eqvsym X_2$，
        \item 存在一个同伦 $\zeta:e\circ g_1\htpy g_2$，
        \item 存在一个同伦 $\eta:h_2\circ e\htpy h_1$，
        \item 对于任意 $a:A$，我们有 $\opp{\apfunc{h_2}(\zeta(a))} \ct \eta(g_1(a)) \ct H_1(a) = H_2(a)$。
    \end{enumerate}
    我们按顺序证明这四个断言：
    \begin{enumerate}
        \item 通过 \cref{prop:factor_equiv_fiber}，我们有一个纤维等价
        \begin{equation*}
            E(H) : \prd{b:B} \eqv{\hfib{h_1}b}{\hfib{h_2}b}.
        \end{equation*}
        这诱导了总空间的等价，即我们有
        \begin{equation*}
            \eqvspaced{\Parens{\sm{b:B} \hfib{h_1}b}}{\Parens{\sm{b:B}\hfib{h_2}b}}。
        \end{equation*}
        当然，通过 \cref{thm:total-space-of-the-fibers}，我们也有等价 $X_1\eqvsym\sm{b:B}\hfib{h_1}b$ 和 $X_2\eqvsym\sm{b:B} \hfib{h_2}b$。这给了我们等价 $e:X_1\eqvsym X_2$；读者可以验证 $e$ 的底层函数由下式给出
        \begin{equation*}
            e(x) \jdeq \proj1(E(H,h_1(x))(x,\refl{h_1(x)}))。
        \end{equation*}
        \item 通过 \cref{prop:factor_equiv_fiber}，我们可以选择
        $\zeta(a) \defeq \apfunc{\proj1}(\overline E(H,a)) : e(g_1(a)) = g_2(a)$。
        \label{item:orth-fact-2}
        \item 对于每个 $x:X_1$，我们有
        \begin{equation*}
            \proj2(E(H,h_1(x))({x,\refl{h_1(x)}})) :h_2(e(x))= h_1(x)，
        \end{equation*}
        给了我们一个同伦 $\eta:h_2\circ e\htpy h_1$。
        \item 通过纤维中的路径的特性 (\cref{lem:hfib})，来自 \cref{prop:factor_equiv_fiber} 的路径 $\overline E(H,a)$ 给出了
        $\eta(g_1(a)) = \apfunc{h_2}(\zeta(a)) \ct \opp{H(a)}$。
        所需的等式通过替换 $H$ 的定义并重新排列路径得出。\qedhere
    \end{enumerate}
\end{proof}

通过标准的论证，这产生了以下正交性原则。

\begin{thm}
    设 $e:A\to B$ 是 $n$-连通的，并且 $m:C\to D$ 是 $n$-截断的。则映射
    \[ \varphi: (B\to C) \;\to\; \sm{h:A\to C}{k:B\to D} (m\circ h \htpy k \circ e) \]
    是一个等价。
\end{thm}
\begin{proof}[证明简述]
    对于任意的 $(h,k,H)$ 在上面的域中，设 $h = h_2 \circ h_1$ 且 $k = k_2 \circ k_1$，其中 $h_1$ 和 $k_1$ 是 $n$-连通的，而 $h_2$ 和 $k_2$ 是 $n$-截断的。则 $f = (m\circ h_2) \circ h_1$ 和 $f = k_2 \circ (k_1\circ e)$ 都是 $m \circ h = k\circ e$ 的 $n$-分解。因此，它们之间存在唯一的等价。从中提取 $\hfib\varphi{(h,k,H)}$ 是收缩的，这是显而易见的。
\end{proof}

\index{正交分解系统|)}%
\index{唯一!分解系统|)}%

我们最后展示像在拉回下是稳定的。
\index{像!在拉回下的稳定性}%
\index{分解!在拉回下的稳定性}

\begin{lem}\label{lem:hfiber_wrt_pullback}
假设以下方块
\begin{equation*}
    \vcenter{\xymatrix{
        A\ar[r]\ar[d]_f &
        C\ar[d]^g\\
        B\ar[r]_-h &
        D
    }}
\end{equation*}
是一个拉回方块，并且令 $b:B$。则 $\hfib{f}b\eqvsym\hfib{g}{h(b)}$。
\end{lem}

\begin{proof}
    这来自拉回的粘贴 (\cref{ex:pullback-pasting})，因为下图中的类型 $X$
    \begin{equation*}
        \vcenter{\xymatrix{
            X\ar[r]\ar[d] &
            A\ar[r]\ar[d]_f &
            C\ar[d]^g\\
            \unit\ar[r]_b &
            B\ar[r]_h &
            D
        }}
    \end{equation*}
    是左边方块的拉回当且仅当它是外矩形的拉回，而 $\hfib{f}b$ 是左边方块的拉回，$\hfib{g}{h(b)}$ 是外矩形的拉回。
\end{proof}

\begin{thm}\label{thm:stable-images}
\index{稳定性!像在拉回下的稳定性}%
考虑函数 $f:A\to B$, $g:C\to D$ 和下图
\begin{equation*}
    \vcenter{\xymatrix{
        A\ar[r]\ar[d]_{\tilde{f}_n} &
        C\ar[d]^{\tilde{g}_n}\\
        \im_n(f)\ar[r]\ar[d]_{\proj1} &
        \im_n(g)\ar[d]^{\proj1}\\
        B\ar[r]_h &
        D
    }}
\end{equation*}
如果外矩形是一个拉回，那么下方方块也是（因此通过 \cref{ex:pullback-pasting} 上方方块也是）。因此，像在拉回下是稳定的。
\end{thm}

\begin{proof}
    假设外方块是一个拉回，我们有以下等价
    \begin{align*}
        $B\times_D\im_n(g)$ & \jdeq \sm{b:B}{w:\im_n(g)} h(b)=\proj1 w\\
        & \eqvsym \sm{b:B}{d:D}{w:\trunc n{\hfib{g}d}} h(b)= d\\
        & \eqvsym \sm{b:B} \trunc n{\hfib{g}{h(b)}}\\
        & \eqvsym \sm{b:B} \trunc n{\hfib{f}b} &&
        \text{(通过 \cref{lem:hfiber_wrt_pullback})}\\
        & \equiv \im_n(f)。 && \qedhere
    \end{align*}
\end{proof}

\index{n-类型@$n$-type|)}%

\section{模态 (Modalities)}
\label{sec:modalities}

\index{modality|(}

几乎所有关于 $n$-类型 ($n$-types) 和连通性 (connectedness) 的理论都可以在更广泛的范围内进行研究。本节内容在本书的其他部分中不会被使用。

我们首先想到的关于推广 $n$-类型理论的方法可能是将 \cref{thm:trunc-reflective} 作为定义。

\begin{defn}\label{defn:reflective-subuniverse}
\define{反射子宇宙 (reflective subuniverse)}
\indexdef{reflective!subuniverse}%
\indexdef{subuniverse, reflective}%
是谓词 $P:\type\to\prop$，使得对于每个 $A:\type$，我们都有一个类型 $\reflect A$，使得 $P(\reflect A)$ 成立，并且有一个映射
$\project_A:A\to\reflect A$，其性质是对于每个 $P(B)$ 成立的 $B:\type$，以下映射是一个等价：
\[\function{(\reflect A\to{}B)}{(A\to{}B)}{f}{f\circ\project_A}.\]
\end{defn}

我们写作 $\P \defeq \setof{A:\type | P(A)}$，因此 $A:\P$ 意味着 $A:\type$ 并且 $P(A)$ 成立。
我们也用 $\rec{\modal}$ 表示上述映射的准逆 (quasi-inverse)。
尽管 $\reflect$ 的符号可能看起来有些奇怪，但它很快就会变得清晰。

对于任何反射子宇宙，我们可以以通常的方式证明从范畴论 (category theory) 中反射子类 (reflective subcategories) 的所有熟知事实。例如，我们有：
\begin{itemize}
    \item 一个类型 $A$ 属于 $\P$ 当且仅当 $\project_A:A\to\reflect A$ 是一个等价。
    \item $\P$ 在收缩 (retracts) 下封闭。特别地，当 $\project_A$ 允许一个收缩时，$A$ 就属于 $\P$。
    \item 在适合的逐点一致同伦 (up-to-coherent-homotopy) 意义下，$\reflect$ 是一个函子 (functor)，我们可以在需要的任意高级别上将其精确化。
    \item $\P$ 中的类型在所有极限 (limits) 下封闭，例如乘积和拉回 (pullbacks)。特别地，对于任意 $A:\P$ 和 $x,y:A$，等式类型 $(x=_A y)$ 也在 $\P$ 中，因为它是两个函数 $\unit\to A$ 的拉回。
    \item $\P$ 中的余极限 (colimits) 可以通过对类型的普通余极限应用 $\reflect$ 来构造。
\end{itemize}

重要的是，乘积的封闭性也扩展到了“无限乘积”，即依赖函数类型 (dependent function types)。

\begin{thm}\label{thm:reflsubunv-forall}
如果 $B:A\to\P$ 是反射子宇宙 \P 中的任意类型族 (family of types)，那么 $\prd{x:A} B(x)$ 也在 \P 中。
\end{thm}
\begin{proof}
    对于任意 $x:A$，考虑函数 $\mathsf{ev}_x : (\prd{x:A} B(x)) \to B(x)$，定义为 $\mathsf{ev}_x(f) \defeq f(x)$。
    由于 $B(x)$ 属于 $P$，这可以扩展为一个函数
    \[ \rec{\modal}(\mathsf{ev}_x) : \reflect\Parens{\prd{x:A} B(x)} \to B(x). \]
    因此，我们可以定义 $h:\reflect(\prd{x:A} B(x)) \to \prd{x:A} B(x)$，令 $h(z)(x) \defeq \rec{\modal}(\mathsf{ev}_x)(z)$。
    然后 $h$ 是 $\project_{\prd{x:A} B(x)}$ 的一个收缩，因此 $\prd{x:A} B(x)$ 属于 $\P$。
\end{proof}

特别地，如果 $B:\P$ 并且 $A$ 是任意类型，那么 $(A\to B)$ 属于 \P。
在范畴论的语言中，这意味着任何反射子宇宙都是一个\define{指数理想 (exponential ideal)}。
\indexdef{exponential ideal}%
这反过来又意味着通过标准的论证，反射器保留有限乘积。

\begin{cor}\label{cor:trunc_prod}
对于任意类型 $A$ 和 $B$ 以及任意反射子宇宙，诱导映射 $\reflect(A\times B) \to \reflect(A) \times \reflect(B)$ 是一个等价。
\end{cor}
\begin{proof}
    只需证明 $\reflect(A) \times \reflect(B)$ 具有与 $\reflect(A\times B)$ 相同的普遍性质即可。
    根据上述关于 $\P$ 中类型在极限下封闭的备注，它属于 $\P$。
    现在令 $C:\P$；我们有
    \begin{align*}
    (\reflect(A) \times \reflect(B) \to C)
        &= (\reflect(A) \to (\reflect(B) \to C))\\
        &= (\reflect(A) \to (B \to C))\\
        &= (A \to (B \to C))\\
        &= (A \times B \to C)
    \end{align*}
    使用 $\reflect(B)$ 和 $\reflect(A)$ 的普遍性质，以及 $B\to C$ 属于 \P 的事实。
    很容易验证这个等价是通过与 $\mreturn_A \times \mreturn_B$ 复合得到的，如所需。
\end{proof}

可能看起来很奇怪，所有类型的反射子类 (reflective subcategories) 自动成为一个指数理想 (exponential ideal)，并且有一个保留乘积的反射器。然而，在经典的集合范畴 (category of sets) 中也是如此，原因相同。只是这个事实通常不被提及，因为经典的集合范畴——与同伦类型范畴 (category of homotopy types) 相比——并没有很多有趣的反射子类。

$n$-类型的两个基本性质在一般的反射子宇宙中并不共享：\cref{thm:ntypes-sigma}（在 $\Sigma$ 类型下的封闭性）和 \cref{thm:truncn-ind}（截断归纳，truncation induction）。然而，这两个性质的类比是等价的。

\begin{thm}\label{thm:modal-char}
对于反射子宇宙 \P，以下条件在逻辑上是等价的：
\begin{enumerate}
    \item 如果 $A:\P$ 且 $B:A\to \P$，那么 $\sm{x:A} B(x)$ 也属于 \P。\label{item:mchr1}
    \item 对于每个 $A:\type$、类型族 $B:\reflect A\to\P$ 以及映射 $g:\prd{a:A} B(\project(a))$，存在 $f:\prd{z:\reflect A} B(z)$，使得对于所有 $a:A$，都有 $f(\project(a)) = g(a)$。\label{item:mchr2}
\end{enumerate}
\end{thm}

\begin{proof}
    假设条件~\ref{item:mchr1} 成立。
    然后，在条件~\ref{item:mchr2} 的情况下，类型 $\sm{z:\reflect A} B(z)$ 属于 \P，并且我们有 $g':A\to \sm{z:\reflect A} B(z)$，定义为 $g'(a)\defeq (\project(a),g(a))$。
    因此，我们有 $\rec{\modal}(g'):\reflect A \to \sm{z:\reflect A} B(z)$，使得 $\rec{\modal}(g')(\project(a)) = (\project(a),g(a))$。

    现在考虑函数 $\proj1 \circ \rec{\modal}(g') : \reflect A \to \reflect A$ 和 $\idfunc[\reflect A]$。
    根据假设，当前置组合 $\project$ 时，这两个函数相等。
    因此，根据 $\reflect$ 的普遍性质，它们已经相等，即我们有 $p_z:\proj1(\rec{\modal}(g')(z)) = z$ 对于所有 $z$ 都成立。
    现在我们可以定义
    %
    \narrowequation{f(z) \defeq \trans{p_z}{\proj2(\rec{\modal}(g')(z))},}
    %
    使用 \cref{defn:reflective-subuniverse} 中定义的等价性原理，证明
    %
    \narrowequation{\rec{\modal}(g')(\project(a)) = (\project(a),g(a))}
    %
    的第一部分等于 $p_{\project(a)}$。因此，其第二部分证明 $f(\project(a)) = g(a)$，如所需。

    反过来，假设条件~\ref{item:mchr2} 成立，并且 $A:\P$ 且 $B:A\to\P$。
    令 $h$ 是复合函数
    \[ \reflect\Parens{\sm{x:A} B(x)} \xrightarrow{\reflect(\proj1)} \reflect A \xrightarrow{\opp{(\project_A)}} A. \]
    对于 $z:\sm{x:A} B(x)$，我们有
    \begin{align*}
        h(\project(z)) &= \opp\project(\reflect(\proj1)(\project(z)))\\
        &= \opp\project(\project(\proj1(z)))\\
        &= \proj1(z).
    \end{align*}
    将此路径表示为 $p_z$。
    现在，如果我们定义 $C:\reflect(\sm{x:A} B(x)) \to \type$ 为 $C(w) \defeq B(h(w))$，我们有
    \[ g \defeq \lam{z} \trans{p_z}{\proj2(z)} \;:\; \prd{z:\sm{x:A} B(x)} C(\project(z)). \]
    因此，假设条件产生了
    %
    \narrowequation{f:\prd{w:\reflect(\sm{x:A}B(x))} C(w)}
    %
    使得 $f(\project(z)) = g(z)$。
    组合 $h$ 和 $f$ 给出了一个函数
    %
    \narrowequation{k:\reflect(\sm{x:A}B(x)) \to \sm{x:A}B(x)}
    %
    定义为 $k(w) \defeq (h(w),f(w))$，而 $p_z$ 和等式 $f(\project(z)) = g(z)$ 显示 $k$ 是 $\project_{\sm{x:A}B(x)}$ 的一个收缩。
    因此，$\sm{x:A}B(x)$ 属于 \P。
\end{proof}

请注意与 \cref{sec:htpy-inductive} 中讨论的相似性。
\index{recursion principle!for a modality}%
\index{induction principle!for a modality}%
\index{uniqueness!principle, propositional!for a modality}%
反射子宇宙的反射器的普遍性质类似于归纳原则及其唯一性原理，而 \cref{thm:modal-char}\ref{item:mchr2} 类似于相应的归纳原则。
与 \cref{sec:htpy-inductive} 不同的是，这里这两者并不等价，因为我们只能将其消解到 \P 中的类型。
\cref{thm:modal-char} 的条件~\ref{item:mchr1} 修复了这种脱节。

不出所料，如果我们有归纳原则，那么我们可以推导出递归原则。
我们还可以推导出它的唯一性原理，只要我们允许自己消解到路径类型。
这表明了以下定义。
请注意，任何反射子宇宙都可以通过操作 $\reflect:\type\to\type$ 和函数 $\project_A:A\to \reflect A$ 来表征，因为我们有 $P(A) = \isequiv(\project_A)$。

\begin{defn}\label{defn:modality}
\define{模态 (modality)}
\indexdef{modality}
是一个操作 $\modal:\type\to\type$，它有以下特性：
\begin{enumerate}
    \item 对于每种类型 $A$，都有函数 $\mreturn^\modal_A:A\to\modal(A)$。\label{item:modal1}
    \item 对于每种类型 $A:\type$ 和每个类型族 $B:\modal(A)\to\type$，有一个函数\label{item:modal2}
    \begin{equation*}
        \ind{\modal}:\Parens{\prd{a:A}\modal(B(\mreturn^\modal_A(a)))}\to\prd{z:\modal(A)}\modal(B(z)).
    \end{equation*}
    \item 对于每个 $f:\prd{a:A}\modal(B(\mreturn^\modal_A(a)))$，都有路径 $\ind\modal(f)(\mreturn^\modal_A(a)) = f(a)$。\label{item:modal3}
    \item 对于任何 $z,z':\modal(A)$，函数 $\mreturn^\modal_{z=z'} : (z=z') \to \modal(z=z')$ 是一个等价。\label{item:modal4}
\end{enumerate}
我们说 $A$ 对于 $\modal$ 是 \define{模态的 (modal)}
\indexdef{modal!type}%
\indexdef{type!modal}%
，如果 $\mreturn^\modal_A:A\to\modal(A)$ 是一个等价，并且我们写作
\begin{equation}
    \modaltype\defeq\setof{X:\type | X \text{ 是 $\modal$-模态的} }\label{eq:modaltype}
\end{equation}
表示模态类型的集合。
\end{defn}

条件~\ref{item:modal2} 和~\ref{item:modal3} 与 \cref{thm:modal-char}\ref{item:mchr2} 非常相似，但使用 $\modal B(z)$ 而不是假设 $B$ 在 \P 中。
这允许我们仅使用操作 $\modal$ 来表述条件，而不需要事先给出谓词 $P:\type\to\prop$。
（这不是完全令人满意的，因为我们在条件~\ref{item:modal4} 中仍然不得不提及 $P$。我们不知道~\ref{item:modal4} 是否可以从~\ref{item:modal1}--\ref{item:modal3} 推导出来。）
然而，通过 \cref{defn:modality}\ref{item:modal2} 和~\ref{item:modal3} 可以推出 \cref{thm:modal-char}\ref{item:mchr2} 中的看似更强的性质，因为对于任何 $C:\modal A \to \modaltype$，我们有 $C(z) \eqvsym \modal C(z)$，并且我们可以跨越这个等价。

\index{universal!property!of a modality}%
与其他归纳原则一样，这也意味着一个普遍性质。

\begin{thm}\label{prop:lv_n_deptype_sec_equiv_by_precomp}
令 $A$ 为一个类型，令 $B:\modal(A)\to\modaltype$。则函数
\begin{equation*}
(\blank\circ \mreturn^\modal_A) : \Parens{\prd{z:\modal(A)}B(z)} \to \Parens{\prd{a:A}B(\mreturn^\modal_A(a))}
\end{equation*}
是一个等价。
\end{thm}
\begin{proof}
    根据定义，操作 $\ind{\modal}$ 是 $(\blank\circ \mreturn^\modal_A)$ 的右逆。
    因此，我们只需找到一个同伦
    \begin{equation*}
        \prd{z:\modal(A)}s(z)= \ind{\modal}(s\circ \mreturn^\modal_A)(z)
    \end{equation*}
    对于每个 $s:\prd{z:\modal(A)}B(z)$，将其展示为左逆。
    根据假设，每个 $B(z)$ 都是模态的，因此每种类型 $s(z)= R^\modal_X(s\circ \mreturn^\modal_A)(z)$ 也是模态的。
    因此，只需找到类型
    \begin{equation*}
        \prd{a:A}s(\mreturn^\modal_A(a))= \ind{\modal}(s\circ \mreturn^\modal_A)(\mreturn^\modal_A(a))
    \end{equation*}
    的一个函数，这可以从 \cref{defn:modality}\ref{item:modal3} 中得出。
\end{proof}

特别地，对于每种类型 $A$ 和每个模态类型 $B$，我们有等价 $(\modal A\to B)\eqvsym (A\to B)$。

\begin{cor}
    对于任何模态 $\modal$，$\modal$-模态类型构成一个满足 \cref{thm:modal-char} 等价条件的反射子宇宙。
\end{cor}

因此，模态可以与在 $\Sigma$ 类型下封闭的反射子宇宙相识别。
\emph{模态} 一词来源于 \emph{模态逻辑} (modal logic)，研究可以形成诸如“可能 $A$”（通常写作 $\diamond A$）或“必然 $A$”（通常写作 $\Box A$）的陈述。
符号 $\modal$ 在任意模态算子 (modal operator) 中较为常见。% (而不是像 $\diamond$ 或 $\Box$ 这样的特定符号)。
在命题即类型 (propositions-as-types) 原则下，模态逻辑中的模态对应于 \emph{类型} 上的操作，并且 \cref{defn:modality} 似乎是如何定义此类操作的一个合理候选。
（更精确地说，我们或许应该称这些为 \emph{幺半模态} (idempotent, monadic) 模态；参见注释部分。）
\index{idempotent!modality}%
如 \cref{subsec:when-trunc} 所述，我们通常可以使用副词\index{adverb}来非正式地谈论这些模态，例如“仅仅”（merely）\index{merely} 对于命题截断 (propositional truncation) 和“纯粹地”（purely）\index{purely} 对于身份模态 (identity modality)
\index{identity!modality}%
\index{modality!identity}%
（即由 $\modal A \defeq A$ 定义的那个）。

对于任何模态 $\modal$，我们定义映射 $f:A\to B$ 为 \define{$\modal$-连通的 ($\modal$-connected)}\indexdef{function!.circle-connected@$\modal$-connected}%
\indexdef{.circle-connected function@$\modal$-connected function}%
如果 $\modal(\hfib f b)$ 对于所有 $b:B$ 是收缩的 (contractible)，并且定义为 \define{$\modal$-截断的 ($\modal$-truncated)}\indexdef{function!.circle-truncated@$\modal$-truncated}%
\indexdef{.circle-truncated function@$\modal$-truncated function}%
如果 $\hfib f b$ 对于所有 $b:B$ 是模态的。
\cref{sec:connectivity,sec:image-factorization} 中的所有理论只要不涉及不同 $n$ 值的 $n$-类型之间的关系，都可以在这个一般情况下原封不动地适用。
\index{orthogonal factorization system}%
\index{unique!factorization system}%
特别是，我们有一个正交分解系统 (orthogonal factorization system)。

一类重要的模态是不包括 $n$-截断的 (truncation) \emph{左正合模态} (left exact modalities)：它们的函子 $\modal$ 保留拉回 (pullbacks) 以及有限乘积 (finite products)。
\index{topology!Lawvere-Tierney}%
这些是在初等拓扑斯 (elementary topos) 理论中“Lawvere-Tierney\index{Lawvere}\index{Tierney} 拓扑”的范畴化 (categorification)，在高阶范畴语义学 (higher-categorical semantics) 中对应于子-$(\infty,1)$-拓扑斯。
\index{.infinity1-topos@$(\infty,1)$-topos}%
然而，这超出了本书的讨论范围。

除了 $n$-截断外，还可以在练习中找到其他特定的模态例子。

\index{modality|)}

\sectionNotes

同伦理论 (classical homotopy theory) 中的同伦 $n$-类型的概念相当古老。
是 Voevodsky 意识到这个概念可以在同伦类型论 (homotopy type theory) 中递归定义，从契约性 (contractibility) 开始。

\index{axiom!Streicher's Axiom K}%
“公理 K (Axiom K)” 属性由 Thomas Streicher 命名，作为身份类型 (identity types) 的一种性质，它出现在 J 之后，J 是身份类型消解器 (eliminator) 的传统名称。
\cref{thm:hedberg} 归因于 Hedberg~\cite{hedberg1998coherence}；\cite{krausgeneralizations} 包含更多信息和推广。

$n$-连通空间和函数的概念在同伦理论中也是经典的，尽管如前所述，我们对函数连通性的索引比经典索引多一个。
由 Rezk、Lurie 和其他人在高阶拓扑斯理论中的最新工作强调了由此产生的分解系统的重要性。%
\index{.infinity1-topos@$(\infty,1)$-topos}
特别是，本章的结果应该与~\cite[\S6.5.1]{lurie:higher-topoi} 进行比较。
在 \cref{sec:freudenthal} 中，$n$-连通映射的理论对于我们的 Freudenthal 悬挂定理 (Freudenthal suspension theorem) 的证明至关重要。

模态算子\index{modal!operator} 在 \emph{简单} 类型论 (simple type theory) 中已经被广泛研究；参见例如~\cite{modalTT}。在依赖类型论 (dependent type theory) 的背景下，\cite{ab:bracket-types} 处理了作为模态算子的命题截断 ($(-1)$-truncation) 的特殊情况。这里提出的发展极大地扩展和推广了这项工作，同时还借鉴了拓扑斯理论 (topos theory) 的思想。\index{topos}

通常，模态算子\index{modal!operator} 至少有两种类型：如 $\diamond$（“可能”）的那些类型，其中 $A\Rightarrow \diamond A$，以及如 $\Box$（“必然”）的那些类型，其中 $\Box A \Rightarrow A$。
当它们也是 \emph{幺半的} (idempotent)（即 $\diamond A = \diamond{\diamond A}$ 或 $\Box A = \Box{\Box A}$）时，前者可以与反射子类 (reflective subcategories)（或等价地，幺半单子 (idempotent monads)）相识别，后者可以与对反射子类 (coreflective subcategories)（或幺半伴随 (idempotent comonads)）相识别。
\index{monad}
\index{comonad}
然而，在依赖类型论中处理共单子类型 (comonadic sort) 更为棘手，因为它们更少稳定于拉回下，因此不能解释为宇宙 $\UU$ 上的操作。
有时可以绕过这个问题（例如，参见~\cite{QGFTinCHoTT12}），但为了简洁，这里我们坚持单子类型。

在计算机科学方面，单子 (monads)（因此模态\index{modality}）用于在函数式编程 (functional programming) 中模拟计算效果 (computational effects)~\cite{Moggi89}。%
\index{programming}%
\index{computational effect}
当执行结果没有副作用（例如在屏幕上打印消息、播放音乐或通过互联网发送数据）时，计算被称为 \emph{纯粹的} (pure)。
存在“纯函数式”编程语言 (purely functional programming languages)，例如 Haskell\index{Haskell}，其中从技术上讲只能编写纯函数：副作用通过对输出类型应用“单子”来表示。
例如，类型为 $\mathsf{Int}\to\mathsf{Int}$ 的函数是纯的，而类型为 $\mathsf{Int}\to \mathsf{IO}(\mathsf{Int})$ 的函数在计算结果的过程中可能会执行输入和输出；操作 $\mathsf{IO}$ 是一个单子。
\index{purely}%
（这是我们使用副词“纯粹地 (purely)”来表示身份单子的起源，因为它在计算上对应于没有副作用的纯函数。）
我们在本章中考虑的模态都是幺半的，而函数式编程中使用的那些则很少如此，但这些思想仍然密切相关。

\sectionExercises

\begin{ex}\label{ex:all-types-sets}\
\begin{enumerate}
    \item 使用 \cref{thm:h-set-refrel-in-paths-sets} 证明，如果对于每种类型 $A$，都有 $\brck{A}\to A$，那么每种类型都是集合。
    \item 证明如果每个满射函数 (surjective function)（纯粹地）分裂，即
    %
    \narrowequation{\prd{b:B}\brck{\hfib{f}{b}}\to\prd{b:B}\hfib{f}{b}}
    %
    对于每个 $f:A\to B$，那么每种类型都是集合。
\end{enumerate}
\end{ex}

\begin{ex}\label{ex:s2-colim-unit}
对于这个练习，我们考虑以下一般的余极限概念 (colimit)。
定义一个 \define{图 (graph)}\indexdef{graph} $\Gamma$，其由类型 $\Gamma_0$ 和一个家族 $\Gamma_1 : \Gamma_0 \to \Gamma_0 \to \UU$ 组成。
一个 \define{图上的图表 (diagram)}\index{diagram}（类型的）由图 $\Gamma$ 组成，连同对于每个 $x,y:\Gamma_0$ 的函数 $F_{x,y}:\Gamma_1(x,y) \to F(x) \to F(y)$。
此类图表的 \define{余极限}\index{colimit!of types} 是由以下类型生成的高阶归纳类型 (higher inductive type) $\colim(F)$：
\begin{itemize}
    \item 对于每个 $x:\Gamma_0$，一个函数 $\inc_x:F(x) \to \colim(F)$，以及
    \item 对于每个 $x,y:\Gamma_0$ 和 $\gamma:\Gamma_1(x,y)$ 以及 $a:F(x)$，一个路径 $\inc_y(F_{x,y}(\gamma,a)) = \inc_x(a)$。
\end{itemize}
当然，还有更多类型的余极限（例如，参见 \cref{ex:s2-colim-unit-2}），但这已经足够满足许多目的。
\begin{enumerate}
    \item 展示一个图 $\Gamma$，使得 $\Gamma$-图表的余极限可以与 \cref{sec:colimits} 中定义的推挤 (pushouts) 相识别。换句话说，每个跨度都应该引发一个 $\Gamma$ 上的图表，其余极限是该跨度的推挤。
    \item 展示一个图 $\Gamma$ 和图表 $F$，其中 $\Gamma$ 上的图表 $F(x)=\unit$ 对于所有 $x$ 都成立，但 $\colim(F)=\Sn^2$。请注意，$\unit$ 是 $(-2)$-类型，而 $\Sn^2$ 不应被视为任何有限 $n$ 的 $n$-类型。另见 \cref{ex:s2-colim-unit-2}。
\end{enumerate}
\end{ex}

\begin{ex}\label{ex:ntypes-closed-under-wtypes}
证明如果 $A$ 是一个 $n$-类型，并且 $B:A\to \ntype{n}$ 是一个 $n$-类型的家族，其中 $n\ge -1$，那么 $W$ 类型 $\wtype{a:A} B(a)$（参见 \cref{sec:w-types}）也是一个 $n$-类型。
\end{ex}

\begin{ex}\label{ex:connected-pointed-all-section-retraction}
使用 \cref{prop:nconn_fiber_to_total} 将 \cref{thm:connected-pointed} 扩展到任何截面-收缩对 (section-retraction pair)。
\end{ex}

\begin{ex}\label{ex:ntype-from-nconn-const}
证明 \cref{thm:nconn-to-ntype-const} 也可以作为反方向的表征：如果 $B$ 是 $n$-类型，则每个从 $n$-连通类型映射到 $B$ 的映射都是常数映射。
理想情况下，您的证明应适用于 \cref{sec:modalities} 中的任何模态。
\end{ex}

\begin{ex}\label{ex:connectivity-inductively}
证明对于 $n\ge -1$，一个类型 $A$ 是 $n$-连通的，如果且仅如果它只是被居住，并且对于所有 $a,b:A$，类型 $\id[A]ab$ 是 $(n-1)$-连通的。
因此，由于每种类型都是 $(-2)$-连通的，$n$-连通性类型可以仅使用命题截断递归定义。
（特别地，$A$ 是 0-连通的，如果且仅如果 $\brck{A}$ 和 $\prd{a,b:A} \brck{a=b}$。）
\end{ex}

\begin{ex}\label{ex:lemnm}
\indexdef{excluded middle!LEMnm@$\LEM{n,m}$}%
对于 $-1\le n,m \le\infty$，令 $\LEM{n,m}$ 表示陈述
\[ \prd{A:\ntype{n}} \trunc m{A + \neg A},\]
其中 $\ntype{\infty} \defeq \type$ 并且 $\trunc{\infty}{X}\defeq X$。
证明：
\begin{enumerate}
    \item 如果 $n=-1$ 或 $m=-1$，那么 $\LEM{n,m}$ 等价于 \cref{sec:intuitionism} 中的 $\LEM{}$。
    \item 如果 $n\ge 0$ 并且 $m\ge 0$，那么 $\LEM{n,m}$ 与一值性 (univalence) 不一致。
\end{enumerate}
\end{ex}

\begin{ex}\label{ex:acnm}
\indexdef{axiom!of choice!ACnm@$\choice{n,m}$}%
对于 $-1\le n,m\le\infty$，令 $\choice{n,m}$ 表示陈述
\[ \prd{X:\set}{Y:X\to\ntype{n}}
\Parens{\prd{x:X} \trunc m{Y(x)}}
\to
\Trunc m{\prd{x:X} Y(x)},
\]
与 \cref{ex:lemnm} 中的惯例相同。
因此，$\choice{0,-1}$ 是 \cref{sec:axiom-choice} 中的选择公理 (axiom of choice)，而 $\choice{\infty,\infty}$ 是恒等函数。
（如果我们像 \eqref{eq:ac} 而不是 \eqref{eq:epis-split} 那样制定 $\choice{n,m}$，那么 $\choice{\infty,\infty}$ 会像 \cref{thm:ttac} 一样。）
众所周知，$\choice{\infty,-1}$ 与一值性是一致的，因为它在 Voevodsky 的单纯模型 (simplicial model) 中成立。
\begin{enumerate}
    \item 不使用一值性，证明 $\LEM{n,\infty}$ 意味着 $\choice{n,m}$ 对所有 $m$ 成立。
    （另一方面，在 \cref{subsec:emacinsets} 中，我们将证明 $\choice{}=\choice{0,-1}$ 意味着 $\LEM{}=\LEM{-1,-1}$。）
    \item 当然，如果 $k\le n$，则 $\choice{n,m}\Rightarrow \choice{k,m}$。
    $\choice{n,m}$ 之间还有其他含义吗？
    $\choice{n,m}$ 与一值性对任何 $m\ge 0$ 和任何 $n$ 一致吗？
    （这些是开放问题。）\index{open!problem}
\end{enumerate}
\end{ex}

\begin{ex}\label{ex:acnm-surjset}
证明 $\choice{n,-1}$ 意味着对于任何 $n$-类型 $A$，仅存在一个集合 $B$ 并且一个满射 $B\to A$。
\end{ex}

\begin{ex}\label{ex:acconn}
定义 \define{$n$-连通选择公理 ($n$-connected axiom of choice)}
\indexdef{n-connected@$n$-connected!axiom of choice}%
\indexdef{axiom!of choice!n-connected@$n$-connected}%
为以下陈述：
\begin{quote}
    如果 $X$ 是一个集合并且 $Y:X\to \type$ 是一个类型家族，使得每个 $Y(x)$ 是 $n$-连通的，那么 $\prd{x:X} Y(x)$ 是 $n$-连通的。
\end{quote}
请注意，$(-1)$-连通选择公理是 \cref{ex:acnm} 中的 $\choice{\infty,-1}$。
\begin{enumerate}
    \item 证明 $(-1)$-连通选择公理意味着所有 $n\ge -1$ 的 $n$-连通选择公理。
    \item $n$-连通选择公理与 $\choice{n,m}$ 原则之间还有其他含义吗？
    （这是一个开放问题。）\index{open!problem}
\end{enumerate}
\end{ex}

\begin{ex}\label{ex:n-truncation-not-left-exact}
证明 $n$-截断模态对于任何 $n\ge -1$ 都不是左正合的。也就是说，展示一个它不能保留的拉回。
\end{ex}

\begin{ex}\label{ex:double-negation-modality}
证明 $X\mapsto (\neg\neg X)$ 是一个模态。\index{modal!operator}%
\end{ex}

\begin{ex}\label{ex:prop-modalities}
令 $P$ 为一个纯命题 (mere proposition)。
\begin{enumerate}
    \item 证明 $X\mapsto (P\to X)$ 是一个左正合模态。这称为 \define{开模态 (open modality)}\indexdef{open!modality}%
    \indexdef{modality!open}% 与 $P$ 关联。
    \item 证明 $X\mapsto P*X$ 是一个左正合模态，其中 $*$ 表示连接 (join)（参见 \cref{sec:colimits}）。这称为 \define{闭模态 (closed modality)}\indexdef{closed!modality}%
    \indexdef{modality!closed}%
    与 $P$ 关联。
\end{enumerate}
\end{ex}

\begin{ex}\label{ex:f-local-type}
令 $f:A\to B$ 为一个映射；类型 $Z$ 是 \define{$f$-局部的 ($f$-local)}
\indexdef{f-local type@$f$-local type}%
\indexdef{type!f-local@$f$-local}%
如果 $(\blank\circ f):(B\to Z) \to (A\to Z)$ 是一个等价。
\begin{enumerate}
    \item 证明 $f$-局部类型构成一个反射子宇宙。您将需要使用高阶归纳类型定义反射器 (localization)。
    \item 证明如果 $B=\unit$，那么该子宇宙是一个模态。
\end{enumerate}
\end{ex}

\begin{ex}\label{ex:trunc-spokes-no-hub}
与 \cref{rmk:spokes-no-hub} 相反，展示我们可以等效地定义 $\trunc nA$ 为由函数 $\tprojf n : A \to \trunc n A$ 生成的类型，连同每个 $r:\Sn^{n+1} \to \trunc n A$ 和每个 $x:\Sn^{n+1}$ 的路径 $s_r(x):r(x) = r(\base)$。
\end{ex}

\begin{ex}\label{ex:s2-colim-unit-2}
在这个练习中，我们考虑一个比 \cref{ex:s2-colim-unit} 中略为复杂的余极限概念。
定义 \define{具有复合的图 (graph with composition)}\indexdef{graph!with composition} $\Gamma$ 为一个图，如 \cref{ex:s2-colim-unit} 中所述，连同每个 $x,y,z:\Gamma_0$ 的函数 $\Gamma_1(y,z) \to \Gamma_1(x,y) \to \Gamma_1(x,z)$，表示为 $\delta\mapsto\gamma \mapsto \delta \circ \gamma$。
（例如，\cref{cha:category-theory} 中的任何预范畴 (precategory) 都是一个具有复合的图。）
一个 \define{图上的图表 (diagram)}\index{diagram} $F$ 由基础图上的图表组成，连同每个 $x,y,z:\Gamma_0$ 和 $\gamma:\Gamma_1(x,y)$ 以及 $\delta:\Gamma_1(y,z)$ 的同伦 $\cmp_{x,y,z}(\delta,\gamma) : F_{y,z}(\delta) \circ F_{x,y}(\gamma) \htpy F_{x,z}(\delta\circ\gamma)$。
此类图表的 \define{余极限}\index{colimit!of types} 是由以下类型生成的高阶归纳类型 $\colim(F)$：
\begin{itemize}
    \item 对于每个 $x:\Gamma_0$，一个函数 $\inc_x:F(x) \to \colim(F)$，
    \item 对于每个 $x,y:\Gamma_0$ 和 $\gamma:\Gamma_1(x,y)$ 以及 $a:F(x)$，一个路径 $\glue_{x,y}(\gamma,a) : \inc_y(F_{x,y}(\gamma,a)) = \inc_x(a)$，以及
    \item 对于每个 $x,y,z:\Gamma_0$ 和 $\gamma:\Gamma_1(x,y)$ 以及 $\delta:\Gamma_1(y,z)$ 以及 $a:F(x)$，一个路径
    \[ \ap{\inc_z}{\cmp_{x,y,z}(\delta,\gamma,a)} \ct \glue_{x,z}(\delta\circ \gamma,a) = \glue_{y,z}(\delta,F_{x,y}(\gamma,a)) \ct \glue_{x,y}(\gamma,a)。 \]
\end{itemize}
（这是“第二阶近似”，用于完全同伦理论 (homotopy-theoretic) 的图表和余极限概念，应该涉及所有更高层次的“连贯路径” (coherence paths)。
在类型论中定义这种东西是一个重要的开放问题。）

展示一个具有复合的图 $\Gamma$，其中 $\Gamma_0$ 是一个集合并且每个类型 $\Gamma_1(x,y)$ 是纯命题，并且展示一个图表 $F$ 使得 $\Gamma$ 上的图表 $F(x)=\unit$ 对于所有 $x$ 成立，但 $\colim(F)=\Sn^2$。
\end{ex}

\begin{ex}\label{ex:fiber-map-not-conn}
比较 \cref{lem:nconnected_postcomp_variation,prop:nconn_fiber_to_total}，您可能会推测，如果 $f:A\to B$ 是 $n$-连通的，并且 $g:\prd{a:A} P(a) \to Q(f(a))$ 诱导了一个 $n$-连通的映射 $\Parens{\sm{a:A} P(a)} \to \Parens{\sm{b:B} Q(b)}$，那么 $g$ 是纤维上的 $n$-连通的。
举出一个反例证明这不成立。
（实际上，当推广到模态时，该属性表征了左正合模态；参见 \cref{ex:prop-modalities}。）
\end{ex}

\begin{ex}\label{ex:is-conn-trunc-functor}
证明如果 $f : A \to B$ 是 $n$-连通的，那么 $\trunc kf : \trunc kA \to \trunc kB$ 也是 $n$-连通的。
\end{ex}

\begin{ex}\label{ex:categorical-connectedness}
我们说一个类型 $A$ 是 \define{范畴连通的 (categorically connected)}\indexdef{connected!categorically} 如果对于每种类型 $B, C$，通过函数定义的典型映射
$e_{A, B, C}:((A\to B) + (A\to C)) \to (A \to B + C)$
\begin{align*}
    e_{A,B,C}(\inl(g)) &\defeq \lam{x} \inl(g(x)),\\
    e_{A,B,C}(\inr(g)) &\defeq \lam{x} \inr(g(x))
\end{align*}
是一个等价。
\begin{enumerate}
    \item 证明任何连通类型都是范畴连通的。
    \item 证明如果且仅如果 $\LEM{}$ 成立，则所有范畴连通类型都是连通的。 （提示：考虑 $A \defeq \Sigma P$ 使得 $\neg \neg P$ 成立。）
\end{enumerate}
\end{ex}

%%% 本地变量：
%%% 模式：latex
%%% TeX-master: "hott-online"
%%% 结束：

