\chapter{同伦 $n$-类型 (Homotopy \texorpdfstring{$n$}{n}-types)}
\label{cha:hlevels}

\index{n-type@$n$-type|(}%
\indexsee{h-level}{$n$-type}

同伦理论 (Homotopy Theory) 中的一个基本概念是\emph{同伦 $n$-类型 (Homotopy $n$-type)}：它是一个在维度 $n$ 之上不包含有趣的同伦的空间。例如，一个同伦 $0$-类型 (Homotopy $0$-type) 本质上是一个集合，不包含非平凡路径 (Nontrivial Paths)，而同伦 $1$-类型 (Homotopy $1$-type) 可能包含非平凡路径，但不包含路径之间的非平凡路径。同伦 $n$-类型 (Homotopy $n$-types) 也被称为\emph{$n$-截断空间 ($n$-truncated spaces)}。我们已经在 \cref{sec:basics-sets} 提到了这个概念；我们本章的第一个目标是在同伦类型论 (Homotopy Type Theory) 中给出它的精确定义。

截断性 (Truncatedness) 的对偶概念是连通性 (Connectedness)：一个空间是\emph{$n$-连通 (n-connected)}的，如果它在维度 $n$ 及其以下没有有趣的同伦。例如，一个空间是 $0$-连通 (0-connected) 的（也称为``连通 (Connected)''），如果它只有一个连通分量，而 $1$-连通 (1-connected) 的（也称为``单连通 (Simply Connected)''），如果它也没有非平凡循环 (Nontrivial Loops)（尽管它可能有循环之间的非平凡高阶循环 (Higher Loops)）。

截断性 (Truncatedness) 和连通性 (Connectedness) 之间的对偶性最容易通过扩展这两种概念到映射 (Maps) 来看。我们称一个映射为\emph{$n$-截断 (n-truncated)}或\emph{$n$-连通 (n-connected)}的，如果它的所有纤维 (Fibers) 都是如此。那么 $n$-连通和 $n$-截断映射 (Maps) 形成一个\emph{正交分解系统 (Orthogonal Factorization System)}，即每个映射都唯一地分解为一个 $n$-连通映射和一个 $n$-截断映射。

在 $n={-1}$ 的情况下，$n$-截断映射 (n-truncated maps) 是嵌入 (Embeddings)，而 $n$-连通映射 (n-connected maps) 是满射 (Surjections)，如 \cref{sec:mono-surj} 中所定义。因此，$n$-连通分解系统 (n-connected factorization system) 是函数之间标准的图像分解的一个重大推广，它将集合之间的函数分解为一个满射和一个单射。在本章的最后，我们将简要地概述一个更一般的理论：任何类型理论中的\emph{模态性 (Modality)} 都会产生一个类似的分解系统。

\section{$n$-类型的定义 (Definition of \texorpdfstring{$n$}{n}-types)}
\label{sec:n-types}

如 \cref{sec:basics-sets,sec:contractibility} 所述，从零以下两个级别开始定义 $n$-类型是方便的，其中 $(-1)$-类型是纯命题 (Mere Propositions)，$(-2)$-类型是可收缩的 (Contractible)。

\begin{defn}\label{def:hlevel}
定义谓词 (Predicate) $\istype{n} : \type \to \type$ 对于 $n \geq -2$，其递归定义如下：
\[ \istype{n}(X) \defeq
\begin{cases}
    \iscontr(X) & \text{当 } n = -2 \text{ 时}, \\
    \prd{x,y : X} \istype{n'}(\id[X]{x}{y}) & \text{当 } n = n'+1 \text{ 时}.
\end{cases}
\]
我们称 $X$ 是一个\define{$n$-类型 (n-type)}，有时也称它是\emph{$n$-截断的 ($n$-truncated)}，
\indexdef{n-type@$n$-type}%
\indexsee{n-truncated@$n$-truncated!type}{$n$-type}%
\indexsee{type!n-type@$n$-type}{$n$-type}%
\indexsee{type!n-truncated@$n$-truncated}{$n$-type}%
如果 $\istype{n}(X)$ 是居留的 (Inhabited)。
\end{defn}

\begin{rmk}
    在 \cref{def:hlevel} 中，$n$ 的取值范围包括所有大于或等于 $-2$ 的整数。我们可以通过定义类型 $\Z_{{\geq}-2}$ 这样的整数类型来正式理解这一点（该类型的归纳原理与 $\nat$ 的归纳原理相同），或者定义谓词 $\istype{(k-2)}$ 对于 $k : \nat$。无论哪种方式，我们都可以通过对 $n$ 进行归纳来证明关于 $n$-类型的定理，其中 $n = -2$ 是基本情况。
\end{rmk}

\begin{eg}
    \index{set}
    我们在 \cref{thm:prop-minusonetype} 中已经看到，$X$ 是一个 $(-1)$-类型当且仅当它是一个纯命题 (Mere Proposition)。因此，$X$ 是一个 $0$-类型当且仅当它是一个集合 (Set)。
\end{eg}

我们还看到有些类型不是集合 (\cref{thm:type-is-not-a-set})。然而，到目前为止，我们还没有展示对于任何 $n>0$ 的类型，它们不是 $n$-类型。在 \cref{cha:homotopy} 中，我们将展示 $(n+1)$-球体 $\Sn^{n+1}$ 不是 $n$-类型。（Kraus 还展示了第 $n$ 层嵌套的单值宇宙 (Nested Univalent Universe) 也不是 $n$-类型，而没有使用任何高阶归纳类型 (Higher Inductive Types)）。此外，在 \cref{sec:whitehead} 中，我们将给出一个类型，它不是任何有限数 $n$ 的 $n$-类型。

我们从展示 $n$-类型在某些操作和构造下是封闭的开始，来展开 $n$-类型的一般理论。

\begin{thm}\label{thm:h-level-retracts}
\index{retract!of a type}%
\index{retraction}%
令 $p : X \to Y$ 是一个缩回 (Retraction)，并且假设 $X$ 是一个 $n$-类型，对于任何 $n\geq -2$。那么 $Y$ 也是一个 $n$-类型。
\end{thm}

\begin{proof}
    我们通过对 $n$ 进行归纳来证明。基本情况 $n=-2$ 由 \cref{thm:retract-contr} 处理。

    对于归纳步骤，假设任何 $n$-类型的缩回也是 $n$-类型，并且 $X$ 是一个 $\nplusone$-类型。令 $y, y' : Y$；我们必须证明 $\id{y}{y'}$ 是一个 $n$-类型。令 $s$ 是 $p$ 的一个截面 (Section)，并令 $\epsilon$ 是一个同伦 $\epsilon : p \circ s \htpy 1$。由于 $X$ 是一个 $\nplusone$-类型，$\id[X]{s(y)}{s(y')}$ 是一个 $n$-类型。我们声称 $\id{y}{y'}$ 是 $\id[X]{s(y)}{s(y')}$ 的一个缩回。对于截面，我们取
    \[ \apfunc s : (y=y') \to (s(y)=s(y')) \]
    对于缩回，我们定义 $t:(s(y)=s(y'))\to(y=y')$ 为
    \[ t(q) \defeq  \opp{\epsilon_y} \ct \ap p q \ct \epsilon_{y'} \]
    为了证明 $t$ 是 $\apfunc s$ 的缩回，我们必须证明
    \[ \opp{\epsilon_y} \ct \ap p {\ap sr} \ct \epsilon_{y'} = r \]
    对于任意 $r:y=y'$。但这由 \cref{lem:htpy-natural} 推出。
\end{proof}

作为一个直接的推论，我们得到 $n$-类型在等价 (Equivalence) 下的稳定性（这也是由单值性 (Univalence) 直接得到的）：

\begin{cor}\label{cor:preservation-hlevels-weq}
如果 $\eqv{X}{Y}$ 且 $X$ 是一个 $n$-类型，那么 $Y$ 也是。
\end{cor}

还记得在 \cref{sec:mono-surj} 中的嵌入 (Embedding) 的概念。

\begin{thm}\label{thm:isntype-mono}
\index{function!embedding}
如果 $f:X\to Y$ 是一个嵌入 (Embedding)，并且 $Y$ 是一个 $n$-类型，对于某个 $n\ge -1$，那么 $X$ 也是。
\end{thm}
\begin{proof}
    令 $x,x':X$；我们必须证明 $\id[X]{x}{x'}$ 是一个 $\nminusone$-类型。但是由于 $f$ 是一个嵌入，我们有 $(\id[X]{x}{x'}) \eqvsym (\id[Y]{f(x)}{f(x')})$，而后者根据假设是一个 $\nminusone$-类型。
\end{proof}

注意，当 $n=-2$ 时，这个定理是不成立的：映射 $\emptyt \to \unit$ 是一个嵌入，但 $\unit$ 是一个 $(-2)$-类型，而 $\emptyt$ 不是。

\begin{thm}\label{thm:hlevel-cumulative}
$n$-类型的层次结构是累积的，在以下意义上：给定一个数 $n \geq -2$，如果 $X$ 是一个 $n$-类型，那么它也是一个 $\nplusone$-类型。
\end{thm}

\begin{proof}
    我们通过对 $n$ 进行归纳来证明。

    对于 $n = -2$，我们需要证明一个可收缩类型 (Contractible Type)，例如 $A$，具有可收缩的路径空间 (Path Spaces)。令 $a_0: A$ 为 $A$ 的收缩中心 (Center of Contraction)，并令 $x, y : A$。我们证明 $\id[A]{x}{y}$ 是可收缩的。由于 $A$ 的可收缩性，我们有一条路径 $\contr_x \ct \opp{\contr_y} : x = y$，我们选择它作为 $\id{x}{y}$ 的收缩中心。给定任何路径 $p : x = y$，我们需要证明 $p = \contr_x \ct \opp{\contr_y}$。通过路径归纳 (Path Induction)，只需证明 $\refl{x} = \contr_x \ct \opp{\contr_x}$，这是显然的。

    对于归纳步骤，我们需要证明 $\id[X]{x}{y}$ 是一个 $\nplusone$-类型，前提是 $X$ 是一个 $\nplusone$-类型。将归纳假设应用于 $\id[X]{x}{y}$，即可得出所需结论。
\end{proof}

% \section{Preservation under constructors}
% \label{sec:ntype-pres}

现在我们展示 $n$-类型在大多数类型构造操作下的保留性。

\begin{thm}\label{thm:ntypes-sigma}
设 $n \geq -2$，并令 $A : \type$ 和 $B : A \to \type$。如果 $A$ 是一个 $n$-类型，并且对于所有 $a : A$，$B(a)$ 是一个 $n$-类型，那么 $\sm{x : A} B(x)$ 也是一个 $n$-类型。
\end{thm}

\begin{proof}
    我们通过对 $n$ 进行归纳来证明。

    对于 $n = -2$，我们选择 $\sm{x : A} B(x)$ 的收缩中心为 $(a_0, b_0)$，其中 $a_0 : A$ 是 $A$ 的收缩中心，$b_0 : B(a_0)$ 是 $B(a_0)$ 的收缩中心。给定 $\sm{x : A} B(x)$ 的任何其他元素 $(a,b)$，我们通过分别对 $A$ 和 $B(a_0)$ 的收缩性提供路径 $\id{(a, b)}{(a_0,b_0)}$。

    对于归纳步骤，假设 $A$ 是一个 $\nplusone$-类型，并且对于任意 $a : A$，$B(a)$ 是一个 $\nplusone$-类型。我们证明 $\sm{x : A} B(x)$ 是一个 $\nplusone$-类型：固定 $\sm{x : A} B(x)$ 中的 $(a_1, b_1)$ 和 $(a_2,b_2)$，我们需要证明 $\id{(a_1, b_1)}{(a_2,b_2)}$ 是一个 $n$-类型。根据 \cref{thm:path-sigma}，我们有
    \[ \eqvspaced{(\id{(a_1, b_1)}{(a_2,b_2)})}{\sm{p : \id{a_1}{a_2}} (\id[B(a_2)]{\trans{p}{b_1}}{b_2})} \]
    并且根据等价下 $n$-类型的保留性 (\cref{cor:preservation-hlevels-weq})，我们只需证明后者是一个 $n$-类型。这可以通过归纳假设得到。
\end{proof}

作为一个特例，如果 $A$ 和 $B$ 是 $n$-类型，那么 $A\times B$ 也是。还要注意，\cref{thm:hlevel-cumulative} 意味着如果 $A$ 是一个 $n$-类型，那么对于任意 $x,y:A$，$\id[A]xy$ 也是一个 $n$-类型。将此与 \cref{thm:ntypes-sigma} 结合，我们可以看到，对于 $n$-类型的函数 $f:A\to C$ 和 $g:B\to C$，它们的纤维积 (Pullback)
\[ A\times_C B \defeq \sm{x:A}{y:B} (f(x)=g(y)) \]
（参见 \cref{ex:pullback}）也是一个 $n$-类型。更一般地说，$n$-类型在所有\emph{极限 (Limits)}下是封闭的。

\begin{thm}\label{thm:hlevel-prod}
令 $n\geq -2$，并令 $A : \type$ 和 $B : A \to \type$。如果对于所有 $a : A$，$B(a)$ 是一个 $n$-类型，那么 $\prd{x : A} B(x)$ 也是一个 $n$-类型。
\end{thm}

\begin{proof}
    我们通过对 $n$ 进行归纳来证明。对于 $n = -2$，结果就是 \cref{thm:contr-forall}。

    对于归纳步骤，假设结果对于 $n$-类型成立，并且每个 $B(a)$ 都是一个 $\nplusone$-类型。令 $f, g : \prd{a:A}B(a)$。我们需要证明 $\id{f}{g}$ 是一个 $n$-类型。通过函数扩展性 (Function Extensionality) 和等价下 $n$-类型的封闭性，证明 $\prd{a : A} (\id[B(a)]{f(a)}{g(a)})$ 是一个 $n$-类型即可。这个结论可通过归纳假设得到。
\end{proof}

作为上述定理的一个特例，函数空间 $A \to B$ 是一个 $n$-类型，前提是 $B$ 是一个 $n$-类型。我们现在可以推广在 \cref{cha:basics} 中关于 $\isset(A)$ 和 $\isprop(A)$ 是纯命题的观察。

\begin{thm}\label{thm:isaprop-isofhlevel}
对于任何 $n \geq -2$ 和任何类型 $X$，类型 $\istype{n}(X)$ 是一个纯命题。
\end{thm}
\begin{proof}
    我们通过对 $n$ 进行归纳来证明。

    对于基本情况，我们需要证明对于任何 $X$，类型 $\iscontr(X)$ 是一个纯命题。这是 \cref{thm:isprop-iscontr}。

    对于归纳步骤，我们需要证明
    \[\prd{X : \type} \isprop (\istype{n}(X)) \to \prd{X : \type} \isprop (\istype{\nplusone}(X))。\]
    要证明这个推论的结论，我们需要证明对于任何类型 $X$，类型
    \[\prd{x, x' : X}\istype{n}(x = x')\]
    是一个纯命题。根据 \cref{thm:isprop-forall} 或 \cref{thm:hlevel-prod}，只需证明对于任何 $x, x' : X$，类型 $\istype{n}(x =_X x')$ 是一个纯命题即可。这可由归纳假设应用于类型 $(x =_X x')$ 得到。
\end{proof}

最后，我们展示 $n$-类型的类型本身是一个 $\nplusone$-类型。我们将其定义为：
\symlabel{universe-of-ntypes}
\[\ntype{n} \defeq \sm{X : \type} \istype{n}(X)。\]
如有必要，我们可以通过写成 $\ntypeU{n}$ 来指定宇宙 $\UU$。特别地，我们有 $\prop \defeq \ntype{(-1)}$ 和 $\set \defeq \ntype{0}$，如 \cref{cha:basics} 中定义的。注意，由于 $\istype{n}(X)$ 是一个纯命题，根据 \cref{thm:path-subset} 对于任何 $(X,p), (X',p'):\ntype{n}$，我们有
\begin{align*}
    \Big(\id[\ntype{n}]{(X, p)}{(X', p')}\Big) &\eqvsym (\id[\type] X X')\\
    &\eqvsym (\eqv{X}{X'})。
\end{align*}

\begin{thm}\label{thm:hleveln-of-hlevelSn}
对于任何 $n \geq -2$，类型 $\ntype{n}$ 是一个 $\nplusone$-类型。
\end{thm}
\begin{proof}%[Proof of \cref{thm:hleveln-of-hlevelSn}]
    令 $(X, p), (X', p') : \ntype{n}$；我们需要证明 $\id{(X, p)}{(X', p')}$ 是一个 $n$-类型。根据上述观察，这个类型等价于 $\eqv{X}{X'}$。接下来，我们观察到投影
    \[(\eqv{X}{X'}) \to (X \rightarrow X').\]
    是一个嵌入，因此如果 $n\geq -1$，根据 \cref{thm:isntype-mono}，只需证明 $X \rightarrow X'$ 是一个 $n$-类型即可。但是，由于 $n$-类型在箭头类型下是封闭的，这归结为假设 $X'$ 是一个 $n$-类型。

    在 $n=-2$ 的情况下，这个论证表明 $\eqv{X}{X'}$ 是一个 $(-1)$-类型——但它也是居留的，因为任何两个可收缩类型都等价于 \unit，因此彼此等价。因此，$\eqv{X}{X'}$ 也是一个 $(-2)$-类型。
\end{proof}

\section{同一性证明的唯一性与 Hedberg 定理 (Uniqueness of identity proofs and Hedberg's theorem)}
\label{sec:hedberg}

\index{set|(}%

在 \cref{sec:basics-sets} 中，我们定义了一个类型 $X$ 是\emph{集合 (Set)}，如果对于所有 $x, y : X$ 和 $p, q : x =_X y$ 我们有 $p = q$。在传统类型论中，这个属性称为\define{同一性证明的唯一性 (Uniqueness of Identity Proofs, UIP)}。
\indexdef{uniqueness!of identity proofs}%
我们还看到它等价于上一节中 $0$-类型的定义。这里是另一个等价的刻画，涉及到 Streicher 的``公理 K (Axiom K)'' \cite{Streicher93}：

\begin{thm}\label{thm:h-set-uip-K}
一个类型 $X$ 是集合 (Set)，当且仅当它满足\define{公理 K (Axiom K)}：对于所有 $x : X$ 和 $p : (x =_A x)$ 我们有 $p = \refl{x}$。
\indexdef{axiom!Streicher's Axiom K}%
\end{thm}

\begin{proof}
    显然，公理 K 是 UIP 的特例。反之，如果 $X$ 满足公理 K，则令 $x, y : X$ 和 $p, q : (\id{x}{y})$；我们想要证明 $p=q$。但是对 $q$ 进行归纳 (Induction) 将这个目标精简为公理 K。
\end{proof}

我们强调，\emph{我们}并不假设 UIP 或 K 原理作为公理！它们只是某一特定类型可能或可能不满足的属性（它们等价于集合）。回忆 \cref{thm:type-is-not-a-set}，并非所有类型都是集合。

下面的定理是另一个证明类型为集合的有用方法。

\begin{thm}\label{thm:h-set-refrel-in-paths-sets}
\index{relation!reflexive}%
假设 $R$ 是一个在类型 $X$ 上的反身纯关系 (Reflexive Mere Relation)，它暗含了同一性 (Identity)。那么 $X$ 是集合，并且对于所有 $x,y:X$，$R(x,y)$ 等价于 $\id[X]{x}{y}$。
\end{thm}

\begin{proof}
    令 $\rho : \prd{x:X} R(x,x)$ 证明 $R$ 的反身性，并令 \narrowequation{f : \prd{x,y:X} R(x,y) \to (\id[X]{x}{y})} 证明 $R$ 暗含同一性。首先，定理中的两个陈述是等价的。一方面，如果 $X$ 是一个集合，那么 $\id[X]xy$ 是一个纯命题，并且由于它在逻辑上等价于纯命题 $R(x,y)$，根据假设，它也必须等价于它。另一方面，如果 $\id[X]xy$ 等价于 $R(x,y)$，那么与后者一样，对于所有 $x,y:X$，它是一个纯命题，因此 $X$ 是一个集合。

    我们给出两种证明这个定理的方法。第一种直接证明 $X$ 是一个集合；第二种直接证明 $R(x,y)\eqvsym (x=y)$。

    \emph{第一种证明：} 我们证明 $X$ 是一个集合。这个思路与 \cref{thm:prop-set} 相同：函数 $f$ 必须在其参数 $x$ 和 $y$ 中是连续的。然而，由于我们必须处理额外的 $R(x,y)$ 类型的参数，符号表达上稍微复杂一些。

    首先，对于任何 $x:X$ 和 $p:\id[X]xx$，考虑 $\apdfunc{f(x)}(p)$。这是一个从 $f(x,x)$ 到它自身的依赖路径 (Dependent Path)。由于 $f(x,x)$ 仍然是一个函数 $R(x,x) \to (\id[X]xx)$，根据 \cref{thm:dpath-arrow}，这给出了对于任何 $r:R(x,x)$ 的路径
    \[\trans{p}{f(x,x,r)} = f(x,x,\trans{p}r)。\]
    在左侧，我们有同一类型中的传输 (Transport)，即连接。在右侧，我们有 $\trans{p}r = r$，因为它们都属于纯命题 $R(x,x)$。因此，替代 $r\defeq \rho(x)$，我们得到
    \[ f(x,x,\rho(x)) \ct p = f(x,x,\rho(x))。\]
    通过消去得到 $p=\refl{x}$。所以 $X$ 满足公理 K，因此是一个集合。

    \emph{第二种证明：} 我们证明每个 $f(x,y) : R(x,y) \to \id[X]{x}{y}$ 是一个等价 (Equivalence)。根据 \cref{thm:total-fiber-equiv}，我们只需证明 $f$ 在总空间 (Total Space) 上诱导了一个等价：
    \begin{equation*}
        \eqv{\Parens{\sm{y:X}R(x,y)}}{\Parens{\sm{y:X}\id[X]{x}{y}}}。
    \end{equation*}
    根据 \cref{thm:contr-paths}，右侧的类型是可收缩的，因此只需证明左侧的类型是可收缩的。我们选择对 $(x,\rho(x))$ 的对作为收缩中心。剩下的就是对每个 ${y:X}$ 和每个 ${H:R(x,y)}$ 证明
    \begin{equation*}
        \id{\pairr{x,\rho(x)}}{\pairr{y,H}}。
    \end{equation*}
    但由于 $R(x,y)$ 是一个纯命题，根据 \cref{thm:path-sigma}，我们只需证明 $\id[X]{x}{y}$，这是从 $f(H)$ 得到的。
\end{proof}

\begin{cor}\label{notnotstable-equality-to-set}
如果一个类型 $X$ 具有属性 $\neg\neg(x=y)\to(x=y)$ 对于任何 $x,y:X$，那么 $X$ 是一个集合。
\end{cor}

另一种方便的方法来证明一个类型是集合如下。回忆 \cref{sec:intuitionism}，一个类型 $X$ 被认为具有\emph{可判定等同性 (Decidable Equality)}，如果对于所有 $x, y : X$ 我们有
\[(x =_X y) + \neg (x =_X y)。\]
\index{continuity of functions in type theory@``continuity'' of functions in type theory}%
\index{functoriality of functions in type theory@``functoriality'' of functions in type theory}%
这是一种非常强的条件：它意味着当路径存在时，$x=y$ 可以在 $x$ 和 $y$ 中连续（或可计算，或函子化）地选择出来。通过 \cref{thm:h-set-refrel-in-paths-sets} 和下面的引理，这最终会导致 $X$ 是一个集合。

\begin{lem}\label{lem:hedberg-helper}
对于任何类型 $A$，我们有 $(A+\neg A)\to(\neg\neg A\to A)$。
\end{lem}

\begin{proof}
    这在本质上已经在 \cref{thm:not-lem} 中证明过了，但我们重复这个论证。假设 $x:A+\neg A$。我们有两个情况需要考虑。如果 $x$ 是某个 $a:A$ 的 $\inl(a)$，那么我们有一个常函数 $\neg\neg A \to A$，它将所有内容映射到 $a$。如果 $x$ 是某个 $t:\neg A$ 的 $\inr(t)$，我们有 $g(t):\emptyt$ 对于每个 $g:\neg\neg A$。因此，我们可以使用\emph{从错误中推出任何结论}，即 $\rec{\emptyt}$，对任意 $g:\neg\neg A$ 得到一个 $A$ 的元素。
\end{proof}

\index{anger}
\begin{thm}[Hedberg]\label{thm:hedberg}
\index{Hedberg's theorem}%
\index{theorem!Hedberg's}%
如果 $X$ 具有可判定等同性 (Decidable Equality)，那么 $X$ 是一个集合。
\end{thm}

\begin{proof}
    如果 $X$ 具有可判定等同性，则对于任何 $x,y:X$，$\neg\neg(x=y)\to(x=y)$ 成立。因此，Hedberg 定理从 \cref{notnotstable-equality-to-set} 推出。
\end{proof}

当然，这个定理与 \cref{thm:not-lem} 有很强的联系。被 \cref{thm:not-lem} 否定的 \LEM{\infty} 陈述显然意味着每个类型都有可判定等同性，因此是一个集合，这我们知道并非如此。
\index{excluded middle}%
请注意，一致的公理 \LEM{} 从 \cref{sec:intuitionism} 推出仅意味着每个类型具有\emph{仅仅是可判定等同性 (Merely Decidable Equality)}，即对于任何 $A$ 我们有
\indexdef{equality!merely decidable}%
\indexdef{merely!decidable equality}%
\[ \prd{a,b:A} (\brck{a=b} + \neg\brck{a=b})。\]

\index{decidable!equality|)}%

作为 \cref{thm:hedberg} 的一个应用实例，回忆在 \cref{thm:nat-set} 中我们观察到 $\nat$ 是一个集合，通过 \cref{sec:compute-nat} 中我们对其等同性类型的刻画。
更传统的证明这个定理的方法仅使用~\eqref{eq:zero-not-succ} 和~\eqref{eq:suc-injective}，而不是 \cref{thm:path-nat} 的完整刻画，使用 \cref{thm:hedberg} 来填补空白。

\begin{thm}\label{prop:nat-is-set}
自然数类型 $\nat$ 具有可判定等同性，因此是一个集合。
\end{thm}

\begin{proof}
    令 $x, y : \nat$ 被给定；我们通过对 $x$ 进行归纳和对 $y$ 进行情况分析来证明 $(x=y)+\neg(x=y)$。如果 $x \jdeq 0$ 且 $y \jdeq 0$，我们取 $\inl(\refl0)$。如果 $x \jdeq 0$ 且 $y \jdeq \suc(n)$，则根据~\eqref{eq:zero-not-succ} 我们得到 $\neg (0 = \suc (n))$。

    对于归纳步骤，令 $x \jdeq \suc (n)$。如果 $y \jdeq 0$，我们再次使用~\eqref{eq:zero-not-succ}。最后，如果 $y \jdeq \suc (m)$，归纳假设给出 $(m = n)+\neg(m = n)$。在第一种情况下，如果 $p:m=n$，那么 $\ap \suc p:\suc(m)=\suc(n)$。在第二种情况下，~\eqref{eq:suc-injective} 导致 $\neg(\suc(m)=\suc(n))$。
\end{proof}

\index{set|)}%

\index{axiom!Streicher's Axiom K!generalization to n-types@generalization to $n$-types}%
尽管 Hedberg 定理看起来对集合（$0$-类型）特别适用，``公理 K (Axiom K)'' 自然地推广到 $n$-类型。请注意，普通的公理 K（作为类型 $X$ 的属性）陈述为对于所有 $x:X$，环空间 (Loop Space) $\Omega(X,x)$（见 \cref{def:loopspace}）是可收缩的 (Contractible)。由于 $\Omega(X,x)$ 总是居留的（通过 $\refl{x}$），这等价于它是一个纯命题（一个 $(-1)$-类型）。由于 $0 = (-1)+1$，这提出了以下推广。

\begin{thm}\label{thm:hlevel-loops}
对于任何 $n\geq -1$，类型 $X$ 是一个 $\nplusone$-类型，当且仅当对于所有 $x : X$，类型 $\Omega(X, x)$ 是一个 $n$-类型。
\end{thm}

在证明此之前，我们先证明一个辅助引理：

\begin{lem}\label{lem:hlevel-if-inhab-hlevel}
给定 $n \geq -1$ 和 $X : \type$。如果给定 $X$ 的任何居留元素就能推出 $X$ 是一个 $n$-类型，那么 $X$ 是一个 $n$-类型。
\end{lem}
\begin{proof}
    令 $f : X \to \istype{n}(X)$ 是给定的映射。我们需要证明对于任何 $x, x' : X$，类型 $\id{x}{x'}$ 是一个 $\nminusone$-类型。但是 $f(x)$ 表明 $X$ 是一个 $n$-类型，因此它的所有路径空间 (Path Spaces) 都是 $\nminusone$-类型。
\end{proof}

\begin{proof}[Proof of \cref{thm:hlevel-loops}]
    ``如果''的方向是显然的，因为 $\Omega(X,x)\defeq (\id[X]xx)$。反之，为了证明 $X$ 是一个 $\nplusone$-类型，我们需要证明对于任何 $x, x' : X$，类型 $\id{x}{x'}$ 是一个 $n$-类型。根据 \cref{lem:hlevel-if-inhab-hlevel}，只需给出一个映射
    \[ (\id{x}{x'}) \to \istype{n}(\id{x}{x'})。\]
    通过路径归纳 (Path Induction)，只需证明当 $x\jdeq x'$ 时，这来自于假设 $\Omega(X, x)$ 是一个 $n$-类型。
\end{proof}

\index{whiskering}
通过归纳和一些巧妙的刷操作 (Whiskering)，我们可以将 K 属性推广到 $n>0$。

\begin{thm}\label{thm:ntype-nloop}
\index{loop space!iterated}%
对于每个 $n\ge -1$，一个类型 $A$ 是一个 $n$-类型，当且仅当对于所有 $a:A$，$\Omega^{n+1}(A,a)$ 是可收缩的。
\end{thm}
\begin{proof}
    回忆 $\Omega^0(A,a) = (A,a)$，$n=-1$ 的情况是 \cref{ex:prop-inhabcontr}。$n=0$ 的情况是 \cref{thm:h-set-uip-K}。现在我们使用归纳法；假设该陈述对 $n:\N$ 成立。根据 \cref{thm:hlevel-loops}，$A$ 是一个 $(n+1)$-类型，当且仅当对于所有 $a:A$，$\Omega(A,a)$ 是一个 $n$-类型。根据归纳假设，后者等价于 $\Omega^{n+1}(\Omega(A,a),p)$ 对于所有 $p:\Omega(A,a)$ 是可收缩的。

    由于 $\Omega^{n+2}(A,a) \defeq \Omega^{n+1}(\Omega(A,a),\refl{a})$，并且 $\Omega^{n+1} = \Omega^n \circ \Omega$，它将足以证明 $\Omega(\Omega(A,a),p)$ 等于 $\Omega(\Omega(A,a),\refl{a})$，在类型 $\pointed\type$ 中。为此，只需给出一个等价
    \[ g : \Omega(\Omega(A,a),p) \eqvsym \Omega(\Omega(A,a),\refl{a}) \]
    它将基点 (Basepoint) $\refl{p}$ 映射到基点 $\refl{\refl{a}}$。对于 $q:p=p$，定义 $g(q):\refl{a} = \refl{a}$ 为以下复合：
    \[ \refl{a} = p\ct \opp p \overset{q}{=} p\ct\opp p = \refl{a}，\]
    其中标有 ``$q$'' 的路径实际上是 $\apfunc{\lam{r} r\ct\opp p} (q)$。然后 $g$ 是一个等价，因为它是等价的复合
    \[ (p=p) \xrightarrow{\apfunc{\lam{r} r\ct\opp p}} (p\ct \opp p = p\ct \opp p) \xrightarrow{i\ct - \ct \opp i} (\refl{a} = \refl{a})。\]
    使用 \cref{eg:concatequiv,thm:paths-respects-equiv}，其中 $i:\refl{a} = p\ct \opp p$ 是规范等价。显然，$g(\refl{p}) = \refl{\refl{a}}$。
\end{proof}

\section{截断 (Truncations)}
\label{sec:truncations}

\indexsee{n-truncation@$n$-truncation}{truncation}%
\index{truncation!n-truncation@$n$-truncation|(defstyle}%

在 \cref{subsec:prop-trunc} 中，我们介绍了命题截断 (Propositional Truncation)，它提供了某个类型作为一个纯命题（即 $(-1)$-类型）的``最佳近似''。在 \cref{sec:hittruncations} 中，我们将此截断构造为一个高阶归纳类型 (Higher Inductive Type)，并给出了将其推广为 0-截断的一种方法。现在，我们将解释一种更好的推广方式，它将任意类型截断为任意 $n\geq -2$ 的 $n$-类型；在经典同伦理论中，这被称为其 \define{$n^{\mathrm{th}}$ Postnikov 截断 (Postnikov section)}。\index{Postnikov tower}

其思想是利用 \cref{thm:ntype-nloop}，该定理表明 $A$ 是一个 $n$-类型，当且仅当 $\Omega^{n+1}(A,a)$ \index{loop space!iterated}%
对于所有 $a:A$ 是可收缩的，并且利用 \cref{lem:susp-loop-adj}，该引理暗示 \narrowequation{\Omega^{n+1}(A,a) \eqvsym \Map_{*}(\Sn^{n+1},(A,a))}，其中 $\Sn^{n+1}$ 配备了一些基点 (Basepoint)，我们不妨称其为 \base。然而，通过给出路径构造子，可以直接确保 $\Map_*(\Sn^{n+1},(A,a))$ 的可收缩性。

\index{hub and spoke}%
我们将使用 ``轮毂和辐条'' 构造 (Hub and Spoke Construction)，如 \cref{sec:hubs-spokes} 所述。因此，对于 $n\ge -1$，我们将 $\trunc nA$ 视为由以下构造生成的高阶归纳类型：
\begin{itemize}
    \item 一个函数 $\tprojf n : A \to \trunc n A$，
    \item 对于每个 $r:\Sn^{n+1} \to \trunc n A$，一个\emph{轮毂 (Hub)} 点 $h(r):\trunc n A$，以及
    \item 对于每个 $r:\Sn^{n+1} \to \trunc n A$ 和每个 $x:\Sn^{n+1}$，一个\emph{辐条 (Spoke)} 路径 $s_r(x):r(x) = h(r)$。
\end{itemize}

\noindent 这些构造子的存在足以证明：

\begin{lem}
    $\trunc n A$ 是一个 $n$-类型。
\end{lem}
\begin{proof}
    根据 \cref{thm:ntype-nloop}，只需证明 $\Omega ^{n+1}(\trunc nA,b)$ 对于所有 $b:\trunc nA$ 是可收缩的，根据 \cref{lem:susp-loop-adj} 这等价于 \narrowequation{\Map_*(\Sn^{n+1},(\trunc nA,b))}。作为后者的收缩中心，我们选择常数为 $b$ 的函数 $c_b:\Sn^{n+1} \to \trunc nA$，以及 $\refl b : c_b(\base) = b$。

    现在，$\Map_*(\Sn^{n+1},(\trunc nA,b))$ 的任意元素由一个映射 $r:\Sn^{n+1} \to \trunc n A$ 以及一个路径 $p:r(\base)=b$ 组成。根据函数外延性 (Function Extensionality)，为了证明 $r = c_b$，只需给出每个 $x:\Sn^{n+1}$ 的路径 $r(x)=c_b(x) \jdeq b$。我们选择它为复合路径 $s_r(x) \ct \opp{s_r(\base)} \ct p$，其中 $s_r(x)$ 是 $x$ 处的辐条路径。

    最后，我们必须证明当沿着这个等式 $r=c_b$ 进行传递时，路径 $p$ 变为 $\refl b$。通过路径类型中的传递，这意味着我们需要
    \[\opp{(s_r(\base) \ct \opp{s_r(\base)} \ct p)} \ct p = \refl b。\]
    但这是通过路径运算立即得出的。
\end{proof}

（这种构造对 $n=-2$ 失效，但在这种情况下我们可以简单地定义 $\trunc{-2}{A}\defeq \unit$ 对于所有 $A$。从现在起我们假设 $n\ge -1$。）

\index{induction principle!for truncation}%
为了展示 $n$-截断的预期通用性质 (Universal Property)，我们需要归纳原理 (Induction Principle)。我们按照通常的方式从构造子中提取它；它表明，给定 $P:\trunc nA\to\type$ 以及以下内容：
\begin{itemize}
    \item 对于每个 $a:A$，一个元素 $g(a) : P(\tproj na)$，
    \item 对于每个 $r:\Sn^{n+1} \to \trunc n A$ 和 $r':\prd{x:\Sn^{n+1}} P(r(x))$，一个元素 $h'(r,r'):P(h(r))$，
    \item 对于每个 $r:\Sn^{n+1} \to \trunc n A$ 和 $r':\prd{x:\Sn^{n+1}} P(r(x))$，以及每个 $x:\Sn^{n+1}$，一个依赖路径 $\dpath{P}{s_r(x)}{r'(x)}{h'(r,r')}$，
\end{itemize}
存在一个截面 $f:\prd{x:\trunc n A} P(x)$，其中 $f(\tproj n a) \jdeq g(a)$ 对于所有 $a:A$ 成立。为了使其更有用，我们将其重新表述如下。

\begin{thm}\label{thm:truncn-ind}
对于任意类型族 $P:\trunc n A \to \type$，使得每个 $P(x)$ 是一个 $n$-类型，并且任意函数 $g : \prd{a:A} P(\tproj n a)$，存在一个截面 $f:\prd{x:\trunc n A} P(x)$，使得 $f(\tproj n a)\defeq g(a)$ 对于所有 $a:A$ 成立。
\end{thm}
\begin{proof}
    只需构造上述列出的第二个和第三个数据，因为 $g$ 的类型与第一个数据完全一致。给定 $r:\Sn^{n+1} \to \trunc n A$ 和 $r':\prd{x:\Sn^{n+1}} P(r(x))$，我们有 $h(r):\trunc n A$ 和 $s_r :\prd{x:\Sn^{n+1}} (r(x) = h(r))$。定义 $t:\Sn^{n+1} \to P(h(r))$ 为 $t(x) \defeq \trans{s_r(x)}{r'(x)}$。然后由于 $P(h(r))$ 是 $n$-截断的，因此存在一个点 $u:P(h(r))$ 和一个收缩 $v:\prd{x:\Sn^{n+1}} (t(x) = u)$。定义 $h'(r,r') \defeq u$，提供了第二个数据。然后（回忆依赖路径的定义），$v$ 正好具有第三个数据所需的类型。
\end{proof}

特别地，如果 $E$ 是某个 $n$-类型，我们可以考虑在 $A$ 的每个点上等于 $E$ 的常数类型族 (Constant Family of Types)。\symlabel{extend} \index{recursion principle!for truncation}%
因此，每个映射 $f:A\to{}E$ 都可以扩展为映射 $\extend{f}:\trunc nA\to{}E$，定义为 $\extend{f}(\tproj na)\defeq f(a)$；这是 $\trunc n A$ 的\emph{递归原理 (Recursion Principle)}。

归纳原理还暗示了这种形式的函数的唯一性原理。\index{uniqueness!principle, propositional!for functions on a truncation}%
也就是说，如果 $E$ 是一个 $n$-类型，并且 $g,g':\trunc nA\to{}E$ 满足 $g(\tproj na)=g'(\tproj na)$ 对于每个 $a:A$，那么 $g(x)=g'(x)$ 对于所有 $x:\trunc nA$ 成立，因为类型 $g(x)=g'(x)$ 是一个 $n$-类型。因此，$g=g'$。（实际上，当 $E$ 是一个 $(n+1)$-类型时，这个唯一性原理在更广泛的情况下也是成立的。）这产生了以下通用性质。

\begin{lem}[截断的通用性质 (Universal Property of Truncations)]\label{thm:trunc-reflective}
\index{universal!property!of truncation}%
设 $n\ge-2$，$A:\type$ 和 $B:\typele{n}$。以下映射是一个等价：
\[\function{(\trunc nA\to{}B)}{(A\to{}B)}{g}{g\circ\tprojf n}\]
\end{lem}

\begin{proof}
    考虑到 $B$ 是 $n$-截断的，任意 $f:A\to{}B$ 可以扩展为映射 $\extend{f}:\trunc nA\to{}B$。映射 $\extend{f}\circ\tprojf n$ 等于 $f$，因为对于每个 $a:A$，我们有 $\extend{f}(\tproj na)=f(a)$ 根据定义。而映射 $\extend{g\circ\tprojf n}$ 等于 $g$，因为它们都将 $\tproj na$ 映射到 $g(\tproj na)$。
\end{proof}

在范畴语言中，这意味着 $n$-类型形成了类型范畴 (Category of Types) 的一个\emph{反射子范畴 (Reflective Subcategory)}。\index{reflective!subcategory}%
（为了完全精确地陈述这一点，应使用 $(\infty,1)$-范畴的语言。）
\index{.infinity1-category@$(\infty,1)$-category}%
特别地，这意味着 $n$-截断是函子性的：给定 $f:A\to B$，将递归原理应用于复合 $A\xrightarrow{f} B \to \trunc n B$ 产生映射 $\trunc n f: \trunc n A \to \trunc n B$。根据定义，我们有一个同伦
\begin{equation}
    \mathsf{nat}^f_n : \prd{a:A} \trunc n f(\tproj n a) = \tproj n {f(a)},\label{eq:trunc-nat}
\end{equation}
表达了映射 $\tprojf n$ 的\emph{自然性 (Naturality)}。

唯一性暗示了函子性定律 (Functoriality Laws)，例如 $\trunc n {g\circ f} = \trunc n g \circ \trunc n f$ 和 $\trunc n{\idfunc[A]} = \idfunc[\trunc n A]$，以及随附的相干性定律 (Coherence Laws)。我们还有更高的函子性，例如：

\begin{lem}\label{thm:trunc-htpy}
给定 $f,g:A\to B$ 和一个同伦 $h:f\htpy g$，存在一个诱导的同伦 $\trunc n h : \trunc n f \htpy \trunc n g$，使得复合
\begin{equation}
    \xymatrix@C=3.6pc{\tproj n{f(a)} \ar@{=}[r]^-{\opp{\mathsf{nat}^f_n(a)}} &
    \trunc n f(\tproj n a) \ar@{=}[r]^-{\trunc n h(\tproj na)} &
    \trunc n g(\tproj n a) \ar@{=}[r]^-{\mathsf{nat}^g_n(a)} &
    \tproj n{g(a)}}\label{eq:trunc-htpy}
\end{equation}
等于 $\apfunc{\tprojf n}(h(a))$。
\end{lem}
\begin{proof}
    首先，我们确实有一个同伦，其分量为 $\apfunc{\tprojf n}(h(a)) : \tproj n{f(a)} = \tproj n{g(a)}$。在两侧复合由 $\trunc n f$ 和 $\trunc ng$ 的定义产生的路径 $\tproj n{f(a)} = \trunc n f(\tproj n a)$ 和 $\tproj n{g(a)} = \trunc n g(\tproj n a)$，我们获得了一个同伦 $(\trunc n f \circ \tprojf n) \htpy (\trunc n g \circ \tprojf n)$，因此根据函数外延性有一个等式。但是由于 $(\blank\circ \tprojf n)$ 是一个等价，必须有一个路径 $\trunc nf = \trunc ng$ 来诱导它，并且函数外延性的相干性定律暗示了~\eqref{eq:trunc-htpy}。
\end{proof}

关于反射子范畴的以下观察也是标准的。

\begin{cor}
    一个类型 $A$ 是一个 $n$-类型，当且仅当 $\tprojf n : A \to \trunc n A$ 是一个等价。
\end{cor}
\begin{proof}
    ``如果'' 这一点是由等价下的 $n$-类型的封闭性 (Closure of $n$-types under equivalence) 得出的。另一方面，如果 $A$ 是一个 $n$-类型，我们可以定义 $\ext(\idfunc[A]):\trunc n A\to{}A$。然后我们有 $\ext(\idfunc[A])\circ\tprojf n=\idfunc[A]:A\to{}A$ 根据定义。为了证明 $\tprojf n\circ\ext(\idfunc[A])=\idfunc[\trunc nA]$，我们只需要证明 $\tprojf n\circ\ext(\idfunc[A])\circ\tprojf n= \idfunc[\trunc nA]\circ\tprojf n$。这再次成立：
    \[\raisebox{\depth-\height+1em}{\xymatrix{
        A \ar^-{\tprojf n}[r] \ar_{\idfunc[A]}[rd] &
        \trunc nA \ar^>>>{\ext(\idfunc[A])}[d] \ar@/^40pt/^{\idfunc[\trunc nA]}[dd] \\
        & A \ar_{\tprojf n}[d] \\
        & \trunc nA}}
    \qedhere\]
\end{proof}

$n$-类型范畴 (Category of $n$-types) 还具有一些其他反射子范畴所不具备的特殊属性。例如，反射器 (Reflector) $\trunc n-$ 保持有限积 (Finite Products)。

\begin{thm}\label{cor:trunc-prod}
对于任意类型 $A$ 和 $B$，诱导映射 $\trunc n{A\times B} \to \trunc nA \times \trunc nB$ 是一个等价。
\end{thm}
\begin{proof}
    只需证明 $\trunc nA \times \trunc nB$ 具有与 $\trunc n{A\times B}$ 相同的通用性质即可。因此，设 $C$ 是一个 $n$-类型；我们有
    \begin{align*}
    (\trunc nA \times \trunc nB \to C)
        &= (\trunc nA \to (\trunc nB \to C))\\
        &= (\trunc nA \to (B \to C))\\
        &= (A \to (B \to C))\\
        &= (A \times B \to C)
    \end{align*}
    使用 $\trunc nB$ 和 $\trunc nA$ 的通用性质，以及 $B\to C$ 是一个 $n$-类型，因为 $C$ 是。可以很容易地验证，此等价通过与 $\tprojf n \times \tprojf n$ 的复合给出，这是所需要的。
\end{proof}

以下关于依赖和 (Dependent Sum) 的相关事实通常也很有用。

\begin{thm}\label{thm:trunc-in-truncated-sigma}
令 $P:A\to\type$ 为一个类型族。则存在等价
\begin{equation*}
    \eqv{\Trunc n{\sm{x:A}\trunc n{P(x)}}}{\Trunc n{\sm{x:A}P(x)}}。
\end{equation*}
\end{thm}

\begin{proof}
    我们多次使用 $n$-截断的归纳原理来构造函数
    \begin{align*}
        \varphi & : \Trunc n{\sm{x:A}\trunc n{P(x)}}\to\Trunc n{\sm{x:A}P(x)}\\
        \psi & : \Trunc n{\sm{x:A}P(x)}\to \Trunc n{\sm{x:A} \trunc n{P(x)}}
    \end{align*}
    以及将它们作为准逆 (Quasi-inverses) 展示的同伦 $H:\varphi\circ\psi\htpy \idfunc$ 和 $K:\psi\circ\varphi\htpy \idfunc$。我们通过设定 $\varphi(\tproj n{\pairr{x,\tproj nu}})\defeq\tproj n{\pairr{x,u}}$ 来定义 $\varphi$。我们通过设定 $\psi(\tproj n{\pairr{x,u}})\defeq\tproj n{\pairr{x,\tproj nu}}$ 来定义 $\psi$。然后我们定义 $H(\tproj n{\pairr{x,u}})\defeq \refl{\tproj n{\pairr{x,u}}}$ 和 $K(\tproj n{\pairr{x,\tproj nu}})\defeq \refl{\tproj n{\pairr{x,\tproj nu}}}$。
\end{proof}

\begin{cor}\label{thm:refl-over-ntype-base}
如果 $A$ 是一个 $n$-类型且 $P:A\to\type$ 是任意类型族，那么
\[ \eqv{\sm{a:A} \trunc n{P(a)}}{\Trunc n{\sm{a:A}P(a)}} \]
\end{cor}
\begin{proof}
    如果 $A$ 是一个 $n$-类型，则上面的左侧类型已经是一个 $n$-类型，因此等价于其 $n$-截断；因此这是由 \cref{thm:trunc-in-truncated-sigma} 推导出的。
\end{proof}

我们可以使用与 \cref{sec:compute-coprod,sec:compute-nat} 中计算余积 (Coproduct) 和自然数时使用的相同方法（我们将在 \cref{cha:homotopy} 中用来计算同伦群）来描述截断的路径空间 (Path Spaces)。不出所料，$A$ 的 $(n+1)$-截断的路径空间是 $A$ 的路径空间的 $n$-截断。实际上，对于任意 $x,y:A$，存在一个标准映射
\begin{equation}
    f:\ttrunc n{x=_Ay}\to \Big(\tproj {n+1}x=_{\trunc{n+1}A}\tproj {n+1}y\Big)\label{eq:path-trunc-map}
\end{equation}
定义为
\[f(\tproj n{p})\defeq \apfunc{\tprojf {n+1}}(p)。\]
此定义使用了 $\truncf n$ 的递归原理，这是正确的，因为 $\trunc {n+1}A$ 是 $(n+1)$-截断的，因此 $f$ 的余域是 $n$-截断的。

\begin{thm} \label{thm:path-truncation}
对于任意 $A$ 和 $x,y:A$ 以及 $n\ge -2$，映射~\eqref{eq:path-trunc-map} 是一个等价；因此我们有
\[ \eqv{\ttrunc n{x=_Ay}}{\Big(\tproj {n+1}x=_{\trunc{n+1}A}\tproj {n+1}y\Big)}。\]
\end{thm}

\begin{proof}
    证明是一个简单的编码-解码方法的应用 (Encode-decode method)：
    在以前的情形中，我们不能直接定义映射~\eqref{eq:path-trunc-map} 的准逆 (Quasi-inverse)，因为没有办法对 $\tproj {n+1}x$ 和 $\tproj {n+1}y$ 之间的等式进行归纳。
    因此，相反，我们在广义其类型后，再有广义的 $\trunc{n+1}A$ 的一般元素，而不是 $\tproj {n+1}x$ 和 $\tproj {n+1}y$。
    定义 $P:\trunc {n+1}A\to\trunc {n+1}A\to\typele{n}$ 为
    \[P(\tproj {n+1}x,\tproj {n+1}y)\defeq \trunc n{x=_Ay}\]
    此定义是正确的，因为 $\trunc n{x=_Ay}$ 是 $n$-截断的，而 \typele{n} 是 $(n+1)$-截断的根据 \cref{thm:hleveln-of-hlevelSn}。
    现在对于每个 $u,v:\trunc{n+1}A$，存在一个映射
    \[\decode:P(u,v) \to \big(u=_{\trunc{n+1}A}v\big)\]
    对于 $u=\tproj {n+1}x$ 和 $v=\tproj {n+1}y$ 和 $p:x=y$ 定义为
    \[\decode(\tproj n{p})\defeq \apfunc{\tprojf{n+1}} (p)。\]
    由于 $\decode$ 的余域是 $n$-截断的，只需对 $u$ 和 $v$ 进行此形式的定义，然后它就是与以前相同的定义。我们还定义了一个函数
    \[ r : \prd{u:\trunc{n+1} A} P(u,u) \]
    通过对 $u$ 的归纳，其中 $r(\tproj{n+1} x) \defeq \tproj n {\refl x}$。

    现在我们可以定义逆映射 (Inverse map)
    \[\encode: (u=_{\trunc{n+1}A}v) \to P(u,v)\]
    通过
    \[\encode(p) \defeq \transfib{v\mapsto P(u,v)}{p}{r(u)}。\]
    要证明复合映射
    \[ (u=_{\trunc{n+1}A}v) \xrightarrow{\encode} P(u,v) \xrightarrow{\decode} (u=_{\trunc{n+1}A}v) \]
    是恒等函数 (Identity function)，通过路径归纳法，只需检查它对于 $\refl u : u=u$ 的情况，在这种情况下，我们需要知道的是 $\decode(r(u)) = \refl{u}$。
    但是由于这是一个 $(n-1)$-类型，因此也是一个 $(n+1)$-类型，我们可以假设 $u\jdeq \tproj {n+1} x$，在这种情况下，按照 $r$ 和 $\decode$ 的定义，它得以成立。
    最后，要证明
    \[ P(u,v) \xrightarrow{\decode} (u=_{\trunc{n+1}A}v) \xrightarrow{\encode} P(u,v) \]
    是恒等函数，由于该目标再次是一个 $(n-1)$-类型，我们可以假设 $u=\tproj {n+1}x$ 和 $v=\tproj {n+1}y$ 并且我们正在考虑某些 $p:x=y$ 的 $P(\tproj{n+1}x,\tproj{n+1}y)$。
    然后我们有
    \begin{align*}
        \encode(\decode(\tproj n p)) &= \encode(\apfunc{\tprojf{n+1}}(p))\\
        &= \transfib{v\mapsto P(\tproj{n+1}x,v)}{\apfunc{\tprojf{n+1}}(p)}{\tproj n {\refl x}}\\
        &= \transfib{y\mapsto \trunc n{x=y}}{p}{\tproj n {\refl x}}\\
        &= \tproj n {\transfib{y \mapsto (x=y)}{p}{\refl x}}\\
        &= \tproj n p,
    \end{align*}
    使用 \cref{thm:transport-compose,thm:ap-transport}。
    （或者，我们可以在 $p$ 上进行路径归纳；在这种情况下，所需的等式将是判断上的 (Judgmentally)。）
    这就完成了 \decode 和 \encode 是准逆的证明。给出的结果是 $u=\tproj {n+1}x$ 和 $v=\tproj {n+1}y$ 的特例。
\end{proof}

\begin{cor}
    令 $n\ge-2$ 并且 $(A,a)$ 是一个基点类型 (Pointed Type)。那么
    \[\ttrunc n{\Omega(A,a)}=\Omega\mathopen{}\left(\trunc{n+1}{(A,a)}\right)\]
\end{cor}
\begin{proof}
    这是前述引理的一个特例，其中 $x=y=a$。
\end{proof}

\begin{cor}
    令 $n\ge -2$ 和 $k\ge 0$ 并且 $(A,a)$ 为一个基点类型。那么
    \[\ttrunc n{\Omega^k(A,a)} = \Omega^k\mathopen{}\left(\trunc{n+k}{(A,a)}\right)。\]
\end{cor}
\begin{proof}
    通过对 $k$ 进行归纳，使用 $\Omega^k$ 的递归定义。
\end{proof}

我们还观察到``截断是累积的 (Cumulative)''：如果我们截断为 $n$-类型，然后再截断为 $k$-类型，其中 $k\le n$，那么我们可能也可以直接截断为 $k$-类型。

\begin{lem} \label{lem:truncation-le}
令 $k,n\ge-2$ 并且 $k\le{}n$ 和 $A:\type$。那么
$\trunc k{\trunc nA}=\trunc kA$。
\end{lem}
\begin{proof}
    我们定义两个映射 $f:\trunc k{\trunc nA}\to\trunc kA$ 和 $g:\trunc kA\to\trunc k{\trunc nA}$ 通过
    %
    \[
        f(\tproj k{\tproj na}) \defeq \tproj ka
        \qquad\text{和}\qquad
        g(\tproj ka) \defeq \tproj k{\tproj na}。
    \]
    %
    映射 $f$ 是良好定义的，因为 $\trunc kA$ 是 $k$-截断的，并且也是 $n$-截断的（因为 $k\le{}n$），映射 $g$ 是良好定义的，因为 $\trunc k{\trunc nA}$ 是 $k$-截断的。

    复合 $f\circ{}g:\trunc kA\to\trunc kA$ 满足 $(f\circ{}g)(\tproj ka)=\tproj ka$，因此 $f\circ{}g=\idfunc[\trunc kA]$。同样地，我们有 $(g\circ{}f)(\tproj k{\tproj na})=\tproj k{\tproj na}$，因此 $g\circ{}f=\idfunc[\trunc k{\trunc nA}]$。
\end{proof}

% \begin{lem}
%   我们有 $\trunc n{\unit}=\unit$。
% \end{lem}
% \begin{proof}
%   确实，$\unit$ 对于每个 $n$ 都是 $n$-截断的，因此 $\trunc n{\unit}=\unit$ 通过
%   \cref{reflectPequiv}。
% \end{proof}

\index{truncation!n-truncation@$n$-truncation|)}%

\section{Colimits of \texorpdfstring{$n$}{n}-types}
\label{sec:pushouts}

Recall that in \cref{sec:colimits}, we used higher inductive types to define pushouts of types, and proved their universal property.
In general, a (homotopy) colimit of $n$-types may no longer be an $n$-type (for an extreme counterexample, see \cref{ex:s2-colim-unit}).
However, if we $n$-truncate it, we obtain an $n$-type which satisfies the correct universal property with respect to other $n$-types.

In this section we prove this for pushouts, which are the most important and nontrivial case of colimits.
Recall the following definitions from \cref{sec:colimits}.

\begin{defn}
  A \define{span} % in $\P$
  \indexdef{span} %
  is a 5-tuple $\Ddiag=(A,B,C,f,g)$ with % $A,B,C:\P$ and
  $f:C\to{}A$ and $g:C\to{}B$.
  \[\Ddiag=\quad\vcenter{\xymatrix{C \ar^g[r] \ar_f[d] & B \\ A & }}\]
\end{defn}

\begin{defn}
  Given a span $\Ddiag=(A,B,C,f,g)$ and a type $D$, a %$D:\P$, a
  \define{cocone under $\Ddiag$ with base $D$} is a triple $(i, j, h)$
  \index{cocone} %
  with $i:A\to{}D$, $j:B\to{}D$ and $h : \prd{c:C}i(f(c))=j(g(c))$:
  \[\uppercurveobject{{ }}\lowercurveobject{{ }}\twocellhead{{ }}
  \xymatrix{C \ar^g[r] \ar_f[d] \drtwocell{^h} & B \ar^j[d] \\ A \ar_i[r] & D
  }\]
  We denote by $\cocone{\Ddiag}{D}$ the type of all such cocones.
\end{defn}

The type of cocones is (covariantly) functorial.
For instance, given $D,E$ % $D,E:\P$
and a map $t:D\to{}E$, there is a map
  \[\function{\cocone{\Ddiag}{D}}{\cocone{\Ddiag}{E}}{c}{\composecocone{t}c}\]
  defined by:
  \[\composecocone{t}(i,j,h)=(t\circ{}i,t\circ{}j,\mapfunc{t}\circ{}h).\]
And given $D,E,F$, %$:\P$,
functions $t:D\to{}E$, $u:E\to{}F$ and $c:\cocone{\Ddiag}{D}$, we have
\begin{align}
  \composecocone{\idfunc[D]}c &= c \label{eq:composeconeid}\\
  \composecocone{(u\circ{}t)}c&=\composecocone{u}(\composecocone{t}c). \label{eq:composeconefunc}
\end{align}

\begin{defn}
  Given a span $\Ddiag$ of $n$-types, an $n$-type $D$, and a cocone
  $c:\cocone{\Ddiag}{D}$, the pair $(D,c)$ is said to be a \define{pushout
  of $\Ddiag$ in $n$-types}
  \indexdef{pushout!in ntypes@in $n$-types}%
  if for every $n$-type $E$, the map
  \[\function{(D\to{}E)}{\cocone{\Ddiag}{E}}{t}{\composecocone{t}c}\]
  is an equivalence.
\end{defn}

\begin{comment}
We showed in \cref{thm:pushout-ump} that pushouts exist when $\P$ is \type itself, by giving a direct construction in terms of higher
inductive types.
For a general \P, pushouts may or may not exist, but if they do, then they are unique.

\begin{lem}
  If $(D,c)$ and $(D',c')$ are two pushouts of $\Ddiag$ in $\P$, then
  $(D,c)=(D',c')$.
\end{lem}
\begin{proof}
  We first prove that the two types $D$ and $D'$ are equivalent.

  Using the universal property of $D$ with $D'$, we see that the following map is an
  equivalence
  %
  \[
    \function{(D\to{}D')}{\cocone{\Ddiag}{D'}}{t}{\composecocone{t}c}
  \]
  %
  In particular, there is a function $f:D\to{}D'$ satisfying $\composecocone{f}c=c'$. In the
  same way there is a function $g:D'\to{}D$ such that $\composecocone{g}c'=c$.

  In order to prove that $g\circ{}f=\idfunc[D]$ we use the universal property of
  $D$ for $D$, which says that the following map is an equivalence:
  %
  \[
  \function{(D\to{}D)}{\cocone{\Ddiag}{D}}{t}{\composecocone{t}c}
  \]
  %
  Using the functoriality of $t\mapsto{}\composecocone{t}c$ we see that
  \begin{align*}
    \composecocone{(g\circ{}f)}c &= \composecocone{g}(\composecocone{f}c) \\
    &= \composecocone{g}c' \\
    &= c \\
    &= \composecocone{\idfunc[D]}c
  \end{align*}
  hence
  $g\circ{}f=\idfunc[D]$, because equivalences are injective. The same argument
  with $D'$ instead of $D$ shows that $f\circ{}g=\idfunc[D']$.

  Hence $D$ and $D'$ are equal, and the fact that $(D,c)=(D',c')$ follows from
  the fact that the equivalence between $D$ and $D'$ we just defined sends $c$
  to $c'$.
\end{proof}

\begin{cor}
  The type of pushouts of $\Ddiag$ in $\P$ is a mere proposition. In particular if
  pushouts merely exist then they actually exist.
\end{cor}

As in the case of pullbacks, if \P is reflective, then pushouts in \P always exist.
However, unlike the case of pullbacks, pushouts in \P are not the same as the pushouts in \type: they are obtained by applying the
reflector.
\end{comment}

In order to construct pushouts of $n$-types, we need to explain how to reflect spans and cocones.

\bgroup
\def\reflect(#1){\trunc n{#1}}

\begin{defn}
  Let
  \[\Ddiag=\quad\vcenter{\xymatrix{C \ar^g[r] \ar_f[d] & B \\ A & }}\]
  be a span. We denote by $\reflect(\Ddiag)$ the following
  span of $n$-types:
  \[\reflect(\Ddiag)\defeq\quad \vcenter{\xymatrix{\reflect(C) \ar^{\reflect(g)}[r]
      \ar_{\reflect(f)}[d] & \reflect(B) \\ \reflect(A) & }}\]
\end{defn}

\begin{defn}
  Let $D:\type$ and $c=(i,j,h):\cocone{\Ddiag}{D}$.
  We define
  \[\reflect(c)=(\reflect(i),\reflect(j),k):
  \cocone{\reflect(\Ddiag)}{\reflect(D)}\]
  where $k$ is the composite homotopy
  \[ \reflect(i) \circ \reflect(f) \htpy \reflect(i\circ f) \htpy \reflect(j\circ g) \htpy \reflect(j) \circ \reflect(g) \]
  using \cref{thm:trunc-htpy} and the functoriality of $\reflect(\blank)$.
  % \[\reflect(h):\prd{c:\reflect(C)}\reflect(i)(\reflect(f)(c))=\reflect(j)(\reflect(g)(c))\]
  % is defined in the following way:
\end{defn}

\egroup

We now observe that the maps from each type to its $n$-truncation assemble into a map of spans, in the following sense.

\begin{defn}
  Let
  \[\Ddiag=\quad\vcenter{\xymatrix{C \ar^g[r] \ar_f[d] & B \\ A & }}
  \qquad\text{and}\qquad
  \Ddiag'=\quad\vcenter{\xymatrix{C' \ar^{g'}[r] \ar_{f'}[d] & B' \\ A' & }}
  \]
  be spans.
  A \define{map of spans}
  \indexdef{map!of spans}%
  $\Ddiag \to \Ddiag'$ consists of functions $\alpha:A\to A'$, $\beta:B\to B'$, and $\gamma:C\to C'$ and homotopies $\phi: \alpha\circ f \htpy f'\circ \gamma$ and $\psi:\beta\circ g \htpy g' \circ \gamma$.
\end{defn}

Thus, for any span $\Ddiag$, we have a map of spans $\tprojf[\Ddiag] n : \Ddiag \to \trunc n\Ddiag$ consisting of $\tprojf[A]n$, $\tprojf[B]n$, $\tprojf[C]n$, and the naturality homotopies $\mathsf{nat}^f_n$ and $\mathsf{nat}^g_n$ from~\eqref{eq:trunc-nat}.

We also need to know that maps of spans behave functorially.
Namely, if $(\alpha,\beta,\gamma,\phi,\psi):\Ddiag \to \Ddiag'$ is a map of spans and $D$ any type, then we have
\[ \function{\cocone{\Ddiag'}{D}}{\cocone{\Ddiag}{D}}{(i,j,h)}{(i\circ \alpha,j\circ\beta, k)} \]
where $k: \prd{z:C} i(\alpha(f(z))) = j(\beta(g(z)))$ is the composite
\begin{equation}\label{eq:mapofspans-htpy}
\xymatrix{
  i(\alpha(f(z))) \ar@{=}[r]^{\apfunc{i}(\phi)} &
  i(f'(\gamma(z))) \ar@{=}[r]^{h(\gamma(z))} &
  j(g'(\gamma(z))) \ar@{=}[r]^{\apfunc{j}(\psi)} &
  j(\beta(g(z))). }
\end{equation}
We denote this cocone by $(i,j,h) \circ (\alpha,\beta,\gamma,\phi,\psi)$.
Moreover, this functorial action commutes with the other functoriality of cocones:

\begin{lem}\label{thm:conemap-funct}
  Given $(\alpha,\beta,\gamma,\phi,\psi):\Ddiag \to \Ddiag'$ and $t:D\to E$, the following diagram commutes:
  \begin{equation*}
    \vcenter{\xymatrix{
        \cocone{\Ddiag'}{D}\ar[r]^{t \circ {\blank}}\ar[d] &
        \cocone{\Ddiag'}{E}\ar[d]\\
        \cocone{\Ddiag}{D}\ar[r]_{t \circ {\blank}} &
        \cocone{\Ddiag}{E}
      }}
  \end{equation*}
\end{lem}
\begin{proof}
  Given $(i,j,h):\cocone{\Ddiag'}{D}$, note that both composites yield a cocone whose first two components are $t\circ i\circ \alpha$ and $t\circ j\circ\beta$.
  Thus, it remains to verify that the homotopies agree.
  For the top-right composite, the homotopy is~\eqref{eq:mapofspans-htpy} with $(i,j,h)$ replaced by $(t\circ i, t\circ j, \apfunc{t}\circ h)$:
  \begin{equation*}
    \xymatrix@+2.8em{
      {t \, i \, \alpha \, f \, z} \ar@{=}[r]^{\apfunc{t\circ i}(\phi)} &
      {t \, i \, f' \, \gamma \, z} \ar@{=}[r]^{\apfunc{t}(h(\gamma(z)))} &
      {t \, j \, g' \, \gamma \, z} \ar@{=}[r]^{\apfunc{t\circ j}(\psi)} &
      {t \, j \, \beta \, g \, z}
    }
  \end{equation*}
  (For brevity, we are omitting the parentheses around the arguments of functions.)
  On the other hand, for the left-bottom composite, the homotopy is $\apfunc{t}$ applied to~\eqref{eq:mapofspans-htpy}.
  Since $\apfunc{}$ respects path-concatenation, this is equal to
  \begin{equation*}
    \xymatrix@+2.8em{
      {t \, i \, \alpha \, f \, z} \ar@{=}[r]^{\apfunc{t}(\apfunc{i}(\phi))} &
      {t \, i \, f' \, \gamma \, z} \ar@{=}[r]^{\apfunc{t}(h(\gamma(z)))} &
      {t \, j \, g' \, \gamma \, z} \ar@{=}[r]^{\apfunc{t}(\apfunc{j}(\psi))} &
      {t \, j \, \beta \, g \, z}. }
  \end{equation*}
  But $\apfunc{t}\circ \apfunc{i} = \apfunc{t\circ i}$ and similarly for $j$, so these two homotopies are equal.
\end{proof}

Finally, note that since we defined $\trunc nc : \cocone{\trunc n \Ddiag}{\trunc n D}$ using \cref{thm:trunc-htpy}, the additional condition~\eqref{eq:trunc-htpy} implies
\begin{equation}
  \tprojf[D] n \circ c = \trunc n c \circ \tprojf[\Ddiag]n. \label{eq:conetrunc}
\end{equation}
for any $c:\cocone{\Ddiag}{D}$.
Now we can prove our desired theorem.

\begin{thm}
  \label{reflectcommutespushout}
  \index{universal!property!of pushout}%
  Let $\Ddiag$ be a span and $(D,c)$ its pushout.
  Then $(\trunc nD,\trunc n c)$ is a pushout of $\trunc n\Ddiag$ in $n$-types.
\end{thm}
\begin{proof}
  Let $E$ be an $n$-type, and consider the following diagram:
\bgroup
\def\reflect(#1){\trunc n{#1}}
  \begin{equation*}
  \vcenter{\xymatrix{
      (\trunc nD \to E)\ar[r]^-{\blank\circ \tprojf[D] n}\ar[d]_{\blank\circ \trunc nc} &
      (D\to E)\ar[d]^{\blank\circ c}\\
      \cocone{\trunc n \Ddiag}{E}\ar[r]^-{\blank\circ \tprojf[\Ddiag]n}\ar@{<-}[d]_{\ell_1} &
      \cocone{\Ddiag}{E}\ar@{<-}[d]^{\ell_2}\\
      (\reflect(A)\to{}E)\times_{(\reflect(C)\to{}E)}(\reflect(B)\to{}E)\ar[r] &
      (A\to{}E)\times_{(C\to{}E)}(B\to{}E)
      }}
  \end{equation*}
\egroup
  The upper horizontal arrow is an equivalence since $E$ is an $n$-type, while $\blank\circ c$ is an equivalence since $c$ is a pushout cocone.
  Thus, by the 2-out-of-3 property, to show that $\blank\circ \trunc nc$ is an equivalence, it will suffice to show that the upper square commutes and that the middle horizontal arrow is an equivalence.
  To see that the upper square commutes, let $t:\trunc nD \to E$; then
  \begin{align}
    \big(t \circ \trunc n c\big) \circ \tprojf[\Ddiag] n
    &= t \circ \big(\trunc n c \circ \tprojf[\Ddiag] n\big)
    \tag{by \cref{thm:conemap-funct}}\\
    &= t\circ \big(\tprojf[D]n \circ c\big)
    \tag{by~\eqref{eq:conetrunc}}\\
    &= \big(t\circ \tprojf[D]n\big) \circ c
    \tag{by~\eqref{eq:composeconefunc}}.
  \end{align}
  To show that the middle horizontal arrow is an equivalence, consider the lower square.
  The two lower vertical arrows are simply applications of $\happly$:
  \begin{align*}
    \ell_1(i,j,p) &\defeq (i,j,\happly(p))\\
    \ell_2(i,j,p) &\defeq (i,j,\happly(p))
  \end{align*}
  and hence are equivalences by function extensionality.
  The lowest horizontal arrow is defined by
  \[ (i,j,p) \mapsto \big( i\circ \tprojf[A]n,\;\; j \circ \tprojf[B] n,\;\; q\big) \]
  where $q$ is the composite
  \begin{align}
    i\circ \tprojf[A]n \circ f
    &= i\circ \trunc nf \circ \tprojf[C]n
    \tag{by $\funext(\lam{z} \apfunc{i}(\mathsf{nat}^f_n(z)))$}\\
    &= j\circ \trunc ng \circ \tprojf[C]n
    \tag{by $\apfunc{\blank\circ \tprojf[C] n}(p)$}\\
    &= j\circ \tprojf[B]n \circ g.
    \tag{by $\funext(\lam{z} \apfunc{j}(\mathsf{nat}^g_n(z)))$}
  \end{align}
  This is an equivalence, because it is induced by an equivalence of cospans.
  Thus, by 2-out-of-3, it will suffice to show that the lower square commutes.
  But the two composites around the lower square agree definitionally on the first two components, so it suffices to show that for $(i,j,p)$ in the lower left corner and $z:C$, the path
  \[ \happly(q,z) : i(\tproj n{f(z)}) = j(\tproj n{g(z)}) \]
  (with $q$ as above)
  is equal to the composite
  \begin{align}
    i(\tproj n{f(z)})
    &= i(\trunc nf(\tproj nz))
    \tag{by $\apfunc{i}(\mathsf{nat}^f_n(z))$}\\
    &= j(\trunc ng(\tproj nz))
    \tag{by $\happly(p,\tproj nz)$}\\
    &= j(\tproj n{g(z)}).
    \tag{by $\apfunc{j}(\mathsf{nat}^g_n(z))$}
  \end{align}
  However, since $\happly$ is functorial, it suffices to check equality for the three component paths:
  \begin{align*}
    \happly({\funext(\lam{z} \apfunc{i}(\mathsf{nat}^f_n(z)))},z)
    &= {\apfunc{i}(\mathsf{nat}^f_n(z))}\\
    \happly(\apfunc{\blank\circ \tprojf[C] n}(p), z)
    &= {\happly(p,\tproj nz)}\\
    \happly({\funext(\lam{z} \apfunc{j}(\mathsf{nat}^g_n(z)))},z)
    &= {\apfunc{j}(\mathsf{nat}^g_n(z))}.
  \end{align*}
  The first and third of these are just the fact that $\happly$ is quasi-inverse to $\funext$, while
  the second is an easy general lemma about $\happly$ and precomposition.
\end{proof}


\section{Connectedness}
\label{sec:connectivity}

An $n$-type is one that has no interesting information above dimension $n$.
By contrast, an \emph{$n$-connected type} is one that has no interesting information \emph{below} dimension $n$.
It turns out to be natural to study a more general notion for functions as well.

\begin{defn}
A function $f:A\to B$ is said to be \define{$n$-connected}
\indexdef{function!n-connected@$n$-connected}%
\indexsee{n-connected@$n$-connected!function}{function, $n$-connected}%
if for all $b:B$, the type $\trunc n{\hfiber f b}$ is contractible:
\begin{equation*}
  \mathsf{conn}_n(f)\defeq \prd{b:B}\iscontr(\trunc n{\hfiber{f}b}).
\end{equation*}
A type $A$ is said to be \define{$n$-connected}
\indexsee{n-connected@$n$-connected!type}{type, $n$-connected}%
\indexdef{type!n-connected@$n$-connected}%
 if the unique function $A\to\unit$ is $n$-connected, i.e.\ if $\trunc nA$ is contractible.
\end{defn}
\indexsee{connected!function}{function, $n$-connected}

Thus, a function $f:A\to B$ is $n$-connected if and only if $\hfib{f}b$ is $n$-connected for every $b:B$.
Of course, every function is $(-2)$-connected.
At the next level, we have:

\begin{lem}\label{thm:minusoneconn-surjective}
  \index{function!surjective}%
  A function $f$ is $(-1)$-connected if and only if it is surjective in the sense of \cref{sec:mono-surj}.
\end{lem}
\begin{proof}
  We defined $f$ to be surjective if $\trunc{-1}{\hfiber f b}$ is inhabited for all $b$.
  But since it is a mere proposition, inhabitation is equivalent to contractibility.
\end{proof}

Thus, $n$-connectedness of a function for $n\ge 0$ can be thought of as a strong form of surjectivity.
Category-theoretically, $(-1)$-connectedness corresponds to essential surjectivity on objects, while $n$-connectedness corresponds to essential surjectivity on $k$-morphisms for $k\le n+1$.

\cref{thm:minusoneconn-surjective} also implies that a type $A$ is $(-1)$-connected if and only if it is merely inhabited.
When a type is $0$-connected we may simply say that it is \define{connected},
\indexdef{connected!type}%
\indexdef{type!connected}%
and when it is $1$-connected we say it is \define{simply connected}.
\indexdef{simply connected type}%
\indexdef{type!simply connected}%

\begin{rmk}\label{rmk:connectedness-indexing}
  While our notion of $n$-connectedness for types agrees with the standard notion in homotopy theory, our notion of $n$-connectedness for \emph{functions} is off by one from a common indexing in classical homotopy theory.
  Whereas we say a function $f$ is $n$-connected if all its fibers are $n$-connected, some classical homotopy theorists would call such a function $(n+1)$-connected.
  (This is due to a historical focus on \emph{cofibers} rather than fibers.)
\end{rmk}

We now observe a few closure properties of connected maps.
\index{function!n-connected@$n$-connected}

\begin{lem}
\index{retract!of a function}%
Suppose that $g$ is a retract of a $n$-connected function $f$.  Then $g$ is
$n$-connected.
\end{lem}
\begin{proof}
This is a direct consequence of \cref{lem:func_retract_to_fiber_retract}.
\end{proof}

\begin{cor}
If $g$ is homotopic to a $n$-connected function $f$, then $g$ is $n$-connected.
\end{cor}

\begin{lem}\label{lem:nconnected_postcomp}
Suppose that $f:A\to B$ is $n$-connected. Then $g:B\to C$ is $n$-connected if and only if $g\circ f$ is
$n$-connected.
\end{lem}

\begin{proof}
For any $c:C$, we have
\begin{align*}
  \trunc n{\hfib{g\circ f}c}
  & \eqvsym \Trunc n{ \sm{w:\hfib{g}c}\hfib{f}{\proj1 w}}
  \tag{by \cref{ex:unstable-octahedron}}\\
  & \eqvsym \Trunc n{\sm{w:\hfib{g}c} \trunc n{\hfib{f}{\proj1 w}}}
  \tag{by \cref{thm:trunc-in-truncated-sigma}}\\
  & \eqvsym \trunc n{\hfib{g}c}.
  \tag{since $\trunc n{\hfib{f}{\proj1 w}}$ is contractible}
\end{align*}
It follows that $\trunc n{\hfib{g}c}$ is contractible if and only if $\trunc n{\hfib{g\circ f}c}$ is
contractible.
\end{proof}

Importantly, $n$-connected functions can be equivalently characterized as those which satisfy an ``induction principle'' with respect to $n$-types.\index{induction principle!for connected maps}
This idea will lead directly into our proof of the Freudenthal suspension theorem in \cref{sec:freudenthal}.

\begin{lem}\label{prop:nconnected_tested_by_lv_n_dependent types}
For $f:A\to B$ and $P:B\to\type$, consider the following function:
\begin{equation*}
\lam{s} s\circ f :\Parens{\prd{b:B} P(b)}\to\Parens{\prd{a:A}P(f(a))}.
\end{equation*}
For a fixed $f$ and $n\ge -2$, the following are equivalent.
\begin{enumerate}
\item $f$ is $n$-connected.\label{item:conntest1}
\item For every $P:B\to\ntype{n}$, the map $\lam{s} s\circ f$ is an equivalence.\label{item:conntest2}
\item For every $P:B\to\ntype{n}$, the map $\lam{s} s\circ f$ has a section.\label{item:conntest3}
\end{enumerate}
\end{lem}

\begin{proof}
Suppose that $f$ is $n$-connected and let $P:B\to\ntype{n}$. Then we have the equivalences
\begin{align}
  \prd{b:B} P(b) & \eqvsym \prd{b:B} \Parens{\trunc n{\hfib{f}b} \to P(b)}
  \tag{since $\trunc n{\hfib{f}b}$ is contractible}\\
  & \eqvsym \prd{b:B} \Parens{\hfib{f}b\to P(b)}
  \tag{since $P(b)$ is an $n$-type}\\
  & \eqvsym \prd{b:B}{a:A}{p:f(a)= b} P(b)
  \tag{by the left universal property of $\Sigma$-types}\\
  & \eqvsym \prd{a:A} P(f(a)).
  \tag{by the left universal property of path types}
\end{align}
We omit the proof that this equivalence is indeed given by $\lam{s} s\circ f$.
Thus,~\ref{item:conntest1}$\Rightarrow$\ref{item:conntest2}, and clearly~\ref{item:conntest2}$\Rightarrow$\ref{item:conntest3}.
To show~\ref{item:conntest3}$\Rightarrow$\ref{item:conntest1}, consider the type family
\begin{equation*}
P(b)\defeq \trunc n{\hfib{f}b}.
\end{equation*}
Then~\ref{item:conntest3} yields a map $c:\prd{b:B} \trunc n{\hfib{f}b}$ with
$c(f(a))=\tproj n{\pairr{a,\refl{f(a)}}}$. To show that each $\trunc n{\hfib{f}b}$ is contractible,
we will find a function of type
\begin{equation*}
\prd{b:B}{w:\trunc n{\hfib{f}b}} w= c(b).
\end{equation*}
By \cref{thm:truncn-ind}, for this it suffices to find a function of type
\begin{equation*}
\prd{b:B}{a:A}{p:f(a)= b} \tproj n{\pairr{a,p}}= c(b).
\end{equation*}
But by rearranging variables and path induction, this is equivalent to the type
\begin{equation*}
\prd{a:A} \tproj n{\pairr{a,\refl{f(a)}}}= c(f(a)).
\end{equation*}
This property holds by our choice of $c(f(a))$.
\end{proof}

\begin{cor}\label{cor:totrunc-is-connected}
For any $A$, the canonical function $\tprojf n:A\to\trunc n A$ is $n$-connected.
\end{cor}
\begin{proof}
By \cref{thm:truncn-ind} and the associated uniqueness principle, the condition of \cref{prop:nconnected_tested_by_lv_n_dependent types} holds.
\end{proof}

For instance, when $n=-1$, \cref{cor:totrunc-is-connected} says that the map $A\to \brck A$ from a type to its propositional truncation is surjective.

\begin{cor}\label{thm:nconn-to-ntype-const}\label{connectedtotruncated}
A type $A$ is $n$-connected if and only if the map
\begin{equation*}
  \lam{b}{a} b: B \to (A\to B)
\end{equation*}
is an equivalence for every $n$-type $B$.
In other words, ``every map from $A$ to an $n$-type is constant''.
\end{cor}
\begin{proof}
  By \cref{prop:nconnected_tested_by_lv_n_dependent types} applied to a function with codomain $\unit$.
\end{proof}

\begin{lem}\label{lem:nconnected_to_leveln_to_equiv}
Let $B$ be an $n$-type and let $f:A\to B$ be a function. Then the induced function $g:\trunc n A\to B$ is an
equivalence if and only if $f$ is $n$-connected.
\end{lem}

\begin{proof}
By \cref{cor:totrunc-is-connected}, $\tprojf n$ is $n$-connected.
Thus, since $f = g\circ \tprojf n$, by
\cref{lem:nconnected_postcomp} $f$ is $n$-connected if and only if $g$ is $n$-connected.
But since $g$ is a function between $n$-types, its fibers are also $n$-types.
Thus, $g$ is $n$-connected if and only if it is an equivalence.
\end{proof}

We can also characterize connected pointed types in terms of connectivity of the inclusion of their basepoint.

\begin{lem}\label{thm:connected-pointed}
  \index{basepoint}%
  Let $A$ be a type and $a_0:\unit\to A$ a basepoint, with $n\ge -1$.
  Then $A$ is $n$-connected if and only if the map $a_0$ is $(n-1)$-connected.
\end{lem}
\begin{proof}
  First suppose $a_0:\unit\to A$ is $(n-1)$-connected and let $B$ be an $n$-type; we will use \cref{thm:nconn-to-ntype-const}.
  The map $\lam{b}{a} b: B \to (A\to B)$ has a retraction given by $f\mapsto f(a_0)$, so it suffices to show it also has a section, i.e.\ that for any $f:A\to B$ there is $b:B$ such that $f = \lam{a}b$.
  We choose $b\defeq f(a_0)$.
  Define $P:A\to\type$ by $P(a) \defeq (f(a)=f(a_0))$.
  Then $P$ is a family of $(n-1)$-types and we have $P(a_0)$; hence we have $\prd{a:A} P(a)$ since $a_0:\unit\to A$ is $(n-1)$-connected.
  Thus, $f = \lam{a} f(a_0)$ as desired.

  Now suppose $A$ is $n$-connected, and let $P:A\to\ntype{(n-1)}$ and $u:P(a_0)$ be given.
  By \cref{prop:nconnected_tested_by_lv_n_dependent types}, it will suffice to construct $f:\prd{a:A} P(a)$ such that $f(a_0)=u$.
  Now $\ntype{(n-1)}$ is an $n$-type and $A$ is $n$-connected, so by \cref{thm:nconn-to-ntype-const}, there is an $n$-type $B$ such that $P = \lam{a} B$.
  Hence, we have a family of equivalences $g:\prd{a:A} (\eqv{P(a)}{B})$.
  Define $f(a) \defeq \opp{g_a}(g_{a_0}(u))$; then $f:\prd{a:A} P(a)$ and $f(a_0) = u$ as desired.
\end{proof}

In particular, a pointed type $(A,a_0)$ is 0-connected if and only if $a_0:\unit\to A$ is surjective, which is to say $\prd{x:A} \brck{x=a_0}$.
For a similar result in the not-necessarily-pointed case, see \cref{ex:connectivity-inductively}.

A useful variation on \cref{lem:nconnected_postcomp} is:

\begin{lem}\label{lem:nconnected_postcomp_variation}
Let $f:A\to B$ be a function and $P:A\to\type$ and $Q:B\to\type$ be type families. Suppose that $g:\prd{a:A} P(a)\to Q(f(a))$
is a fiberwise $n$-connected%
\index{fiberwise!n-connected family of functions@$n$-connected family of functions}
family of functions, i.e.\ each function $g_a : P(a) \to Q(f(a))$ is $n$-connected.
If $f$ is also $n$-connected, then so is the function
\begin{align*}
\varphi &:\Parens{\sm{a:A} P(a)}\to\Parens{\sm{b:B} Q(b)}\\
\varphi(a,u) &\defeq \pairr{f(a),g_a(u)}.
\end{align*}
Conversely, if $\varphi$ and each $g_a$ are $n$-connected, and moreover $Q$ is fiberwise merely inhabited (i.e.\ we have $\brck{Q(b)}$ for all $b:B$), then $f$ is $n$-connected.
\end{lem}

\begin{proof}
For any $b:B$ and $v:Q(b)$ we have
{\allowdisplaybreaks
\begin{align*}
\trunc n{\hfib{\varphi}{\pairr{b,v}}} & \eqvsym \Trunc n{\sm{a:A}{u:P(a)}{p:f(a)= b} \trans{p}{g_a(u)}= v}\\
& \eqvsym \Trunc n{\sm{w:\hfib{f}b}{u:P(\proj1(w))} g_{\proj 1 w}(u)= \trans{\opp{\proj2(w)}}{v}}\\
& \eqvsym \Trunc n{\sm{w:\hfib{f}b} \hfib{g(\proj1 w)}{\trans{\opp{\proj 2(w)}}{v}}}\\
& \eqvsym \Trunc n{\sm{w:\hfib{f}b} \trunc n{\hfib{g(\proj1 w)}{\trans{\opp{\proj 2(w)}}{v}}}}\\
& \eqvsym \trunc n{\hfib{f}b}
\end{align*}}%
where the transportations along $f(p)$ and $f(p)^{-1}$ are with respect to $Q$.
Therefore, if either is contractible, so is the other.

In particular, if $f$ is $n$-connected, then $\trunc n{\hfib{f}b}$ is contractible for all $b:B$, and hence so is $\trunc n{\hfib{\varphi}{\pairr{b,v}}}$ for all $(b,v):\sm{b:B} Q(b)$.
On the other hand, if $\varphi$ is $n$-connected, then $\trunc n{\hfib{\varphi}{\pairr{b,v}}}$ is contractible for all $(b,v)$, hence so is $\trunc n{\hfib{f}b}$ for any $b:B$ such that there exists some $v:Q(b)$.
Finally, since contractibility is a mere proposition, it suffices to merely have such a $v$.
\end{proof}

The converse direction of \cref{lem:nconnected_postcomp_variation} can fail if $Q$ is not fiberwise merely inhabited.
For example, if $P$ and $Q$ are both constant at $\emptyt$, then $\varphi$ and each $g_a$ are equivalences, but $f$ could be arbitrary.

In the other direction, we have

\begin{lem}\label{prop:nconn_fiber_to_total}
Let $P,Q:A\to\type$ be type families and consider a fiberwise transformation\index{fiberwise!transformation}
\begin{equation*}
f:\prd{a:A} \Parens{P(a)\to Q(a)}
\end{equation*}
from $P$ to $Q$. Then the induced map $\total f: \sm{a:A}P(a) \to \sm{a:A} Q(a)$ is $n$-connected if and only if each $f(a)$ is $n$-connected.
\end{lem}

Of course, the ``only if'' direction is also a special case of \cref{lem:nconnected_postcomp_variation}.

\begin{proof}
By \cref{fibwise-fiber-total-fiber-equiv}, we have
$\hfib{\total f}{\pairr{x,v}}\eqvsym\hfib{f(x)}v$
for each $x:A$ and $v:Q(x)$. Hence $\trunc n{\hfib{\total f}{\pairr{x,v}}}$ is contractible if and only if
$\trunc n{\hfib{f(x)}v}$ is contractible.
\end{proof}

Another useful fact about connected maps is that they induce an
equivalence on $n$-truncations:

\begin{lem} \label{lem:connected-map-equiv-truncation}
If $f : A \to B$ is $n$-connected, then it induces an equivalence
$\eqv{\trunc{n}{A}}{\trunc{n}{B}}$.
\end{lem}
\begin{proof}
Let $c$ be the proof that $f$ is $n$-connected.  From left to right, we
use the map $\trunc{n}{f} : \trunc{n}{A} \to \trunc{n}{B}$.
To define the map from right to left, by the universal property of
truncations, it suffices to give a map $\mathsf{back} : B \to {\trunc{n}{A}}$.  We can
define this map as follows:
\[
\mathsf{back}(y) \defeq \trunc{n}{\proj{1}}{(\proj{1}{(c(y))})}.
\]
By definition, $c(y)$ has type $\iscontr(\trunc n {\hfiber{f}y})$, so its
first component has type $\trunc n{\hfiber{f}y}$, and we can obtain an
element of $\trunc n A$ from this by projection.

Next, we show that the composites are the identity.  In both directions,
because the goal is a path in an $n$-truncated type, it suffices to
cover the case of the constructor $\tprojf{n}$.

In one direction, we must show that for all $x:A$,
\[
\trunc{n}{\proj{1}}{(\proj{1}{(c(f(x)))})} = \tproj{n}{x}.
\]
But $\tproj{n}{(x, \refl{f(x)})} : \trunc n{\hfiber{f}{f(x)}}$, and
$c(f(x))$ says that this type is contractible, so
\[
\proj{1}{(c(f(x)))} = \tproj{n}{(x, \refl{})}.
\]
Applying $\trunc{n}{\proj{1}}$ to both sides of this equation gives the
result.

In the other direction, we must show that for all $y:B$,
\[
\trunc{n}{f}(\trunc{n}{\proj{1}} (\proj{1}{(c(y))})) = \tproj{n}{y}.
\]
$\proj{1}{(c(y))}$ has type $\trunc n {\hfiber{f}y}$, and the path we
want is essentially the second component of the $\hfiber{f}y$, but we
need to make sure the truncations work out.

In general, suppose we are given $p:\trunc{n}{\sm{x:A} B(x)}$ and wish to prove
$P(\trunc{n}{\proj{1}{}}(p))$. By truncation induction, it suffices to
prove $P(\tproj{n}{a})$ for all $a:A$ and $b:B(a)$.  Applying this
principle in this case, it suffices to prove
\[
\trunc{n}{f}(\tproj{n}{a}) = \tproj{n}{y}
\]
given $a:A$ and $b:f (a) = y$.  But the left-hand side equals $\tproj{n}{f (a)}$,
so applying $\tprojf{n}$ to both sides of $b$ gives the result.
\end{proof}

One might guess that this fact characterizes the $n$-connected maps, but in fact being $n$-connected is a bit stronger than this.
For instance, the inclusion $\bfalse:\unit \to\bool$ induces an equivalence on $(-1)$-truncations, but is not surjective (i.e.\ $(-1)$-connected).
In \cref{sec:long-exact-sequence-homotopy-groups} we will see that the difference in general is an analogous extra bit of surjectivity.


\section{Orthogonal factorization}
\label{sec:image-factorization}

\index{unique!factorization system|(}%
\index{orthogonal factorization system|(}%
In set theory, the surjections and the injections form a unique factorization system: every function factors essentially uniquely as a surjection followed by an injection.
We have seen that surjections generalize naturally to $n$-connected maps, so it is natural to inquire whether these also participate in a factorization system.
Here is the corresponding generalization of injections.

\begin{defn}
  A function $f:A\to B$ is \define{$n$-truncated}
  \indexdef{n-truncated@$n$-truncated!function}%
  \indexdef{function!n-truncated@$n$-truncated}%
if the fiber $\hfib f b$ is an $n$-type for all $b:B$.
\end{defn}

In particular, $f$ is $(-2)$-truncated if and only if it is an equivalence.
And of course, $A$ is an $n$-type if and only if $A\to\unit$ is $n$-truncated.
Moreover, $n$-truncated maps could equivalently be defined recursively, like $n$-types.

\begin{lem}\label{thm:modal-mono}
  For any $n\ge -2$, a function $f:A\to B$ is $(n+1)$-truncated if and only if for all $x,y:A$, the map $\apfunc{f}:(x=y) \to (f(x)=f(y))$ is $n$-truncated.
  \index{function!embedding}%
  \index{function!injective}%
  In particular, $f$ is $(-1)$-truncated if and only if it is an embedding in the sense of \cref{sec:mono-surj}.
\end{lem}
\begin{proof}
  Note that for any $(x,p),(y,q):\hfib f b$, we have
  \begin{align*}
    \big((x,p) = (y,q)\big)
    &= \sm{r:x=y} (p = \apfunc f(r)\ct q)\\
    &= \sm{r:x=y} (\apfunc f (r) = p\ct \opp q)\\
    &= \hfib{\apfunc{f}}{p\ct \opp q}.
  \end{align*}
  Thus, any path space in any fiber of $f$ is a fiber of $\apfunc{f}$.
  On the other hand, choosing $b\defeq f(y)$ and $q\defeq \refl{f(y)}$ we see that any fiber of $\apfunc f$ is a path space in a fiber of $f$.
  The result follows, since $f$ is $\nplusone$-truncated if all path spaces of its fibers are $n$-types.
\end{proof}

We can now construct the factorization, in a fairly obvious way.

\begin{defn}\label{defn:modal-image}
Let $f:A\to B$ be a function. The \define{$n$-image}
\indexdef{image}%
\indexdef{image!n-image@$n$-image}%
\indexdef{n-image@$n$-image}%
\indexdef{function!n-image of@$n$-image of}%
of $f$ is defined as
\begin{equation*}
\im_n(f)\defeq \sm{b:B} \trunc n{\hfib{f}b}.
\end{equation*}
When $n=-1$, we write simply $\im(f)$ and call it the \define{image} of $f$.
\end{defn}

\begin{lem}\label{prop:to_image_is_connected}
For any function $f:A\to B$, the canonical function $\tilde{f}:A\to\im_n(f)$ is $n$-connected.
Consequently, any function factors as an $n$-connected function followed by an $n$-truncated function.
\end{lem}

\begin{proof}
Note that $A\eqvsym\sm{b:B}\hfib{f}b$. The function $\tilde{f}$ is the function on total spaces induced by the canonical fiberwise transformation
\begin{equation*}
\prd{b:B} \Parens{\hfib{f}b\to\trunc n{\hfib{f}b}}.
\end{equation*}
Since each map $\hfib{f}b\to\trunc n{\hfib{f}b}$ is $n$-connected by \cref{cor:totrunc-is-connected}, $\tilde{f}$ is $n$-connected by \cref{prop:nconn_fiber_to_total}.
Finally, the projection $\proj1:\im_n(f) \to B$ is $n$-truncated, since its fibers are equivalent to the $n$-truncations of the fibers of $f$.
\end{proof}

In the following lemma we set up some machinery to prove the unique factorization theorem.

\begin{lem}\label{prop:factor_equiv_fiber}
Suppose we have a commutative diagram of functions
\begin{equation*}
  \xymatrix{
    {A} \ar[r]^{g_1} \ar[d]_{g_2} &
    {X_1} \ar[d]^{h_1} &
    \\
    {X_2} \ar[r]_{h_2}
    &
    {B}
  }
\end{equation*}
with $H:h_1\circ g_1\htpy h_2\circ g_2$, where $g_1$ and $g_2$ are $n$-connected and where $h_1$ and $h_2$ are $n$-truncated.
Then there is an equivalence
\begin{equation*}
E(H,b):\hfib{h_1}b\eqvsym\hfib{h_2}b
\end{equation*}
for any $b:B$, such that for any $a:A$ we have an identification
\[\overline{E}(H,a) :  E(H,h_1(g_1(a)))({g_1(a),\refl{h_1(g_1(a))}}) = \pairr{g_2(a),\opp{H(a)}}.\]
\end{lem}

\begin{proof}
Let $b:B$. Then we have the following equivalences:
\begin{align}
\hfib{h_1}b
& \eqvsym \sm{w:\hfib{h_1}b} \trunc n{ \hfib{g_1}{\proj1 w}}
\tag{since $g_1$ is $n$-connected}\\
& \eqvsym \Trunc n{\sm{w:\hfib{h_1}b}\hfib{g_1}{\proj1 w}}
\tag{by \cref{thm:refl-over-ntype-base}, since $h_1$ is $n$-truncated}\\
& \eqvsym \trunc n{\hfib{h_1\circ g_1}b}
\tag{by \cref{ex:unstable-octahedron}}
\end{align}
and likewise for $h_2$ and $g_2$.
Also, since we have a homotopy $H:h_1\circ g_1\htpy h_2\circ g_2$, there is an obvious equivalence $\hfib{h_1\circ g_1}b\eqvsym\hfib{h_2\circ g_2}b$.
Hence we obtain
\begin{equation*}
\hfib{h_1}b\eqvsym\hfib{h_2}b
\end{equation*}
for any $b:B$. By analyzing the underlying functions, we get the following representation of what happens to the element
$\pairr{g_1(a),\refl{h_1(g_1(a))}}$ after applying each of the equivalences of which $E$ is composed.
Some of the identifications are definitional, but others (marked with a $=$ below) are only propositional; putting them together we obtain $\overline E(H,a)$.
{\allowdisplaybreaks
\begin{align*}
\pairr{g_1(a),\refl{h_1(g_1(a))}} &
    \overset{=}{\mapsto} \Pairr{\pairr{g_1(a),\refl{h_1(g_1(a))}}, \tproj n{ \pairr{a,\refl{g_1(a)}}}}\\
  & \mapsto \tproj n { \pairr{\pairr{g_1(a),\refl{h_1(g_1(a))}}, \pairr{a,\refl{g_1(a)}} }}\\
  & \mapsto \tproj n { \pairr{a,\refl{h_1(g_1(a))}}}\\
  & \overset{=}{\mapsto} \tproj n { \pairr{a,\opp{H(a)}}}\\
  & \mapsto \tproj n { \pairr{\pairr{g_2(a),\opp{H(a)}},\pairr{a,\refl{g_2(a)}}} }\\
  & \mapsto \Pairr{\pairr{g_2(a),\opp{H(a)}}, \tproj n {\pairr{a,\refl{g_2(a)}}} }\\
  & \mapsto \pairr{g_2(a),\opp{H(a)}}
\end{align*}}
The first equality is because for general $b$, the map
\narrowequation{ \hfib{h_1}b \to \sm{w:\hfib{h_1}b} \trunc n{ \hfib{g_1}{\proj1 w}} }
inserts the center of contraction for $\trunc n{ \hfib{g_1}{\proj1 w}}$ supplied by the assumption that $g_1$ is $n$-truncated; whereas in the case in question this type has the obvious inhabitant $\tproj n{ \pairr{a,\refl{g_1(a)}}}$, which by contractibility must be equal to the center.
The second propositional equality is because the equivalence $\hfib{h_1\circ g_1}b\eqvsym\hfib{h_2\circ g_2}b$ concatenates the second components with $\opp{H(a)}$, and we have $\opp{H(a)} \ct \refl{} = \opp{H(a)}$.
The reader may check that the other equalities are definitional (assuming a reasonable solution to \cref{ex:unstable-octahedron}).
\end{proof}

% The equivalences $E(H,b)$ are such that $E(H^{-1},b)= E(H,b)^{-1}$.

Combining \cref{prop:to_image_is_connected,prop:factor_equiv_fiber}, we have the following unique factorization result:

\begin{thm}\label{thm:orth-fact}
For each $f:A\to B$, the space $\fact_n(f)$ defined by
\begin{equation*}
\sm{X:\type}{g:A\to X}{h:X\to B} (h\circ g\htpy f)\times\mathsf{conn}_n(g)\times\mathsf{trunc}_n(h)
\end{equation*}
is contractible.
Its center of contraction is the element
\begin{equation*}
\pairr{\im_n(f),\tilde{f},\proj1,\theta,\varphi,\psi}:\fact_n(f)
\end{equation*}
arising from \cref{prop:to_image_is_connected},
where $\theta:\proj1\circ\tilde{f}\htpy f$ is the canonical homotopy, where $\varphi$ is the proof of
\cref{prop:to_image_is_connected}, and where $\psi$ is the obvious proof that $\proj1:\im_n(f)\to B$ has $n$-truncated fibers.
\end{thm}

\begin{proof}
By \cref{prop:to_image_is_connected} we know that there is an element of $\fact_n(f)$, hence it is enough to
show that $\fact_n(f)$ is a mere proposition. Suppose we have two $n$-factorizations
\begin{equation*}
\pairr{X_1,g_1,h_1,H_1,\varphi_1,\psi_1}\qquad\text{and}\qquad\pairr{X_2,g_2,h_2,H_2,\varphi_2,\psi_2}
\end{equation*}
of $f$. Then we have the pointwise-concatenated homotopy
\[ H\defeq (\lam{a} H_1(a) \ct H_2^{-1}(a)) \,:\, (h_1\circ g_1\htpy h_2\circ g_2).\]
By univalence and the characterization of paths and transport in $\Sigma$-types, function types, and path types, it suffices to show that
\begin{enumerate}
\item there is an equivalence $e:X_1\eqvsym X_2$,
\item there is a homotopy $\zeta:e\circ g_1\htpy g_2$,
% \note{Is it easy enough to see that these elements are the various transports?}
\item there is a homotopy $\eta:h_2\circ e\htpy h_1$,
\item for any $a:A$ we have $\opp{\apfunc{h_2}(\zeta(a))} \ct \eta(g_1(a)) \ct H_1(a) = H_2(a)$.
\end{enumerate}
%where $\underline{e}$ is the function underlying the equivalence.
We prove these four assertions in that order.
\begin{enumerate}
\item By \cref{prop:factor_equiv_fiber}, we have a fiberwise equivalence
% \note{It could be a nice exercise for the book to show
% that if $f_1:A_1\to B$ and $f_2:A_2\to B$ have equivalent fibers, then $A_1\eqvsym A_2$}.
\begin{equation*}
E(H) : \prd{b:B} \eqv{\hfib{h_1}b}{\hfib{h_2}b}.
\end{equation*}
This induces an equivalence of total spaces, i.e.\ we have
\begin{equation*}
\eqvspaced{\Parens{\sm{b:B} \hfib{h_1}b}}{\Parens{\sm{b:B}\hfib{h_2}b}}.
\end{equation*}
Of course, we also have the equivalences $X_1\eqvsym\sm{b:B}\hfib{h_1}b$ and $X_2\eqvsym\sm{b:B}
\hfib{h_2}b$ from \cref{thm:total-space-of-the-fibers}.
This gives us our equivalence $e:X_1\eqvsym X_2$; the reader may verify that the underlying function of $e$ is given by
\begin{equation*}
e(x) \jdeq \proj1(E(H,h_1(x))(x,\refl{h_1(x)})).
\end{equation*}
\item By \cref{prop:factor_equiv_fiber}, we may choose
  $\zeta(a) \defeq \apfunc{\proj1}(\overline E(H,a)) : e(g_1(a)) = g_2(a)$.
  \label{item:orth-fact-2}
\item For every $x:X_1$, we have
\begin{equation*}
\proj2(E(H,h_1(x))({x,\refl{h_1(x)}})) :h_2(e(x))= h_1(x),
\end{equation*}
giving us a homotopy $\eta:h_2\circ e\htpy h_1$.
\item By the characterization of paths in fibers (\cref{lem:hfib}), the path $\overline E(H,a)$ from \cref{prop:factor_equiv_fiber} gives us
  $\eta(g_1(a)) = \apfunc{h_2}(\zeta(a)) \ct \opp{H(a)}$.
  The desired equality follows by substituting the definition of $H$ and rearranging paths.\qedhere
\end{enumerate}
\end{proof}

% I can't make sense of this, and it doesn't seem necessary
%
% \begin{cor}
% A function $f:A\to B$ is $n$-connected if and only if
% \begin{equation*}
% \prd C\prd{g:\modalfunc(B\to C)} \iscontr\big(\sm{h:\modalfunc(B\to C)}\underline{h}\circ
% f\htpy\underline{g}\circ f\big).
% \end{equation*}
% \end{cor}

By standard arguments, this yields the following orthogonality principle.

\begin{thm}
  Let $e:A\to B$ be $n$-connected and $m:C\to D$ be $n$-truncated.
  Then the map
  \[ \varphi: (B\to C) \;\to\; \sm{h:A\to C}{k:B\to D} (m\circ h \htpy k \circ e) \]
  is an equivalence.
\end{thm}
\begin{proof}[Sketch of proof]
  For any $(h,k,H)$ in the codomain, let $h = h_2 \circ h_1$ and $k = k_2 \circ k_1$, where $h_1$ and $k_1$ are $n$-connected and $h_2$ and $k_2$ are $n$-truncated.
  Then $f = (m\circ h_2) \circ h_1$ and $f = k_2 \circ (k_1\circ e)$ are both $n$-factorizations of $m \circ h = k\circ e$.
  Thus, there is a unique equivalence between them.
  It is straightforward (if a bit tedious) to extract from this that $\hfib\varphi{(h,k,H)}$ is contractible.
\end{proof}

\index{orthogonal factorization system|)}%
\index{unique!factorization system|)}%

We end by showing that images are stable under pullback.
\index{image!stability under pullback}
\index{factorization!stability under pullback}

\begin{lem}\label{lem:hfiber_wrt_pullback}
Suppose that the square
\begin{equation*}
  \vcenter{\xymatrix{
      A\ar[r]\ar[d]_f &
      C\ar[d]^g\\
      B\ar[r]_-h &
      D
      }}
\end{equation*}
is a pullback square and let $b:B$. Then $\hfib{f}b\eqvsym\hfib{g}{h(b)}$.
\end{lem}

\begin{proof}
This follows from pasting of pullbacks (\cref{ex:pullback-pasting}), since the type $X$ in the diagram
\begin{equation*}
  \vcenter{\xymatrix{
      X\ar[r]\ar[d] &
      A\ar[r]\ar[d]_f &
      C\ar[d]^g\\
      \unit\ar[r]_b &
      B\ar[r]_h &
      D
      }}
\end{equation*}
is the pullback of the left square if and only if it is the pullback of the outer rectangle, while $\hfib{f}b$ is the pullback of the square on the left and $\hfib{g}{h(b)}$ is the pullback of the outer rectangle.
\end{proof}

\begin{thm}\label{thm:stable-images}
\index{stability!of images under pullback}%
Consider functions $f:A\to B$, $g:C\to D$ and the diagram
\begin{equation*}
  \vcenter{\xymatrix{
      A\ar[r]\ar[d]_{\tilde{f}_n} &
      C\ar[d]^{\tilde{g}_n}\\
      \im_n(f)\ar[r]\ar[d]_{\proj1} &
      \im_n(g)\ar[d]^{\proj1}\\
      B\ar[r]_h &
      D
      }}
\end{equation*}
If the outer rectangle is a pullback, then so is the bottom square (and hence so is the top square, by \cref{ex:pullback-pasting}). Consequently, images are stable under pullbacks.
\end{thm}

\begin{proof}
Assuming the outer square is a pullback, we have equivalences
\begin{align*}
B\times_D\im_n(g) & \jdeq \sm{b:B}{w:\im_n(g)} h(b)=\proj1 w\\
& \eqvsym \sm{b:B}{d:D}{w:\trunc n{\hfib{g}d}} h(b)= d\\
& \eqvsym \sm{b:B} \trunc n{\hfib{g}{h(b)}}\\
& \eqvsym \sm{b:B} \trunc n{\hfib{f}b} &&
\text{(by \cref{lem:hfiber_wrt_pullback})}\\
& \equiv \im_n(f). && \qedhere
\end{align*}
\end{proof}

\index{n-type@$n$-type|)}%

\section{Modalities}
\label{sec:modalities}

\index{modality|(}

Nearly all of the theory of $n$-types and connectedness can be done in much greater generality.
This section will not be used in the rest of the book.

Our first thought regarding generalizing the theory of $n$-types might be to take \cref{thm:trunc-reflective} as a definition.

\begin{defn}\label{defn:reflective-subuniverse}
  A \define{reflective subuniverse}
  \indexdef{reflective!subuniverse}%
  \indexdef{subuniverse, reflective}%
  is a predicate $P:\type\to\prop$ such that
  for every $A:\type$ we have a type $\reflect A$ such that $P(\reflect A)$ and a map
  $\project_A:A\to\reflect A$, with the property that for every $B:\type$ with $P(B)$, the following map is an equivalence:
  \[\function{(\reflect A\to{}B)}{(A\to{}B)}{f}{f\circ\project_A}.\]
\end{defn}

We write $\P \defeq \setof{A:\type | P(A)}$, so $A:\P$ means that $A:\type$ and we have $P(A)$.
We also write $\rec{\modal}$ for the quasi-inverse of the above map.
The notation $\reflect$ may seem slightly odd, but it will make more sense soon.

For any reflective subuniverse, we can prove all the familiar facts about reflective subcategories from category theory, in the usual way.
For instance, we have:
\begin{itemize}
\item A type $A$ lies in $\P$ if and only if $\project_A:A\to\reflect A$ is an equivalence.
\item $\P$ is closed under retracts.
  In particular, $A$ lies in $\P$ as soon as $\project_A$ admits a retraction.
\item The operation $\reflect$ is a functor in a suitable up-to-coherent-homotopy sense, which we can make precise at as high levels as necessary.
\item The types in $\P$ are closed under all limits such as products and pullbacks.
  In particular, for any $A:\P$ and $x,y:A$, the identity type $(x=_A y)$ is also in $\P$, since it is a pullback of two functions $\unit\to A$.
\item Colimits in $\P$ can be constructed by applying $\reflect$ to ordinary colimits of types.
\end{itemize}

Importantly, closure under products extends also to ``infinite products'', i.e.\ dependent function types.

\begin{thm}\label{thm:reflsubunv-forall}
  If $B:A\to\P$ is any family of types in a reflective subuniverse \P, then $\prd{x:A} B(x)$ is also in \P.
\end{thm}
\begin{proof}
  For any $x:A$, consider the function $\mathsf{ev}_x : (\prd{x:A} B(x)) \to B(x)$ defined by $\mathsf{ev}_x(f) \defeq f(x)$.
  Since $B(x)$ lies in $P$, this extends to a function
  \[ \rec{\modal}(\mathsf{ev}_x) : \reflect\Parens{\prd{x:A} B(x)} \to B(x). \]
  Thus we can define $h:\reflect(\prd{x:A} B(x)) \to \prd{x:A} B(x)$ by $h(z)(x) \defeq \rec{\modal}(\mathsf{ev}_x)(z)$.
  Then $h$ is a retraction of $\project_{\prd{x:A} B(x)}$, so that ${\prd{x:A} B(x)}$ is in $\P$.
\end{proof}

In particular, if $B:\P$ and $A$ is any type, then $(A\to B)$ is in \P.
In categorical language, this means that any reflective subuniverse is an \define{exponential ideal}.
\indexdef{exponential ideal}%
This, in turn, implies by a standard argument that the reflector preserves finite products.

\begin{cor}\label{cor:trunc_prod}
  For any types $A$ and $B$ and any reflective subuniverse, the induced map $\reflect(A\times B) \to \reflect(A) \times \reflect(B)$ is an equivalence.
\end{cor}
\begin{proof}
  It suffices to show that $\reflect(A) \times \reflect(B)$ has the same universal property as $\reflect(A\times B)$.
  It lies in $\P$ by the above remark that types in $\P$ are closed under limits.
  Now let $C:\P$; we have
  \begin{align*}
    (\reflect(A) \times \reflect(B) \to C)
    &= (\reflect(A) \to (\reflect(B) \to C))\\
    &= (\reflect(A) \to (B \to C))\\
    &= (A \to (B \to C))\\
    &= (A \times B \to C)
  \end{align*}
  using the universal properties  of $\reflect(B)$ and $\reflect(A)$, along with the fact that $B\to C$ is in \P since $C$ is.
  It is straightforward to verify that this equivalence is given by composing with $\mreturn_A \times \mreturn_B$, as needed.
\end{proof}

It may seem odd that every reflective subcategory of types is automatically an exponential ideal, with a product-preserving reflector.
However, this is also the case classically in the category of \emph{sets}, for the same reasons.
It's just that this fact is not usually remarked on, since the classical category of sets---in contrast to the category of homotopy
types---does not have many interesting reflective subcategories.

Two basic properties of $n$-types are \emph{not} shared by general reflective subuniverses: \cref{thm:ntypes-sigma} (closure under $\Sigma$-types) and \cref{thm:truncn-ind} (truncation induction).
However, the analogues of these two properties are equivalent to each other.


\begin{thm}\label{thm:modal-char}
  For a reflective subuniverse \P, the following are logically equivalent.
  \begin{enumerate}
  \item If $A:\P$ and $B:A\to \P$, then $\sm{x:A} B(x)$ is in \P.\label{item:mchr1}
  \item for every $A:\type$, type family $B:\reflect A\to\P$, and map $g:\prd{a:A} B(\project(a))$, there exists $f:\prd{z:\reflect A} B(z)$ such that $f(\project(a)) = g(a)$ for all $a:A$.\label{item:mchr2}
  \end{enumerate}
\end{thm}
\begin{proof}
  Suppose~\ref{item:mchr1}.
  Then in the situation of~\ref{item:mchr2}, the type $\sm{z:\reflect A} B(z)$ lies in $\P$, and we have $g':A\to \sm{z:\reflect A} B(z)$ defined by $g'(a)\defeq (\project(a),g(a))$.
  Thus, we have $\rec{\modal}(g'):\reflect A \to \sm{z:\reflect A} B(z)$ such that $\rec{\modal}(g')(\project(a)) = (\project(a),g(a))$.

  Now consider the functions $\proj1 \circ \rec{\modal}(g') : \reflect A \to \reflect A$ and $\idfunc[\reflect A]$.
  By assumption, these become equal when precomposed with $\project$.
  Thus, by the universal property of $\reflect$, they are equal already, i.e.\ we have $p_z:\proj1(\rec{\modal}(g')(z)) = z$ for all $z$.
  Now we can define
  %
  \narrowequation{f(z) \defeq \trans{p_z}{\proj2(\rec{\modal}(g')(z))},}
  %
  Using the adjunction property of the equivalence of
  definition~\ref{defn:reflective-subuniverse}, one can show that the first component of
  %
  \narrowequation{\rec{\modal}(g')(\project(a)) = (\project(a),g(a))}
  %
  is equal to $p_{\project(a)}$.  Thus, its second component yields
  $f(\project(a)) = g(a)$, as needed.

  Conversely, suppose~\ref{item:mchr2}, and that $A:\P$ and $B:A\to\P$.
  Let $h$ be the composite
  \[ \reflect\Parens{\sm{x:A} B(x)} \xrightarrow{\reflect(\proj1)} \reflect A \xrightarrow{\opp{(\project_A)}} A. \]
  Then for $z:\sm{x:A} B(x)$ we have
  \begin{align*}
    h(\project(z)) &= \opp\project(\reflect(\proj1)(\project(z)))\\
    &= \opp\project(\project(\proj1(z)))\\
    &= \proj1(z).
  \end{align*}
  Denote this path by $p_z$.
  Now if we define $C:\reflect(\sm{x:A} B(x)) \to \type$ by $C(w) \defeq B(h(w))$, we have
  \[ g \defeq \lam{z} \trans{p_z}{\proj2(z)} \;:\; \prd{z:\sm{x:A} B(x)} C(\project(z)). \]
  Thus, the assumption yields
  %
  \narrowequation{f:\prd{w:\reflect(\sm{x:A}B(x))} C(w)}
  %
  such that $f(\project(z)) = g(z)$.
  Together, $h$ and $f$ give a function
  %
  \narrowequation{k:\reflect(\sm{x:A}B(x)) \to \sm{x:A}B(x)}
  %
  defined by $k(w) \defeq (h(w),f(w))$, while $p_z$ and the equality $f(\project(z)) = g(z)$ show that $k$ is a retraction of $\project_{\sm{x:A}B(x)}$.
  Therefore, $\sm{x:A}B(x)$ is in \P.
\end{proof}

Note the similarity to the discussion in \cref{sec:htpy-inductive}.
\index{recursion principle!for a modality}%
\index{induction principle!for a modality}%
\index{uniqueness!principle, propositional!for a modality}%
The universal property of the reflector of a reflective subuniverse is like a recursion principle with its uniqueness property, while \cref{thm:modal-char}\ref{item:mchr2} is like the corresponding induction principle.
Unlike in \cref{sec:htpy-inductive}, the two are not equivalent here, because of the restriction that we can only eliminate into types that lie in $\P$.
Condition~\ref{item:mchr1} of \cref{thm:modal-char} is what fixes the disconnect.

Unsurprisingly, of course, if we have the induction principle, then we can derive the recursion principle.
We can also derive its uniqueness property, as long as we allow ourselves to eliminate into path types.
This suggests the following definition.
Note that any reflective subuniverse can be characterized by the operation $\reflect:\type\to\type$ and the functions $\project_A:A\to \reflect A$, since we have $P(A) = \isequiv(\project_A)$.

\begin{defn}\label{defn:modality}
A \define{modality}
\indexdef{modality}
is an operation $\modal:\type\to\type$ for which there are
\begin{enumerate}
\item functions $\mreturn^\modal_A:A\to\modal(A)$ for every type $A$.\label{item:modal1}
\item for every $A:\type$ and every type family $B:\modal(A)\to\type$, a function\label{item:modal2}
\begin{equation*}
\ind{\modal}:\Parens{\prd{a:A}\modal(B(\mreturn^\modal_A(a)))}\to\prd{z:\modal(A)}\modal(B(z)).
\end{equation*}
\item A path $\ind\modal(f)(\mreturn^\modal_A(a)) = f(a)$ for each $f:\prd{a:A}\modal(B(\mreturn^\modal_A(a)))$.\label{item:modal3}
\item For any $z,z':\modal(A)$, the function $\mreturn^\modal_{z=z'} : (z=z') \to \modal(z=z')$ is an equivalence.\label{item:modal4}
\end{enumerate}
We say that $A$ is \define{modal}
\indexdef{modal!type}%
\indexdef{type!modal}%
for $\modal$ if $\mreturn^\modal_A:A\to\modal(A)$ is an equivalence, and we write
\begin{equation}
  \modaltype\defeq\setof{X:\type | X \text{ is $\modal$-modal} }\label{eq:modaltype}
\end{equation}
for the type of modal types.
\end{defn}

Conditions~\ref{item:modal2} and~\ref{item:modal3} are very similar to \cref{thm:modal-char}\ref{item:mchr2}, but phrased using $\modal B(z)$ rather than assuming $B$ to be valued in $\P$.
This allows us to state the condition purely in terms of the operation $\modal$, rather than requiring the predicate $P:\type\to\prop$ to be given in advance.
(It is not entirely satisfactory, since we still have to refer to $P$ not-so-subtly in clause~\ref{item:modal4}.
We do not know whether~\ref{item:modal4} follows from~\ref{item:modal1}--\ref{item:modal3}.)
However, the stronger-looking property of \cref{thm:modal-char}\ref{item:mchr2} follows from \cref{defn:modality}\ref{item:modal2} and~\ref{item:modal3}, since for any $C:\modal A \to \modaltype$ we have $C(z) \eqvsym \modal C(z)$, and we can pass back across this equivalence.

\index{universal!property!of a modality}%
As with other induction principles, this implies a universal property.

\begin{thm}\label{prop:lv_n_deptype_sec_equiv_by_precomp}
Let $A$ be a type and let $B:\modal(A)\to\modaltype$. Then the function
\begin{equation*}
(\blank\circ \mreturn^\modal_A) : \Parens{\prd{z:\modal(A)}B(z)} \to \Parens{\prd{a:A}B(\mreturn^\modal_A(a))}
\end{equation*}
is an equivalence.
\end{thm}
\begin{proof}
By definition, the operation $\ind{\modal}$ is a right inverse to $(\blank\circ \mreturn^\modal_A)$.
Thus, we only need to find a homotopy
\begin{equation*}
\prd{z:\modal(A)}s(z)= \ind{\modal}(s\circ \mreturn^\modal_A)(z)
\end{equation*}
for each $s:\prd{z:\modal(A)}B(z)$, exhibiting it as a left inverse as well.
By assumption, each $B(z)$ is modal, and hence each type $s(z)= R^\modal_X(s\circ \mreturn^\modal_A)(z)$
is also modal.
Thus, it suffices to find a function of type
\begin{equation*}
\prd{a:A}s(\mreturn^\modal_A(a))= \ind{\modal}(s\circ \mreturn^\modal_A)(\mreturn^\modal_A(a))
\end{equation*}
which follows from \cref{defn:modality}\ref{item:modal3}.
\end{proof}

In particular, for every type $A$ and every modal type $B$, we have an equivalence $(\modal A\to B)\eqvsym (A\to B)$.

\begin{cor}
  For any modality $\modal$, the $\modal$-modal types form a reflective subuniverse satisfying the equivalent conditions of \cref{thm:modal-char}.
\end{cor}

Thus, modalities can be identified with reflective subuniverses closed under $\Sigma$-types.
The name \emph{modality} comes, of course, from \emph{modal logic}\index{modal!logic}, which studies logic where we can form statements such as ``possibly $A$'' (usually written $\diamond A$) or ``necessarily $A$'' (usually written $\Box A$).
The symbol $\modal$ is somewhat common for an arbitrary modal operator\index{modal!operator}. % (rather than a specific one such as $\diamond$ or $\Box$).
Under the propositions-as-types principle, a modality in the sense of modal logic corresponds to an operation on \emph{types}, and \cref{defn:modality} seems a reasonable candidate for how such an operation should be defined.
(More precisely, we should perhaps call these \emph{idempotent, monadic} modalities; see the Notes.)
\index{idempotent!modality}%
As mentioned in \cref{subsec:when-trunc}, we may in general use adverbs\index{adverb} to speak informally about such modalities, such as ``merely''\index{merely} for the propositional truncation and ``purely''\index{purely} for the identity modality
\index{identity!modality}%
\index{modality!identity}%
(i.e.\ the one defined by $\modal A \defeq A$).

For any modality $\modal$, we define a map $f:A\to B$ to be \define{$\modal$-connected}
\indexdef{function!.circle-connected@$\modal$-connected}%
\indexdef{.circle-connected function@$\modal$-connected function}%
if $\modal(\hfib f b)$ is contractible for all $b:B$, and to be \define{$\modal$-truncated}
\indexdef{function!.circle-truncated@$\modal$-truncated}%
\indexdef{.circle-truncated function@$\modal$-truncated function}%
if $\hfib f b$ is modal for all $b:B$.
All of the theory of \cref{sec:connectivity,sec:image-factorization} which doesn't involve relating $n$-types for different values of $n$ applies verbatim in this generality.
\index{orthogonal factorization system}%
\index{unique!factorization system}%
In particular, we have an orthogonal factorization system.

An important class of modalities which does \emph{not} include the $n$-trun\-ca\-tions is the \emph{left exact} modalities: those for which the functor $\modal$ preserves pullbacks as well as finite products.
\index{topology!Lawvere-Tierney}%
These are a categorification of ``Lawvere-Tierney\index{Lawvere}\index{Tierney} topologies'' in elementary topos\index{topos} theory,
and correspond in higher-categorical semantics to sub-$(\infty,1)$-toposes.
\index{.infinity1-topos@$(\infty,1)$-topos}%
However, this is beyond the scope of this book.

Some particular examples of modalities other than $n$-truncation can be found in the exercises.

\index{modality|)}

\sectionNotes

The notion of homotopy $n$-type in classical homotopy theory is quite old.
It was Voevodsky who realized that the notion can be defined recursively in homotopy type theory, starting from contractibility.

\index{axiom!Streicher's Axiom K}%
The property ``Axiom K'' was so named by Thomas Streicher, as a property of identity types which comes after J, the latter being the traditional name for the eliminator of identity types.
\cref{thm:hedberg} is due to Hedberg~\cite{hedberg1998coherence}; \cite{krausgeneralizations} contains more information and generalizations.

The notions of $n$-connected spaces and functions are also classical in homotopy theory, although as mentioned before, our indexing for connectedness of functions is off by one from the classical indexing.
The importance of the resulting factorization system has been emphasized by recent work in higher topos theory by Rezk, Lurie, and others.%
\index{.infinity1-topos@$(\infty,1)$-topos}
In particular, the results of this chapter should be compared with~\cite[\S6.5.1]{lurie:higher-topoi}.
In \cref{sec:freudenthal}, the theory of $n$-connected maps will be crucial to our proof of the Freudenthal suspension theorem.

Modal operators\index{modal!operator} in \emph{simple} type theory have been studied extensively; see e.g.~\cite{modalTT}.  In the setting of dependent type theory, \cite{ab:bracket-types} treats the special case of propositional truncation ($(-1)$-truncation) as a modal operator\index{modal!operator}.  The development presented here greatly extends and generalizes this work, while drawing also on ideas from topos theory.\index{topos}

Generally, modal operators\index{modal!operator} come in (at least) two flavors: those such as $\diamond$ (``possibly'') for which $A\Rightarrow \diamond A$, and those such as $\Box$ (``necessarily'') for which $\Box A \Rightarrow A$.
When they are also \emph{idempotent} (i.e.\ $\diamond A = \diamond{\diamond A}$ or $\Box A = \Box{\Box A}$), the former may be identified with reflective subcategories (or equivalently, idempotent monads), and the latter with coreflective subcategories (or idempotent comonads).
\index{monad}
\index{comonad}
However, in dependent type theory it is trickier to deal with the comonadic sort, since they are more rarely stable under pullback, and thus cannot be interpreted as operations on the universe \UU.
Sometimes there are ways around this (see e.g.~\cite{QGFTinCHoTT12}), but for simplicity, here we stick to the monadic sort.

On the computational side, monads (and hence modalities\index{modality}) are used to model computational effects in functional programming~\cite{Moggi89}.%
\index{programming}%
\index{computational effect}
A computation is said to be \emph{pure} if its execution results in no side effects (such as printing a message to the screen, playing music, or sending data over the Internet).
There exist ``purely functional'' programming languages, such as Haskell\index{Haskell}, in which it is technically only possible to write pure functions: side effects are represented by applying ``monads'' to output types.
For instance, a function of type $\mathsf{Int}\to\mathsf{Int}$ is pure, while a function of type $\mathsf{Int}\to \mathsf{IO}(\mathsf{Int})$ may perform input and output along the way to computing its result; the operation $\mathsf{IO}$ is a monad.
\index{purely}%
(This is the origin of our use of the adverb ``purely'' for the identity monad, since it corresponds computationally to pure functions with no side-effects.)
The modalities we have considered in this chapter are all idempotent, whereas those used in functional programming rarely are, but the ideas are still closely related.


\sectionExercises

\begin{ex}\label{ex:all-types-sets}\
  \begin{enumerate}
    \item Use \cref{thm:h-set-refrel-in-paths-sets} to show
    that if $\brck{A}\to A$ for every type $A$,
    then every type is a set.
    \item Show that if every surjective function (purely) splits,
    i.e.~if
    %
    \narrowequation{\prd{b:B}\brck{\hfib{f}{b}}\to\prd{b:B}\hfib{f}{b}}
    %
    for every $f:A\to B$, then every type is a set.
  \end{enumerate}
\end{ex}

\begin{ex}\label{ex:s2-colim-unit}
  For this exercise, we consider the following general notion of colimit.
  Define a \define{graph}\indexdef{graph} $\Gamma$ to consist of a type $\Gamma_0$ and a family $\Gamma_1 : \Gamma_0 \to \Gamma_0 \to \UU$.
  A \define{diagram}\index{diagram} (of types) over a graph $\Gamma$ consists of a family $F:\Gamma_0 \to \UU$ together with for each $x,y:\Gamma_0$, a function $F_{x,y}:\Gamma_1(x,y) \to F(x) \to F(y)$.
  The \define{colimit}\index{colimit!of types} of such a diagram is the higher inductive type $\colim(F)$ generated by
  \begin{itemize}
  \item for each $x:\Gamma_0$, a function $\inc_x:F(x) \to \colim(F)$, and
  \item for each $x,y:\Gamma_0$ and $\gamma:\Gamma_1(x,y)$ and $a:F(x)$, a path $\inc_y(F_{x,y}(\gamma,a)) = \inc_x(a)$.
  \end{itemize}
  There are more general kinds of colimits as well (see e.g.\ \cref{ex:s2-colim-unit-2}), but this is good enough for many purposes.
  \begin{enumerate}
  \item Exhibit a graph $\Gamma$ such that colimits of $\Gamma$-diagrams can be identified with pushouts as defined in \cref{sec:colimits}.
    In other words, each span should induce a diagram over $\Gamma$ whose colimit is the pushout of the span.
  \item Exhibit a graph $\Gamma$ and a diagram $F$ over $\Gamma$ such that $F(x)=\unit$ for all $x$, but such that $\colim(F)=\Sn^2$.
    Note that $\unit$ is a $(-2)$-type, while $\Sn^2$ is not expected to be an $n$-type for any finite $n$.
    See also \cref{ex:s2-colim-unit-2}.
  \end{enumerate}
\end{ex}

\begin{ex}\label{ex:ntypes-closed-under-wtypes}
  Show that if $A$ is an $n$-type and $B:A\to \ntype{n}$ is a family of $n$-types, where $n\ge -1$, then the $W$-type $\wtype{a:A} B(a)$ (see \cref{sec:w-types}) is also an $n$-type.
\end{ex}

\begin{ex}\label{ex:connected-pointed-all-section-retraction}
  Use \cref{prop:nconn_fiber_to_total} to extend \cref{thm:connected-pointed} to any section-retraction pair.
\end{ex}

\begin{ex}\label{ex:ntype-from-nconn-const}
  Show that \cref{thm:nconn-to-ntype-const} also works as a characterization in the other direction: $B$ is an $n$-type if and only if every map into $B$ from an $n$-con\-nect\-ed type is constant.
  Ideally, your proof should work for any modality as in \cref{sec:modalities}.
\end{ex}

\begin{ex}\label{ex:connectivity-inductively}
  Prove that for $n\ge -1$, a type $A$ is $n$-connected if and only if it is merely inhabited and for all $a,b:A$ the type $\id[A]ab$ is $(n-1)$-connected.
  Thus, since every type is $(-2)$-connected, $n$-connectedness of types can be defined inductively using only propositional truncations.
  (In particular, $A$ is 0-connected if and only if $\brck{A}$ and $\prd{a,b:A} \brck{a=b}$.)
\end{ex}

\begin{ex}\label{ex:lemnm}
  \indexdef{excluded middle!LEMnm@$\LEM{n,m}$}%
  For $-1\le n,m \le\infty$, let $\LEM{n,m}$ denote the statement
  \[ \prd{A:\ntype{n}} \trunc m{A + \neg A},\]
  where $\ntype{\infty} \defeq \type$ and $\trunc{\infty}{X}\defeq X$.
  Show that:
  \begin{enumerate}
  \item If $n=-1$ or $m=-1$, then $\LEM{n,m}$ is equivalent to $\LEM{}$ from \cref{sec:intuitionism}.
  \item If $n\ge 0$ and $m\ge 0$, then $\LEM{n,m}$ is inconsistent with univalence.
  \end{enumerate}
\end{ex}

\begin{ex}\label{ex:acnm}
  \indexdef{axiom!of choice!ACnm@$\choice{n,m}$}%
  For $-1\le n,m\le\infty$, let $\choice{n,m}$ denote the statement
  \[ \prd{X:\set}{Y:X\to\ntype{n}}
  \Parens{\prd{x:X} \trunc m{Y(x)}}
  \to
  \Trunc m{\prd{x:X} Y(x)},
  \]
  with conventions as in \cref{ex:lemnm}.
  Thus $\choice{0,-1}$ is the axiom of choice from \cref{sec:axiom-choice},
  while $\choice{\infty,\infty}$ is the identity function.
  (If we had formulated $\choice{n,m}$ analogously to \eqref{eq:ac}
  rather than \eqref{eq:epis-split},
  $\choice{\infty,\infty}$ would be like \cref{thm:ttac}.)
  It is known that $\choice{\infty,-1}$ is consistent with univalence, since it holds in Voevodsky's simplicial model.
  \begin{enumerate}
  \item Without using univalence, show that $\LEM{n,\infty}$ implies $\choice{n,m}$ for all $m$.
    (On the other hand, in \cref{subsec:emacinsets} we will show that $\choice{}=\choice{0,-1}$ implies $\LEM{}=\LEM{-1,-1}$.)
  \item Of course, $\choice{n,m}\Rightarrow \choice{k,m}$ if $k\le n$.
    Are there any other implications between the principles $\choice{n,m}$?
    Is $\choice{n,m}$ consistent with univalence for any $m\ge 0$ and any $n$?
    (These are open questions.)\index{open!problem}
  \end{enumerate}
\end{ex}

\begin{ex}\label{ex:acnm-surjset}
  Show that $\choice{n,-1}$ implies that for any $n$-type $A$, there merely exists a set $B$ and a surjection $B\to A$.
\end{ex}

\begin{ex}\label{ex:acconn}
  Define the \define{$n$-connected axiom of choice}
  \indexdef{n-connected@$n$-connected!axiom of choice}%
  \indexdef{axiom!of choice!n-connected@$n$-connected}%
  to be the statement
  \begin{quote}
    If $X$ is a set and $Y:X\to \type$ is a family of types such that each $Y(x)$ is $n$-connected, then $\prd{x:X} Y(x)$ is $n$-connected.
  \end{quote}
  Note that the $(-1)$-connected axiom of choice is $\choice{\infty,-1}$ from \cref{ex:acnm}.
  \begin{enumerate}
  \item Prove that the $(-1)$-connected axiom of choice implies the $n$-con\-nect\-ed axiom of choice for all $n\ge -1$.
  \item Are there any other implications between the $n$-connected axioms of choice and the principles $\choice{n,m}$?
    (This is an open question.)\index{open!problem}
  \end{enumerate}
\end{ex}

\begin{ex}\label{ex:n-truncation-not-left-exact}
  Show that the $n$-truncation modality is not left exact for any $n\ge -1$.
  That is, exhibit a pullback which it fails to preserve.
\end{ex}

\begin{ex}\label{ex:double-negation-modality}
  Show that $X\mapsto (\neg\neg X)$ is a modality.\index{modal!operator}%
\end{ex}

\begin{ex}\label{ex:prop-modalities}
  Let $P$ be a mere proposition.
  \begin{enumerate}
  \item Show that $X\mapsto (P\to X)$ is a left exact modality.
    This is called the \define{open modality}
    \indexdef{open!modality}%
    \indexdef{modality!open}%
    associated to $P$.
  \item Show that $X\mapsto P*X$ is a left exact modality, where $*$ denotes the join (see \cref{sec:colimits}).
    This is called the \define{closed modality}
    \indexdef{closed!modality}%
    \indexdef{modality!closed}%
    associated to $P$.
  \end{enumerate}
\end{ex}

\begin{ex}\label{ex:f-local-type}
  Let $f:A\to B$ be a map; a type $Z$ is \define{$f$-local}
  \indexdef{f-local type@$f$-local type}%
  \indexdef{type!f-local@$f$-local}%
  if $(\blank\circ f):(B\to Z) \to (A\to Z)$ is an equivalence.
  \begin{enumerate}
  \item Prove that the $f$-local types form a reflective subuniverse.
    You will want to use a higher inductive type to define the reflector (localization).
  \item Prove that if $B=\unit$, then this subuniverse is a modality.
  \end{enumerate}
\end{ex}

\begin{ex}\label{ex:trunc-spokes-no-hub}
  Show that in contrast to \cref{rmk:spokes-no-hub}, we could equivalently define $\trunc nA$ to be generated by a function $\tprojf n : A \to \trunc n A$ together with for each $r:\Sn^{n+1} \to \trunc n A$ and each $x:\Sn^{n+1}$, a path $s_r(x):r(x) = r(\base)$.
\end{ex}

\begin{ex}\label{ex:s2-colim-unit-2}
  In this exercise, we consider a slightly fancier notion of colimit than in \cref{ex:s2-colim-unit}.
  Define a \define{graph with composition}\indexdef{graph!with composition} $\Gamma$ to be a graph as in \cref{ex:s2-colim-unit} together with for each $x,y,z:\Gamma_0$, a function $\Gamma_1(y,z) \to \Gamma_1(x,y) \to \Gamma_1(x,z)$, written as $\delta\mapsto\gamma \mapsto \delta \circ \gamma$.
  (For instance, any precategory as in \cref{cha:category-theory} is a graph with composition.)
  A \define{diagram}\index{diagram} $F$ over a graph with composition $\Gamma$ consists of a diagram over the underlying graph, together with for each $x,y,z:\Gamma_0$ and $\gamma:\Gamma_1(x,y)$ and $\delta:\Gamma_1(y,z)$, a homotopy $\cmp_{x,y,z}(\delta,\gamma) : F_{y,z}(\delta) \circ F_{x,y}(\gamma) \htpy F_{x,z}(\delta\circ\gamma)$.
  The \define{colimit}\index{colimit!of types} of such a diagram is the higher inductive type $\colim(F)$ generated by
  \begin{itemize}
  \item for each $x:\Gamma_0$, a function $\inc_x:F(x) \to \colim(F)$,
  \item for each $x,y:\Gamma_0$ and $\gamma:\Gamma_1(x,y)$ and $a:F(x)$, a path $\glue_{x,y}(\gamma,a) : \inc_y(F_{x,y}(\gamma,a)) = \inc_x(a)$, and
  \item for each $x,y,z:\Gamma_0$ and $\gamma:\Gamma_1(x,y)$ and $\delta:\Gamma_1(y,z)$ and $a:F(x)$, a path
    \[ \ap{\inc_z}{\cmp_{x,y,z}(\delta,\gamma,a)} \ct \glue_{x,z}(\delta\circ \gamma,a) = \glue_{y,z}(\delta,F_{x,y}(\gamma,a)) \ct \glue_{x,y}(\gamma,a). \]
  \end{itemize}
  (This is a ``second-order approximation'' to a fully homotopy-theoretic notions of diagram and colimit, which ought to involve ``coherence paths'' of this sort at all higher levels.
  Defining such things in type theory is an important open problem.)

  Exhibit a graph with composition $\Gamma$ such that $\Gamma_0$ is a set and each type $\Gamma_1(x,y)$ is a mere proposition, and a diagram $F$ over $\Gamma$ such that $F(x)=\unit$ for all $x$, for which $\colim(F)=\Sn^2$.
\end{ex}

\begin{ex}\label{ex:fiber-map-not-conn}
  Comparing \cref{lem:nconnected_postcomp_variation,prop:nconn_fiber_to_total}, one might be tempted to conjecture that if $f:A\to B$ is $n$-connected and $g:\prd{a:A} P(a) \to Q(f(a))$ induces an $n$-connected map $\Parens{\sm{a:A} P(a)} \to \Parens{\sm{b:B} Q(b)}$, then $g$ is fiberwise $n$-connected.
  Give a counterexample to show that this is false.
  (In fact, when generalized to modalities, this property characterizes the left exact ones; see \cref{ex:prop-modalities}.)
\end{ex}

\begin{ex}\label{ex:is-conn-trunc-functor}
  Show that if $f : A \to B$ is $n$-connected, then $\trunc kf : \trunc kA \to \trunc kB$ is also $n$-connected.
\end{ex}

\begin{ex}\label{ex:categorical-connectedness}
  We say a type $A$ is \define{categorically connected}
  \indexdef{connected!categorically} if for every types $B, C$ the canonical map
  $e_{A, B, C}:((A\to B) + (A\to C)) \to (A \to B + C)$ defined by
  \begin{align*}
    e_{A,B,C}(\inl(g)) &\defeq \lam{x} \inl(g(x)),\\
    e_{A,B,C}(\inr(g)) &\defeq \lam{x} \inr(g(x))
  \end{align*}
  is an equivalence.
  \begin{enumerate}
  \item Show that any connected type is categorically connected.
  \item Show that all categorically connected types are connected if and only if $\LEM{}$ holds. (Hint: consider $A \defeq \Sigma P$ such that $\neg \neg P$ holds.)
  \end{enumerate}
\end{ex}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "hott-online"
%%% End:
