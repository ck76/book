\chapter{同伦理论 (Homotopy Theory)}
\label{cha:homotopy}

\index{acceptance|(}

在本章中，我们将在类型理论中发展一些同伦理论 (homotopy theory)。我们使用了在\cref{cha:basics}中介绍的\emph{综合方法} (synthetic approach) 来进行同伦理论的研究：空间 (spaces)、点 (points)、路径 (paths) 和同伦 (homotopies) 是基本概念，它们分别由类型 (types) 和类型的元素表示，特别是同一性类型 (identity type)。路径和同伦的代数结构由类型上自然的 $\infty$-群 (groupoid) 结构生成，这一结构是由同一性类型的规则生成的。使用在\cref{cha:hits}中引入的高阶归纳类型 (higher inductive types)，我们可以直接通过其泛性质来描述空间。

\index{synthetic mathematics}%
这种综合方法有几个有趣的方面。首先，它结合了具体模型（如拓扑空间 (topological spaces) 或单纯集合 (simplicial sets)）的优势与用于同伦理论的抽象范畴框架（如Quillen模型范畴 (Quillen model categories)）的优势。一方面，我们的证明看起来很基础，并且具体涉及类型中的点、路径和同伦。另一方面，我们的方法仍然抽象化了这些对象的任何具体表示——例如，路径连接的结合性是通过路径归纳法 (path induction) 证明的，而不是通过映射 $[0,1] \to X$ 的重参数化或通过角填充条件 (horn-filling conditions) 证明的。类型理论似乎是研究 $\infty$-群 (groupoid) 抽象同伦理论的非常方便的方法：通过使用同一性类型的规则，我们可以避免许多 $\infty$-群定义中涉及的复杂组合问题，并且只需在任何特定证明中说明所需的结构。

类型理论的抽象性质意味着我们的证明可以自动应用于各种环境中。特别是，如前所述，同伦类型理论 (homotopy type theory) 在Kan单纯集合 (Kan simplicial sets) 中有一个解释，这是一种 $\infty$-群同伦理论的模型。因此，我们的证明适用于这个模型，并且通过从单纯集合到拓扑空间的几何实现函子 (geometric realization functor) 转移它们，可以得到经典同伦理论中的对应定理。然而，尽管细节仍在进行中，我们也可以在看起来像 $\infty$-群的其他范畴（例如 $(\infty,1)$-拓扑 (toposes)）中解释类型理论。因此，在类型理论中证明的结果也将在这些环境中成立。这种额外的一般性在普通范畴逻辑中是众所周知的：同一性基础将其扩展到同伦理论中。

其次，我们的综合方法提出了一些新的类型理论方法和证明。我们的一些证明是经典证明的直接转录。其他证明则更具有类型理论的风格，主要包括使用 $\infty$-群操作的计算，这种风格与计算机科学家使用类型理论推理计算机程序非常相似。类型理论允许我们聚焦于同伦理论中不同于其他方法的方面：虽然工具如路径归纳法和高阶归纳类型的泛性质在像Kan单纯集合这样的环境中是可用的，但类型理论提升了它们的重要性，因为它们是处理这些类型的\emph{唯一}原始工具。聚焦于这些工具已经导致了对熟悉构造的新描述，例如圆的通用覆盖 (universal cover) 和Hopf纤维 (Hopf fibration)，这些描述仅使用高阶归纳类型的递归原则。这些描述非常直接，本章中的许多证明涉及到与这些纤维的计算计算。

\index{mathematics!constructive}%
我们的证明的另一个新方面是它们是构造性的（假设同一性和高阶归纳类型是构造性的）；我们将在\cref{sec:moreresults}中描述将其应用于球体的同伦群的一个应用。

\index{mathematics!formalized}%
\indexsee{formalization of mathematics}{mathematics, formalized}%
第三，我们的综合方法非常适合于在证明助手 (proof assistants)（如 \Coq 和 \Agda）中进行计算机验证的证明。本章中描述的几乎所有证明都经过了计算机验证，其中许多证明首先在证明助手中给出，然后为本书“非形式化”。计算机验证的证明与这里提出的非正式证明在长度和努力上是可比的，并且在某些情况下，它们甚至更短，更容易完成。

\mentalpause

在开始介绍我们的结果之前，我们将简要回顾一些基本概念和同伦理论中的定理，以便那些不熟悉这些概念的读者。我们还将概述本章中证明的结果。

\index{classical!homotopy theory|(}%
同伦理论是代数拓扑的一个分支，并使用抽象代数的工具（如群论 (group theory)）来研究空间的性质。同伦理论家研究的一个问题是如何判断两个空间是否相同，其中“相同”意味着\emph{同伦等价} (homotopy equivalence)（连续映射来回组合成同伦意义上的恒等映射——这给了“修正”那些不能完全组合成恒等映射的映射的机会）。判断两个空间是否相同的一种常见方法是计算与空间相关的\emph{代数不变量} (algebraic invariants)，其中包括其\emph{同伦群} (homotopy groups) 和\emph{同调群} (homology) 和\emph{上同调群} (cohomology groups)。同伦等价的空间具有同构的同伦/（上）同调群，因此如果两个空间具有不同的群，那么它们就不等价。因此，这些代数不变量提供了有关空间的全局信息，可用于区分空间，并补充了诸如连续性等概念所提供的局部信息。例如，圆环 (torus) 在局部看起来像2-球面 (2-sphere)，但它有一个全局差异，因为它有一个洞，这一差异在这两个空间的同伦群中是可见的。

最简单的同伦群的例子是空间的\emph{基本群} (fundamental group)，记为 $\pi_1(X,x_0)$：给定一个空间 $X$ 及其中的一个点 $x_0$，可以构造一个群，其元素是 $x_0$ 处的环路（从 $x_0$ 到 $x_0$ 的连续路径），在同伦意义上进行考虑，群运算由恒等路径（静止）、路径连接和路径反转给出。例如，2-球面的基本群是平凡的，但圆环的基本群不是，这表明球面和圆环不是同伦等价的。直观上，每个球面上的环路都是同伦等价于恒等的，因为它的内部可以填充。而在圆环上穿过圆环洞的环路不是同伦等价于恒等的，因此基本群中有非平凡元素。

\index{homotopy!group}
\emph{高阶同伦群} (higher homotopy groups) 提供了空间的更多信息。固定空间 $X$ 中的一个点 $x_0$，并考虑恒等路径 $\refl{x_0}$。那么，$\refl{x_0}$ 与自身之间同伦的同伦类构成一个群 $\pi_2(X,x_0)$，它告诉我们关于空间二维结构的一些信息。然后，$\pi_3(X,x_0)$ 是同伦之间的同伦类的群，依此类推。代数拓扑的一个基本问题是\emph{计算空间 $X$ 的同伦群}，这意味着给出 $\pi_k(X,x_0)$ 和一些更直接的群的描述（例如，通过乘法表或呈示）之间的群同构。令人惊讶的是，即使对于像球体 (spheres) 这样简单的空间，这个问题也是非常困难的。如\cref{tab:homotopy-groups-of-spheres} 所示，高阶同伦群的一些模式出现了，但没有一般公式，并且许多球体的同伦群目前仍然未知。

\bgroup
% Colors for the table of homotopy groups of spheres
\definecolor{xA}{\OPTcolormodel}{\OPTcolxA}
\definecolor{xB}{\OPTcolormodel}{\OPTcolxB}
\definecolor{xC}{\OPTcolormodel}{\OPTcolxC}
\definecolor{xD}{\OPTcolormodel}{\OPTcolxD}
\definecolor{xE}{\OPTcolormodel}{\OPTcolxE}
\definecolor{xF}{\OPTcolormodel}{\OPTcolxF}
\definecolor{xG}{\OPTcolormodel}{\OPTcolxG}
\definecolor{xH}{\OPTcolormodel}{\OPTcolxH}
\definecolor{xI}{\OPTcolormodel}{\OPTcolxI}
\definecolor{xJ}{\OPTcolormodel}{\OPTcolxJ}
\definecolor{xK}{\OPTcolormodel}{\OPTcolxK}
\definecolor{xL}{\OPTcolormodel}{\OPTcolxL}
\definecolor{xM}{\OPTcolormodel}{\OPTcolxM}

\newcommand{\cA}{\colorbox{xG}{\hbox to 20pt {\hfil$0$\hfil}}}
\newcommand{\cB}{\colorbox{xH}{\hbox to 20pt {\hfil$\Z$\hfil}}}
\newcommand{\cC}{\colorbox{xI}{\hbox to 20pt {\hfil$\Z_{2}$\hfil}}}
\newcommand{\cD}{\colorbox{xJ}{\hbox to 20pt {\hfil$\Z_{2}$\hfil}}}
\newcommand{\cE}{\colorbox{xK}{\hbox to 20pt {\hfil$\Z_{24}$\hfil}}}
\newcommand{\cF}{\colorbox{xL}{\hbox to 20pt {\hfil$0$\hfil}}}
\newcommand{\cG}{\colorbox{xM}{\hbox to 20pt {\hfil$0$\hfil}}}
\newcommand{\cH}{\colorbox{xF}{\hbox to 20pt {\hfil$0$\hfil}}}
\newcommand{\cI}{\colorbox{xE}{\hbox to 20pt {\hfil$0$\hfil}}}
\newcommand{\cJ}{\colorbox{xD}{\hbox to 20pt {\hfil$0$\hfil}}}
\newcommand{\cK}{\colorbox{xC}{\hbox to 20pt {\hfil$0$\hfil}}}
\newcommand{\cL}{\colorbox{xB}{\hbox to 20pt {\hfil$0$\hfil}}}
\newcommand{\cM}{\colorbox{xA}{\hbox to 20pt {\hfil$0$\hfil}}}

\begin{table}[htb]
  \centering\small
  \begin{tabular}{p{15pt}>{\centering\arraybackslash}p{\OPTspherescolwidth}>{\centering\arraybackslash}p{\OPTspherescolwidth}>{\centering\arraybackslash}p{\OPTspherescolwidth}>{\centering\arraybackslash}p{\OPTspherescolwidth}>{\centering\arraybackslash}p{\OPTspherescolwidth}>{\centering\arraybackslash}p{\OPTspherescolwidth}>{\centering\arraybackslash}p{\OPTspherescolwidth}>{\centering\arraybackslash}p{\OPTspherescolwidth}>{\centering\arraybackslash}p{\OPTspherescolwidth}}
    \toprule
    & $\Sn^0$ & $\Sn^1$ & $\Sn^{2}$ & $\Sn^{3}$ & $\Sn^{4}$ & $\Sn^{5}$ & $\Sn^{6}$ & $\Sn^{7}$ & $\Sn^{8}$ \\ \addlinespace[3pt] \midrule
    $\pi_{1}$  & $0$     & $\Z$    & \cA       & \cH       & \cI       & \cJ       & \cK       & \cL       & \cM       \\ \addlinespace[3pt]
    $\pi_{2}$  & $0$     & $0$     & \cB       & \cA       & \cH       & \cI       & \cJ       & \cK       & \cL       \\ \addlinespace[3pt]
    $\pi_{3}$  & $0$     & $0$     & $\Z$      & \cB       & \cA       & \cH       & \cI       & \cJ       & \cK       \\ \addlinespace[3pt]
    $\pi_{4}$  & $0$     & $0$     & $\Z_{2}$  & \cC       & \cB       & \cA       & \cH       & \cI       & \cJ       \\ \addlinespace[3pt]
    $\pi_{5}$  & $0$     & $0$     & $\Z_{2}$  & $\Z_{2}$  & \cC       & \cB       & \cA       & \cH       & \cI       \\ \addlinespace[3pt]
    $\pi_{6}$  & $0$     & $0$     & $\Z_{12}$ & $\Z_{12}$ & \cD       & \cC       & \cB       & \cA       & \cH       \\ \addlinespace[3pt]
    $\pi_{7}$  & $0$     & $0$     & $\Z_{2}$  & $\Z_{2}$  & {\footnotesize $\Z {\times} \Z_{12}$} & \cD & \cC & \cB     & \cA    \\ \addlinespace[3pt]
    $\pi_{8}$  & $0$     & $0$     & $\Z_{2}$  & $\Z_{2}$  & $\Z_{2}^{2}$ & \cE & \cD & \cC & \cB \\ \addlinespace[3pt]
    $\pi_{9}$  & $0$     & $0$     & $\Z_{3}$  & $\Z_{3}$  & $\Z_{2}^{2}$ & $\Z_{2}$ & \cE & \cD & \cC \\ \addlinespace[3pt]
    $\pi_{10}$ & $0$     & $0$     & $\Z_{15}$ & $\Z_{15}$ & \footnotesize{$$\Z_{24} {\times} \Z_{3}$$} & $\Z_{2}$ & \cF & \cE & \cD \\ \addlinespace[3pt]
    $\pi_{11}$ & $0$     & $0$     & $\Z_{2}$  & $\Z_{2}$  & $\Z_{15}$ & $\Z_{2}$ & $\Z$ & \cF & \cE \\ \addlinespace[3pt]
    $\pi_{12}$ & $0$     & $0$     & $\Z_{2}^{2}$ & $\Z_{2}^{2}$ & $\Z_{2}$ & $\Z_{30}$ & $\Z_{2}$ & \cG & \cF \\ \addlinespace[3pt]
    $\pi_{13}$ & $0$     & $0$     & {\footnotesize $\Z_{12} {\times} \Z_{2}$} & {\footnotesize $\Z_{12} {\times} \Z_{2}$} & $\Z_{2}^{3}$ & $\Z_{2}$ & $\Z_{60}$ & $\Z_{2}$ & \cG \\ \addlinespace[3pt]
%$\pi_{14}$ & $0$     & $0$     & $\Z_{84} {\times} \Z_{2}^{2}$ & $\Z_{84} {\times} \Z_{2}^{2}$ & {\footnotesize $\Z_{120} {\times} $\Z_{12} {\times} \Z_{2}$} & $\Z_{2}^{3}$ & $\Z_{24} {\times} \Z_{2}$ & $\Z_{120}$ & $\Z_{2}$ \\ \addlinespace[3pt]
%$\pi_{15}$ & $0$     & $0$     & $\Z_{2}^{2}$ & $\Z_{2}^{2}$ & $\Z_{84} {\times} $\Z_{2}^{5}$ & $\Z_{72} {\times} \Z_{2}$ & $\Z_{2}^{3}$ & $\Z_{2}^{3}$ & $\Z {\times} \Z_{120}$ \\ \addlinespace[3pt]
    \bottomrule
  \end{tabular}

  \caption{球体的同伦群~\cite{wikipedia-groups}.\index{homotopy!group!of sphere}
    $n$ 维球面 $\Sn^n$ 的第 $k$ 同伦群 $\pi_k$ 同构于表中的群，其中 $\Z$ 是整数的加法群\index{integers}，$\Z_{m}$ 是阶数为 $m$ 的循环群\index{group!cyclic}\index{cyclic group}。
  }
  \label{tab:homotopy-groups-of-spheres}
\end{table}
\egroup

理解这种复杂性的一种方法是通过在\cref{cha:basics}中介绍的空间和 $\infty$-群的对应关系\index{.infinity-groupoid@$\infty$-groupoid}。如在\cref{sec:circle}中讨论的那样，2-球面由具有一个点和一个二维环的高阶归纳类型 (higher inductive type) 表示。因此，人们可能想知道为什么 $\pi_3(\Sn ^2)$ 是 $\Z$，当类型 $\Sn ^2$ 没有生成 3 维胞元的生成元时。事实证明，$\pi_3(\Sn ^2)$ 的生成元素是使用\cref{thm:EckmannHilton} 中描述的互换律构造的：$\infty$-群的代数结构包括各个层级之间的非平凡相互作用，这些相互作用产生了更高阶同伦群的元素。

\index{classical!homotopy theory|)}%

类型理论为研究这一结构提供了一个自然的环境，因为我们可以很容易地定义高阶同伦群。回顾\cref{def:loopspace}中的定义，对于 $n:\N$，以点类型 $(A,a)$ 的 $n$ 重迭代环空间\index{loop space!iterated} 递归定义为：
\begin{align*}
  \Omega^0(A,a)&=(A,a)\\
  \Omega^{n+1}(A,a)&=\Omega^n(\Omega(A,a)).
\end{align*}
%
这给出了 $n$ 维环的\emph{空间}（即类型），它本身具有更高阶的同伦。通过截断我们得到 $n$ 维环的集合（这也是在\cref{sec:free-algebras}中作为示例定义的）：

\begin{defn}[同伦群 (Homotopy Groups)]\label{def-of-homotopy-groups}
对于 $n\ge 1$ 和 $(A,a)$ 一个点类型，我们定义 $A$ 在 $a$ 处的\define{同伦群 (homotopy groups)}
\indexdef{homotopy!group}%
为
\[\pi_n(A,a)\defeq \Trunc0{\Omega^n(A,a)}\]
\end{defn}

\noindent
由于 $n\ge 1$，路径连接和反转操作在 $\Omega^n(A)$ 上诱导出 $\pi_n(A)$ 上的操作，使其成为群的方式非常简单。如果 $n\ge 2$，那么通过 Eckmann--Hilton 论证\index{Eckmann--Hilton argument} (\cref{thm:EckmannHilton})，群 $\pi_n(A)$ 是阿贝尔群\index{group!abelian}。将 $\pi_0(A) \defeq \trunc0 A$ 也是方便的，但这种情况有所不同：它不仅不是一个群，并且定义时不涉及 $A$ 中的任何基点。

\index{presentation!of an infinity-groupoid@of an $\infty$-groupoid}%
这个定义适合于研究同伦群，因为一个类型 $X$ 的（高阶）归纳定义将 $X$ 表现为一个自由类型，类似于一个自由 $\infty$-群 (groupoid)，并且这种表示\emph{决定}了 $X$ 的更高同一性类型，但并不\emph{显式地描述}。同一性类型由生成元（如圆的 $\lloop$）和对它们应用的所有群操作（恒等，复合，逆元，结合律，互换律，……）生成。因此，高阶归纳的空间表示允许我们提出问题“$X$ 的同一性类型最终是什么？” 尽管回答它可能需要一些重要的数学。这是类型理论中的一个更高维度的推广：即使 $X$ 是一个普通的归纳类型，如自然数或布尔值，刻画 $X$ 的同一性类型也可能需要一些工作。例如，$\bfalse$ 和 $\btrue$ 是不同的这个定理并不是从定义直接得出的；见\cref{sec:compute-coprod}。

\index{univalence axiom}%
同一性公理 (univalence axiom) 在计算同伦群时起着关键作用（没有同一性，类型理论可以兼容一种解释，其中所有路径，包括圆上的 $\lloop$，都是反射性的）。我们将在下面的圆的基本群的计算中看到这一点：从 $\Omega(\Sn^1)$ 到 $\Z$ 的映射是通过将圆上的环映射到集合 $\Z$ 的自同构\index{automorphism!of Z, successor@of $\Z$, successor} 来定义的，例如 $\lloop \ct \opp \lloop$ 被送到 $\mathsf{successor} \ct \mathsf{predecessor}$（其中 $\mathsf{successor}$ 和 $\mathsf{predecessor}$ 是 $\Z$ 的自同构，被视为宇宙中的路径），然后将自同构应用于 0。通过同一性，宇宙中产生了非平凡的路径，这被用来从高阶归纳类型中的路径中提取信息。

在本章中，我们首先计算一些球体的同伦群，包括 $\pi_k(\Sn ^1)$ (\cref{sec:pi1-s1-intro})，$k<n$ 时的 $\pi_{k}(\Sn ^n)$ (\cref{sec:conn-susp,sec:pik-le-n})，通过 Hopf 纤维 (\cref{sec:hopf}) 和长正合序列 (long-exact-sequence) 的论证 (\cref{sec:long-exact-sequence-homotopy-groups}) 计算 $\pi_2(\Sn ^2)$ 和 $\pi_3(\Sn ^2)$，以及通过 Freudenthal 悬挂定理 (\cref{sec:freudenthal}) 计算 $\pi_n(\Sn ^n)$。接着，我们讨论 van Kampen 定理 (\cref{sec:van-kampen})，它刻画了一个推挽 (pushout) 的基本群，以及 Whitehead 原理的状态（当一个映射在所有同伦群上引起等价时，它是否是一个等价？）(\cref{sec:whitehead})。最后，我们简要总结了书中未包括的其他结果，例如 $n\ge 3$ 时的 $\pi_{n+1}(\Sn ^n)$，Blakers--Massey 定理，以及 Eilenberg--Mac Lane 空间的构造 (\cref{sec:moreresults})。本章的先决条件包括\cref{cha:typetheory,cha:basics,cha:hits,cha:hlevels} 以及\cref{cha:logic}的部分内容。

\index{fundamental!group!of circle|(}

\section{\texorpdfstring{$\pi_1(S^1)$}{π₁(S¹)}}
\label{sec:pi1-s1-intro}

在本节中，我们的目标是证明 $\id {\pi_1(\Sn ^1)} {\Z}$。
实际上，我们将证明环空间（loop space）${\Omega(\Sn ^1)}$ 等价于 $\Z$。
这是一个更强的陈述，因为根据定义，$\id{\pi_1(\Sn ^1)} {\trunc 0 {\Omega(\Sn ^1)}}$；因此，如果 $\id {\Omega(\Sn ^1)} {\Z}$，那么通过一致性，$\id {\trunc 0 {\Omega(\Sn ^1)}} {\trunc 0 {\Z}}$，并且 $\Z$ 根据定义是一个集合（作为一个集合商；参见 \cref{defn-Z,Z-quotient-by-canonical-representatives}），所以 $\id {\trunc 0 {\Z}} {\Z}$。
此外，知道 ${\Omega(\Sn ^1)}$ 是一个集合将意味着 $\pi_n(\Sn^1)$ 对于 $n>1$ 是平凡的，因此我们实际上计算了 \emph{所有} 的 $\Sn^1$ 的同伦群。

\subsection{开始 (Getting started)}
\label{sec:pi1s1-initial-thoughts}

定义 $\Omega(\Sn^1)$ 和 $\Z$ 之间双向的函数并不困难。
通过将 \cref{thm:looptothe} 专门化为 $\lloop:\base=\base$，我们得到了一个函数 $\lloop^{\blank} : \Z \rightarrow (\id{\base}{\base})$，它（粗略地说）定义如下：
\[
  \lloop^n =
  \begin{cases}
    \underbrace{\lloop \ct \lloop \ct \cdots \ct \lloop}_{n}  & \text{如果 $n > 0$,} \\
    \underbrace{\opp \lloop \ct \opp \lloop \ct \cdots \ct \opp \lloop}_{-n} & \text{如果 $n < 0$,} \\
    \refl{\base} & \text{如果 $n = 0$.}
  \end{cases}
\]
%
定义一个函数 $g:\Omega(\Sn^1)\to\Z$ 在另一个方向上有点棘手。
注意，后继函数 $\Zsuc:\Z\to\Z$ 是一个等价，
\index{successor!isomorphism on Z@isomorphism on $\Z$}%
因此在宇宙 \type 中诱导出一个路径 $\ua(\Zsuc):\Z=\Z$。
因此，$\Sn^1$ 的递归原理诱导出一个映射 $c:\Sn^1\to\type$，其中 $c(\base)\defeq \Z$，而 $\apfunc c (\lloop) \defid \ua(\Zsuc)$。
然后我们有 $\apfunc{c} : (\base=\base) \to (\Z=\Z)$，并且我们可以定义 $g(p)\defeq \transfib{X\mapsto X}{\apfunc{c}(p)}{0}$。

通过这些定义，我们甚至可以证明对于任何 $n:\Z$，$g(\lloop^n)=n$，使用 \cref{thm:sign-induction} 的归纳原理。
（我们稍后将证明更一般的情况。）
然而，另一个等式 $\lloop^{g(p)}=p$ 则要困难得多。
显而易见的方法是路径归纳，但路径归纳不适用于像 $p:(\base=\base)$ 这样具有 \emph{两端固定} 的环路！
需要一个新的想法，这可以用经典的同伦理论和类型理论来解释。
我们从前者开始。

\subsection{经典证明 (The classical proof)}
\label{sec:pi1s1-classical-proof}

\index{classical!homotopy theory|(}%
在经典同伦理论中，有一个标准证明 $\pi_1(\Sn^1)=\Z$ 使用了通用覆盖空间。
我们的证明可以看作是这个证明的类型理论版本，其中覆盖空间在这里出现为纤维，其纤维是集合。
\index{fibration}%
\index{total!space}%
回顾一下，在同伦理论中，某个空间 $B$ 上的纤维对应于类型理论中的类型族 $B\to\type$。
\index{path!fibration}%
\index{fibration!of paths}%
特别地，对于一个点 $x_0:B$，类型族 $(x\mapsto (x_0=x))$ 对应于 \emph{路径纤维} $P_{x_0} B \to B$，其中 $P_{x_0} B$ 的点是从 $x_0$ 开始的 $B$ 中的路径，映射到 $B$ 选择了这种路径的另一端点。
这个总空间 $P_{x_0} B$ 是可收缩的，因为我们可以“收缩”任何路径到其初始端点 $x_0$ ——我们已经看到了类型理论版本的这一点，如 \cref{thm:contr-paths}。
此外，$x_0$ 之上的纤维是环空间（loop space）$\Omega(B,x_0)$ —— 在类型理论中这是显而易见的，因为这是环空间的定义。

\begin{figure}\centering
\begin{tikzpicture}[xscale=1.4,yscale=.6]
  \node (R) at (2,1) {$\mathbb{R}$};
  \node (S1) at (2,-2) {$S^1$};
  \draw[->] (R) -- node[auto] {$w$} (S1);
  \draw (0,-2) ellipse (1 and .4);
  \draw[dotted] (1,0) arc (0:-30:1 and .8);
  \draw (1,0) arc (0:90:1 and .8) arc (90:270:1 and .3) coordinate (t1);
  \draw[white,line width=4pt] (t1) arc (-90:90:1 and .8);
  \draw (t1) arc (-90:90:1 and .8) arc (90:270:1 and .3) coordinate (t2);
  \draw[white,line width=4pt] (t2) arc (-90:90:1 and .8);
  \draw (t2) arc (-90:90:1 and .8) arc (90:270:1 and .3) coordinate (t3);
  \draw[white,line width=4pt] (t3) arc (-90:90:1 and .8);
  \draw (t3) arc (-90:-30:1 and .8) coordinate (t4);
  \draw[dotted] (t4) arc (-30:0:1 and .8);
  \node[fill,circle,inner sep=1pt,label={below:\scriptsize \base}] at (0,-2.4) {};
  \node[fill,circle,inner sep=1pt,label={above left:\scriptsize 0}] at (0,.2) {};
  \node[fill,circle,inner sep=1pt,label={above left:\scriptsize 1}] at (0,1.2) {};
  \node[fill,circle,inner sep=1pt,label={above left:\scriptsize 2}] at (0,2.2) {};
\end{tikzpicture}
\caption{经典拓扑中的绕线映射 (The winding map in classical topology)}\label{fig:winding}
\end{figure}

现在在经典同伦理论中，$\Sn^1$ 被视为一个拓扑空间，我们可以如下进行。
\index{winding!map}%
考虑“绕线”映射 $w:\mathbb{R}\to \Sn ^1$，它看起来像是一个螺旋线投影到圆上（见 \cref{fig:winding}）。
这个映射 $w$ 将螺旋线上每一点映射到它“坐在上面”的圆上的点。
它是一个纤维，并且每个点的纤维与整数（integers）同构。
如果我们提升底部逆时针绕过的路径，我们在螺旋线上升一个级别，增加纤维中的整数。
类似地，顺时针绕过底部的路径对应于在螺旋线上下降一级，减少这个计数。
这个纤维称为圆的\emph{通用覆盖}（universal cover）。
\index{universal!cover}%
\index{cover!universal}%
\index{covering space!universal}%

现在，经典同伦理论中的一个基本事实是 $E_1\to E_2$ 是 $B$ 上纤维之间的映射，它是 $E_1$ 和 $E_2$ 之间的同伦等价，因而在所有纤维上诱导同伦等价。
（我们已经在 \cref{thm:total-fiber-equiv} 中看到了类型理论版本的这个事实。）
因为 $\mathbb{R}$ 和 $P_{\base} S^1$ 都是可收缩的拓扑空间，所以它们是同伦等价的，因此它们在基点之上的纤维 $\Z$ 和 $\Omega(\Sn ^1)$ 也是同伦等价的。

\index{classical!homotopy theory|)}%

\subsection{类型理论中的通用覆盖 (The universal cover in type theory)}
\label{sec:pi1s1-universal-cover}

\index{universal!cover|(}%
\index{cover!universal|(}%
\index{covering space!universal|(}%

让我们考虑如何在类型理论中表达前面的证明。
我们已经提到 $\Sn^1$ 的路径纤维由类型族 $(x\mapsto (\base=x))$ 表示。
我们也已经看到了一个好的候选通用覆盖 $\Sn^1$：它正是我们在 \cref{sec:pi1s1-initial-thoughts} 中定义的类型族 $c:\Sn^1\to\type$！
根据定义，这个家族在 $\base$ 上的纤维是 $\Z$，而绕过 $\lloop$ 的运输效应是增加一个——因此它的行为正如我们从 \cref{fig:winding} 所预期的那样。

然而，由于我们还不知道这个家族的行为是否像一个通用覆盖应该有的那样（例如，它的总空间是否是简单连通的），我们为它使用了一个不同的名字。
因此，我们再次重复定义以供参考。
\index{integers}

\begin{defn}[Universal Cover of $\Sn^1$] \label{S1-universal-cover}
通过圆递归定义 $\code : \Sn ^1 \to \type$，其中
\begin{align*}
  \code(\base) &\defeq \Z \\
  \apfunc{\code}({\lloop}) &\defid \ua(\Zsuc)。
\end{align*}
\end{defn}

我们简要强调一下这个家族的定义，因为它与经典同伦理论中通常定义覆盖空间的方式是如此不同。
要通过圆递归定义一个函数，我们需要在余码中找到一个点和一个环。
在这种情况下，余码是 $\type$，我们选择的点是 $\Z$，对应于我们期望的通用覆盖的纤维应该是整数。
我们选择的环是后继/前驱（successor/predecessor）
\index{successor!isomorphism on Z@isomorphism on $\Z$}%
\index{predecessor!isomorphism on Z@isomorphism on $\Z$}%
的同构， 它对应于基座上的环绕上升一级的事实。
在这一部分的证明中，等价性是必要的，因为我们需要将 $\Z$ 上的一个 \emph{非平凡} 等价转换为一个恒等式。

我们称这个纤维为“代码”（codes）的纤维，因为它的元素是组合数据，这些数据充当圆上路径的代码：整数 $n$ 为路径编码，该路径在圆上绕行 $n$ 次。

通过这个定义，很容易计算出使用 $\code$ 的运输会将 $\lloop$ 转换为后继函数，将 $\opp{\lloop}$ 转换为前驱函数：
\begin{lem} \label{lem:transport-s1-code}
\id{\transfib \code \lloop x} {x + 1} 和
\id{\transfib \code {\opp \lloop} x} {x - 1}。
\end{lem}
\begin{proof}
  对于第一个等式，我们按如下方式计算：
  \begin{align}
  {\transfib \code \lloop x}
    &= \transfib {A \mapsto A} {(\ap{\code}{\lloop})} x \tag{依据 \cref{thm:transport-compose}}\\
    &= \transfib {A \mapsto A} {\ua (\Zsuc)} x \tag{计算 \rec{\Sn^1}}\\
    &= x + 1 \tag{依据 \ua 的计算结果}。
  \end{align}
  第二个等式由第一个得出，因为 $\transfib{B}{p}{\blank}$ 和 $\transfib{B}{\opp p}{\blank}$ 总是相互逆转，因此 $\transfib\code {\opp \lloop}{\blank}$ 必须是 $\Zsuc$ 的逆函数。
\end{proof}

我们现在可以看到我们第一个方法的错误之处：我们仅在纤维 $\Omega(\Sn^1)$ 和 $\Z$ 上定义了 $f$ 和 $g$，而我们应该定义一个整个纤维上的态射（morphism）。
在类型理论中，这意味着我们应该定义具有以下类型的函数
\begin{align}
  \prd{x:\Sn^1} &((\base=x) \to \code(x)) \qquad\text{和/或} \label{eq:pi1s1-encode}\\
  \prd{x:\Sn^1} &(\code(x) \to (\base=x))\label{eq:pi1s1-decode}
\end{align}
而不仅仅是在 $x$ 为 \base 时的特殊情况。
这也是类型理论中常见的观察的一个例子：当尝试证明某些归纳类型的特定居民时，通常更容易将陈述泛化，使其涉及 \emph{所有} 此类类型的居民，然后我们可以通过归纳证明。
从这个角度来看，$\Omega(\Sn^1)=\Z$ 的证明符合与在 \cref{sec:compute-coprod,sec:compute-nat} 中的共产品和自然数的恒等类型的特征化相同的模式。

在这一点上，有两种方法可以完成证明。
我们可以继续模仿经典论证，构造~\eqref{eq:pi1s1-encode} 或~\eqref{eq:pi1s1-decode}（无论哪种都可以），证明总空间之间的同伦等价诱导纤维上的等价，然后证明通用覆盖的总空间是可收缩的。
$\Omega(\Sn^1)=\Z$ 的第一个类型论证遵循了这一模式；我们称之为 \emph{同伦理论} 证明。

然而，后来我们发现有一个替代的证明，它更具类型理论的感觉，更接近于 \cref{sec:compute-coprod,sec:compute-nat} 中的证明。
在这个证明中，我们直接构造了~\eqref{eq:pi1s1-encode} 和~\eqref{eq:pi1s1-decode}，并通过计算证明它们是互逆的。
我们称之为 \emph{编码-解码} 证明（encode-decode proof），因为我们将函数~\eqref{eq:pi1s1-encode} 和~\eqref{eq:pi1s1-decode} 分别称为 \emph{编码} 和 \emph{解码}。
两个证明都使用了上面给出的相同的覆盖结构。
在经典证明中，从总空间的等价诱导出纤维上的等价，而编码-解码证明则明确地构造了一个作为纤维之间映射的逆映射（\emph{解码}）。
在经典证明中使用了可收缩性，而在编码-解码证明中使用了路径归纳、圆归纳和整数归纳。
这些是用于证明可收缩性的相同工具——实际上，路径归纳 \emph{本质上} 是与 $\mathsf{transport}$ 组合的路径纤维的可收缩性——但它们以不同的方式应用。

由于这是一本关于同伦类型论的书，我们首先介绍编码-解码证明。
如果一个同伦理论者感到困惑，建议跳到同伦理论证明（\cref{subsec:pi1s1-homotopy-theory}）。

\index{universal!cover|)}%
\index{cover!universal|)}%
\index{covering space!universal|)}%

\subsection{编码-解码证明 (The encode-decode proof)}
\label{subsec:pi1s1-encode-decode}

\index{encode-decode method|(}%
\indexsee{encode}{encode-decode method}%
\indexsee{decode}{encode-decode method}%
我们首先介绍将路径映射到代码的函数~\eqref{eq:pi1s1-encode}：
\begin{defn}
  定义 $\encode : \prd{x : \Sn ^1} (\base=x) \rightarrow  \code(x)$，其中
  \[
    \encode \: p \defeq \transfib{\code} p 0
  \]
  （我们省略了参数 $x$）。
\end{defn}
编码是通过提升路径到通用覆盖中定义的，这确定了一个等价性，然后将结果等价性应用于 $0$。
这个函数有趣的地方在于，它从圆上的环上计算出一个具体的数字，而这个环是使用同伦类型论的抽象群结构表示的。
为了获得关于它如何做到这一点的直观理解，请注意，依据上面的引理，$\transfib \code \lloop x$ 是后继函数，而 $\transfib \code {\opp\lloop} x$ 是前驱函数。
此外，$\mathsf{transport}$ 是函子性的（\cref{cha:basics}），所以 $\transfib{\code} {\lloop \ct \lloop}{\blank}$ 是
\[(\transfib \code \lloop-) \circ (\transfib \code \lloop-)\]
依此类推。
因此，当 $p$ 是像
\[
  \lloop \ct \opp \lloop \ct \lloop \ct \cdots
\]
这样的组合时，$\transfib{\code}{p}{\blank}$ 将计算一个类似于
\[
  \Zsuc \circ \Zpred \circ \Zsuc \circ \cdots
\]
的函数组合。
将这个函数组合应用于 $0$ 将计算路径的\emph{绕线数}（winding number）——路径绕过圆的次数，在逆转被取消之后，标志其方向是正还是负。
因此，$\encode$ 的计算行为来自于高级归纳类型和等价性的简化规则，以及 $\mathsf{transport}$ 在组合和逆上的作用。

请注意，实例 $\encode' \defeq \encode_{\base}$ 的类型为 $(\id \base \base) \rightarrow \Z$。
这将是我们所需等价的一个部分；实际上，它正是我们在 \cref{sec:pi1s1-initial-thoughts} 中定义的函数 $g$。

类似地，函数~\eqref{eq:pi1s1-decode} 是 \cref{sec:pi1s1-initial-thoughts} 中函数 $\lloop^{\blank}$ 的推广。

\begin{defn}\label{thm:pi1s1-decode}
通过圆归纳（circle induction）在 $x$ 上定义 $\decode : \prd{x : \Sn ^1}\code(x) \rightarrow (\base=x)$。
它足以给出一个函数 ${\code(\base) \rightarrow (\base=\base)}$，我们使用 $\lloop^{\blank}$，并展示 $\lloop^{\blank}$ 是如何尊重这个环的。
\end{defn}

\begin{proof}
  要展示 $\lloop^{\blank}$ 是如何尊重这个环的，足以给出一个从 $\lloop^{\blank}$ 到它本身的路径，该路径位于 $\lloop$ 之上。
  依据依赖路径的定义，这意味着一个路径从
  \[\transfib {(x' \mapsto \code(x') \rightarrow (\base=x'))} {\lloop} {\lloop^{\blank}}\]
  到 $\lloop^{\blank}$。
  我们定义这样的路径如下：
  \begin{align*}
    \MoveEqLeft \transfib {(x' \mapsto \code(x') \rightarrow (\base=x'))} \lloop {\lloop^{\blank}}\\
    &= \transfibf {x'\mapsto (\base=x')}(\lloop) \circ {\lloop^{\blank}} \circ \transfibf \code ({\opp \lloop}) \\
    &= (- \ct \lloop) \circ (\lloop^{\blank}) \circ \transfibf \code ({\opp \lloop}) \\
    &= (- \ct \lloop) \circ (\lloop^{\blank}) \circ \Zpred \\
    &= (n \mapsto \lloop^{n - 1} \ct \lloop)。
  \end{align*}
  在第一行中，我们应用了 $\mathsf{transport}$ 的特征，当纤维的外连接是 $\rightarrow$ 时，这将 $\mathsf{transport}$ 简化为在域和余域类型上与 $\mathsf{transport}$ 的预组合和后组合。
  在第二行中，我们应用了 $\mathsf{transport}$ 的特征，当类型族是 $x\mapsto \id{\base}{x}$ 时，这是路径的后组合。
  在第三行中，我们使用了 \cref{lem:transport-s1-code} 中 $\code$ 对 $\opp \lloop$ 的作用。
  在第四行中，我们只是简化了函数组合。
  因此，足以证明对于所有 $n$，$\id{\lloop^{n - 1} \ct \lloop}{\lloop^{n}}$。
  这是 \cref{thm:sign-induction} 的一个简单应用，使用了群论的法则。
\end{proof}

我们现在可以展示 $\encode$ 和 $\decode$ 是准逆的。
以前困难的方向现在变得容易了！

\begin{lem} \label{lem:s1-decode-encode}
对于所有 $x: \Sn ^1$ 和 $p : \id \base x$，$\id
{\decode_x({{\encode_x(p)}})} p$。
\end{lem}

\begin{proof}
  通过路径归纳（path induction），足以证明
  \narrowequation{\id {\decode_{\base}({{\encode_{\base}(\refl{\base})}})} {\refl{\base}}。}
  但
  \narrowequation{\encode_{\base}(\refl{\base}) \jdeq \transfib{\code}{\refl{\base}} 0 \jdeq 0，}
  且 $\decode_{\base}(0) \jdeq \lloop^ 0 \jdeq \refl{\base}$。
\end{proof}

另一个方向并不困难。

\begin{lem} \label{lem:s1-encode-decode} 对于所有
$x: \Sn ^1$ 和 $c : \code(x)$，我们有 $\id
{\encode_x({{\decode_x(c)}})} c$。
\end{lem}

\begin{proof}
  证明是通过圆归纳（circle induction）进行的。
  足以证明 \base 的情况，因为 \lloop 的情况是 $\Z$ 中路径之间的路径，这很简单，因为 $\Z$ 是一个集合。

  因此，足以证明，对于所有 $n : \Z$，
  \[
    \id {\encode'(\lloop^n)} {n}。
  \]
  证明是通过使用 \cref{thm:sign-induction} 的归纳进行的。
%
  \begin{itemize}

    \item 对于 $0$ 的情况，结果根据定义为真。

    \item 对于 $n+1$ 的情况，
    \begin{align}
    {\encode'(\lloop^{n+1})}
      &= {\encode'(\lloop^{n} \ct \lloop)} \tag{依据 $\lloop^{\blank}$ 的定义} \\
      &= \transfib{\code}{(\lloop^{n} \ct \lloop)}{0} \tag{依据 $\encode$ 的定义}\\
      &= \transfib{\code}{\lloop}{(\transfib{\code}{\lloop^n}{0})} \tag{依据函子性}\\
      &= {(\transfib{\code}{\lloop^n}{0})} + 1 \tag{依据 \cref{lem:transport-s1-code}}\\
      &= n + 1。 \tag{依据归纳假设}
    \end{align}

    \item 负数的情况是类似的。  \qedhere
  \end{itemize}
\end{proof}

最后，我们总结定理。

\begin{thm}
  存在一个等价的族 $\prd{x : \Sn ^1} (\eqv {(\base=x)} {\code(x)})$。
\end{thm}
\begin{proof}
  $\encode$ 和 $\decode$ 是准逆的，通过
  \cref{lem:s1-decode-encode,lem:s1-encode-decode}。
\end{proof}

在 \base 实例化给出
\begin{cor}\label{cor:omega-s1}
$\eqv {\Omega(\Sn^1,\base)} {\Z}$。
\end{cor}

一个简单的归纳表明，这个等价性将加法带入组合，因此 $\Omega(\Sn ^1) = \Z$ 作为群体。

\begin{cor} \label{cor:pi1s1}
$\id{\pi_1(\Sn ^1)} {\Z}$，而 $\id{\pi_n(\Sn ^1)}0$ 对于 $n>1$。
\end{cor}
\begin{proof}
  对于 $n=1$，我们在 \cref{cor:omega-s1} 中概述了证明。
  对于 $n > 1$，我们有 $\trunc 0 {\Omega^{n}(\Sn ^1)} = \trunc 0 {\Omega^{n-1}(\Omega{\Sn ^1})} = \trunc 0 {\Omega^{n-1}(\Z)}$。
  由于 $\Z$ 是一个集合，$\Omega^{n-1}(\Z)$ 是可收缩的，因此这是平凡的。
\end{proof}

\index{encode-decode method|)}%

\subsection{同伦理论的证明 (The homotopy-theoretic proof)}
\label{subsec:pi1s1-homotopy-theory}

在 \cref{sec:pi1s1-universal-cover} 中，我们在类型理论中定义了推测的通用覆盖 $\code:\Sn^1\to\type$，并在 \cref{subsec:pi1s1-encode-decode} 中定义了从路径纤维到通用覆盖的映射 $\encode : \prd{x:\Sn^1} (\base=x) \to \code(x)$。
经典证明剩下的内容是证明这个映射在总空间上诱导等价，因为两者都是可收缩的，并从中推导出它在每个纤维上的等价。

\index{total!space}%
在 \cref{thm:contr-paths} 中，我们看到总空间 $\sm{x:\Sn^1} (\base=x)$ 是可收缩的。
对于另一个，我们有：

\begin{lem}\label{thm:iscontr-s1cover}
类型 $\sm{x:\Sn^1}\code(x)$ 是可收缩的。
\end{lem}
\begin{proof}
  我们应用 \cref{thm:flattening} 中的展平引理（flattening lemma），使用以下值：
  \begin{itemize}
    \item $A\defeq\unit$ 和 $B\defeq\unit$，$f$ 和 $g$ 是显然的函数。
    因此，展平引理中的基高阶归纳类型 $W$ 等价于 $\Sn^1$。
    \item $C:A\to\type$ 是常数 $\Z$。
    \item $D:\prd{b:B} (\eqv{\Z}{\Z})$ 是常数 $\Zsuc$。
  \end{itemize}
  然后，展平引理中定义的类型族 $P:\Sn^1\to\type$ 等价于 $\code:\Sn^1\to\type$。
  因此，展平引理告诉我们，$\sm{x:\Sn^1}\code(x)$ 等价于一个具有以下生成器的高阶归纳类型，我们将其标记为 $R$：
  \begin{itemize}
    \item 一个函数 $\mathsf{c}: \Z \to R$。
    \item 对于每个 $z:\Z$，一个路径 $\mathsf{p}_z:\mathsf{c}(z) = \mathsf{c}(\Zsuc(z))$。
  \end{itemize}
  我们可以称这个类型为\define{同伦实数}（homotopical reals）；
  \indexdef{real numbers!homotopical}%
  它与经典证明中的拓扑空间 $\mathbb{R}$ 起着相同的作用。

  因此，剩下的就是证明 $R$ 是可收缩的。
  作为收缩的中心，我们选择 $\mathsf{c}(0)$；我们现在必须证明 $x=\mathsf{c}(0)$ 对于所有 $x:R$。
  我们通过在 $R$ 上的归纳来做到这一点。
  首先，当 $x$ 是 $\mathsf{c}(z)$ 时，我们必须给出一个路径 $q_z:\mathsf{c}(0) = \mathsf{c}(z)$，我们可以通过对 $z:\Z$ 的归纳来做到这一点，使用 \cref{thm:sign-induction}：
  \begin{align*}
    q_0 &\defid \refl{\mathsf{c}(0)}\\
    q_{n+1} &\defid q_n \ct \mathsf{p}_n & &\text{对于 $n\ge 0$}\\
    q_{n-1} &\defid q_n \ct \opp{\mathsf{p}_{n-1}} & &\text{对于 $n\le 0$}。
  \end{align*}
  其次，我们必须证明对于任何 $z:\Z$，路径 $q_z$ 在 $\mathsf{p}_z$ 上的运输是 $q_{z+1}$。
  通过路径的运输，这意味着我们需要 $q_z \ct \mathsf{p}_z = q_{z+1}$。
  这通过 $z$ 的归纳很容易做到，使用 $q_z$ 的定义。
  这完成了 $R$ 是可收缩的证明，因此 $\sm{x:\Sn^1}\code(x)$ 也是可收缩的。
\end{proof}

\begin{cor}\label{thm:encode-total-equiv}
由 \encode 诱导的映射：
\[ \tsm{x:\Sn^1} (\base=x) \to \tsm{x:\Sn^1}\code(x) \]
是一个等价。
\end{cor}
\begin{proof}
  两种类型都是可收缩的。
\end{proof}

\begin{thm}
  $\eqv {\Omega(\Sn^1,\base)} {\Z}$。
\end{thm}
\begin{proof}
  将 \cref{thm:total-fiber-equiv} 应用于 $\encode$，使用 \cref{thm:encode-total-equiv}。
\end{proof}

本质上，这两个证明没有太大不同：编码-解码的证明可以看作是同伦理论证明的“简化”或“解包”。
每个都有其优势；两者之间的相互作用是该主题的一部分兴趣所在。
\index{fundamental!group!of circle|)}

\subsection{通用覆盖作为恒等系统 (The universal cover as an identity system)}
\label{sec:pi1s1-idsys}

请注意，纤维 $\code:\Sn^1\to\type$ 与 $0:\code(\base)$ 一起是 \cref{defn:identity-systems} 中所述的\emph{指向谓词}（pointed predicate）。
从这个角度来看，我们可以看到，在 \cref{subsec:pi1s1-encode-decode} 中的编码-解码证明由证明 \code 满足 \cref{thm:identity-systems}\ref{item:identity-systems3} 组成，而在 \cref{subsec:pi1s1-homotopy-theory} 中的同伦理论证明则由证明它满足 \cref{thm:identity-systems}\ref{item:identity-systems4} 组成。
这暗示了一种第三种方法。

\begin{thm}
  对于 $\base:\Sn^1$，对偶 $(\code,0)$ 是 \cref{defn:identity-systems} 中所定义的恒等系统（identity system）。
\end{thm}
\begin{proof}
  令 $D:\prd{x:\Sn^1} \code(x) \to \type$ 和 $d:D(\base,0)$ 已给出；我们要定义一个函数 $f:\prd{x:\Sn^1}{c:\code(x)} D(x,c)$。
  通过圆归纳，足以指定 $f(\base):\prd{c:\code(\base)} D(\base,c)$ 并验证 $\trans{\lloop}{f(\base)} = f(\base)$。

  当然，$\code(\base)\jdeq \Z$。
  通过 \cref{lem:transport-s1-code} 和对 $n$ 的归纳，我们可以为任何整数 $n$ 获得一个路径 $p_n : \transfib{\code}{\lloop^n}{0} = n$。
  因此，通过 $\Sigma$-类型的路径，我们在 $\sm{x:\Sn^1} \code(x)$ 中有一个路径 $\pairpath(\lloop^n,p_n) : (\base,0) = (\base,n)$。
  在与 $D$ 相关联的纤维 $\widehat{D}:(\sm{x:\Sn^1} \code(x)) \to\type$ 中沿着这个路径运输 $d$，我们获得 $D(\base,n)$ 的一个元素。
  我们定义这个元素为 $f(\base)(n)$：
  \[ f(\base)(n) \defeq \transfib{\widehat{D}}{\pairpath(\lloop^n,p_n)}{d}。 \]
  %
  现在我们需要 $\transfib{\lam{x} \prd{c:\code(x)} D(x,c)}{\lloop}{f(\base)} = f(\base)$。
  通过 \cref{thm:dpath-forall}，这意味着我们需要证明对于任何 $n:\Z$，
  %
  \begin{narrowmultline*}
    \transfib{\widehat D}{\pairpath(\lloop,\refl{\trans\lloop n})}{f(\base)(n)}
    =_{D(\base,\trans\lloop n)} \narrowbreak
    f(\base)(\trans\lloop n)。
  \end{narrowmultline*}
  %
  现在我们有一个路径 $q:\trans\lloop n = n+1$，所以沿着这个路径运输，足以证明
  \begin{multline*}
    \transfib{D(\base)}{q}{\transfib{\widehat D}{\pairpath(\lloop,\refl{\trans\lloop n})}{f(\base)(n)}}\\
    =_{D(\base,n+1)} \transfib{D(\base)}{q}{f(\base)(\trans\lloop n)}。
  \end{multline*}
  通过关于运输和依赖应用的几个引理，这等效于
  \[ \transfib{\widehat D}{\pairpath(\lloop,q)}{f(\base)(n)} =_{D(\base,n+1)} f(\base)(n+1)。 \]
  然而，展开 $f(\base)$ 的定义，我们有
  \begin{narrowmultline*}
    \transfib{\widehat D}{\pairpath(\lloop,q)}{f(\base)(n)}
    \narrowbreak
    \begin{aligned}[t]
      &= \transfib{\widehat D}{\pairpath(\lloop,q)}{\transfib{\widehat{D}}{\pairpath(\lloop^n,p_n)}{d}}\\
      &= \transfib{\widehat D}{\pairpath(\lloop^n,p_n) \ct \pairpath(\lloop,q)}{d}\\
      &= \transfib{\widehat D}{\pairpath(\lloop^{n+1},p_{n+1})}{d}\\
      &= f(\base)(n+1)。
    \end{aligned}
  \end{narrowmultline*}
  我们使用了运输的函子性，$\Sigma$-类型中的组合的特征（这是读者的练习），以及一个将 $p_n$ 和 $q$ 关联到 $p_{n+1}$ 的引理，我们将留给读者陈述和证明。

  这完成了函数 $f:\prd{x:\Sn^1}{c:\code(x)} D(x,c)$ 的构造。
  由于
  \[f(\base,0) \jdeq \trans{\pairpath(\lloop^0,p_0)}{d} = \trans{\refl{\base}}{d} = d，\]
  我们已经证明了 $(\code,0)$ 是一个恒等系统。
\end{proof}

\begin{cor}
  对于任何 $x:\Sn^1$，我们有 $\eqv{(\base=x)}{\code(x)}$。
\end{cor}
\begin{proof}
  通过 \cref{thm:identity-systems}。
\end{proof}

当然，这个证明也包含了前两个证明的基本元素。
大致上，我们可以说它统一了 \cref{thm:pi1s1-decode,lem:s1-encode-decode} 的证明，在一般情况下只执行一次所需的归纳论证。

\begin{rmk}
  请注意，所有上述证明 $\eqv{\pi_1(\Sn^1)}{\Z}$ 都在本质上使用了等价性公理。
  这是不可避免的：等价性或类似的东西是\emph{必要的}，以证明 $\eqv{\pi_1(\Sn^1)}{\Z}$。
  在没有等价性的情况下，可以假设“所有类型都是集合”的陈述（又称为“恒等证明的唯一性”或“Axiom K”，如 \cref{sec:hedberg} 中讨论的），该陈述则意味着 $\eqv{\pi_1(\Sn^1)}{\unit}$。
  实际上，$\pi_1(\Sn^1)$ 的（非）平凡性正好检测所有类型是否为集合：\cref{thm:loop-nontrivial} 的证明反过来表明，如果 $\lloop=\refl{\base}$，则所有类型都是集合。
\end{rmk}

\section{悬挂的连通性 (Connectedness of suspensions)}
\label{sec:conn-susp}

回顾在 \cref{sec:connectivity} 中提到的，如果一个类型 $A$ 被称为 \define{$n$-连通的 ($n$-connected)}，则 $\trunc nA$ 是可收缩的 (contractible)。
本节的目的是证明悬挂操作 (suspension operation) 会增加连通性，如 \cref{sec:suspension} 中所述。

\begin{thm} \label{thm:suspension-increases-connectedness}
如果 $A$ 是 $n$-连通的，那么 $A$ 的悬挂 (suspension) 是 $(n+1)$-连通的。
\end{thm}

\begin{proof}
  我们在 \cref{sec:colimits} 中提到，$A$ 的悬挂是推挤 (pushout) $\unit\sqcup^A\unit$，因此我们需要证明以下类型是可收缩的：
  %
  \[\trunc{n+1}{\unit\sqcup^A\unit}。\]
  %
  根据 \cref{reflectcommutespushout}，我们知道 $\trunc{n+1}{\unit\sqcup^A\unit}$ 是 $\typelep{n+1}$ 中以下图表的推挤：
  \[\xymatrix{\trunc{n+1}A \ar[d] \ar[r] & \trunc{n+1}{\unit} \\
  \trunc{n+1}{\unit} & }。\]
  %
  鉴于 $\trunc{n+1}{\unit}=\unit$，$\trunc{n+1}{\unit\sqcup^A\unit}$ 的类型在 $\typelep{n+1}$ 中也是以下图表的推挤（因为两个图表是相等的）：
  %
  \[\Ddiag=\vcenter{\xymatrix{\trunc{n+1}A \ar[d] \ar[r] & \unit \\
  \unit & }}。\]
  %
  我们现在将证明在 $\typelep{n+1}$ 中 $\unit$ 也是 $\Ddiag$ 的推挤。
  %
  设 $E$ 是一个 $(n+1)$-截断的类型；我们需要证明以下映射是一个等价 (equivalence)：
  %
  \[\function{(\unit \to E)}{\cocone{\Ddiag}{E}}{y}
  {(y,y,\lamu{u:{\trunc{n+1}A}} \refl{y(\ttt)})}。\]
  %
  我们回顾一下，$\cocone{\Ddiag}{E}$ 是以下类型：
  \[\sm{f:\unit \to E}{g:\unit \to E}(\trunc{n+1}A\to
  (f(\ttt)=_E{}g(\ttt)))。\]
  %
  映射 $\function{(\unit\to E)}{E}{f}{f(\ttt)}$ 是一个等价映射，因此我们也有
  \[\cocone{\Ddiag}{E}=\sm{x:E}{y:E}(\trunc{n+1}A\to(x=_Ey))。\]
  %
  现在 $A$ 是 $n$-连通的，因此 $\trunc{n+1}A$ 也是 $n$-连通的，因为 $\trunc n{\trunc{n+1}A}=\trunc nA=\unit$，而 $(x=_Ey)$ 是 $n$-截断的，因为 $E$ 是 $(n+1)$-截断的。因此，根据 \cref{connectedtotruncated}，以下映射是一个等价映射：
  %
  \[\function{(x=_Ey)}{(\trunc{n+1}A\to(x=_Ey))}{p}{\lam{z} p}\]
  %
  因此我们有
  %
  \[\cocone{\Ddiag}{E}=\sm{x:E}{y:E}(x=_Ey)。\]
  %
  但是以下映射是一个等价映射：
  %
  \[\function{E}{\sm{x:E}{y:E}(x=_Ey)}{x}{(x,x,\refl{x})}。\]
  %
  因此
  %
  \[\cocone{\Ddiag}{E}=E。\]
  %
  最后我们得到一个等价映射
  %
  \[(\unit \to E)\eqvsym\cocone{\Ddiag}{E}\]
  %
  我们现在可以展开定义以得到此映射的明确表达式，并且我们可以轻松地看到，这正是我们在开始时所得到的映射。

  因此我们证明了 $\unit$ 是 $\typelep{n+1}$ 中 $\Ddiag$ 的推挤。使用推挤的唯一性，我们得到 $\trunc{n+1}{\unit\sqcup^A\unit}=\unit$，这证明了 $A$ 的悬挂是 $(n+1)$-连通的。
\end{proof}

\begin{cor} \label{cor:sn-connected}
对于所有 $n:\N$，球体 $\Sn^n$ 是 $(n-1)$-连通的。
\end{cor}

\begin{proof}
  我们通过归纳法证明这一点。
  %
  对于 $n=0$，我们必须证明 $\Sn^0$ 仅仅是居住的 (inhabited)，这是显然的。
  %
  设 $n:\N$ 使得 $\Sn^n$ 是 $(n-1)$-连通的。根据定义，$\Sn^{n+1}$ 是 $\Sn^n$ 的悬挂，因此根据前面的引理，$\Sn^{n+1}$ 是 $n$-连通的。
\end{proof}

\section{\texorpdfstring{$n$-连通空间和 \texorpdfstring{$\pi_{k < n}(\Sn ^n)$}{π\_(k<n)(Sⁿ)} 的 \texorpdfstring{$\pi_{k \le n}$}{π\_(k≤n)}}
\label{sec:pik-le-n}

设 $(A,a)$ 是一个有基点的类型 (pointed type)，$n:\N$。回顾在 \cref{thm:homotopy-groups} 中提到的，如果 $n>0$，则集合 $\pi_n(A,a)$ 具有群结构 (group structure)，如果 $n>1$，则该群是阿贝尔群 (abelian group)\index{group!abelian}。

我们现在可以讨论 $n$-截断类型 (n-truncated type) 和 $n$-连通类型的同伦群 (homotopy groups)。

\begin{lem}
  如果 $A$ 是 $n$-截断的并且 $a:A$，那么对于所有 $k>n$，$\pi_k(A,a)=\unit$。
\end{lem}

\begin{proof}
  $n$-类型的环空间 (loop space) 是一个 $(n-1)$-类型，因此 $\Omega^k(A,a)$ 是一个 $(n-k)$-类型，并且我们有 $(n-k)\le-1$，所以 $\Omega^k(A,a)$ 是一个单纯命题 (mere proposition)。但是 $\Omega^k(A,a)$ 是居住的，因此它实际上是可收缩的，$\pi_k(A,a)=\trunc0{\Omega^k(A,a)}=\trunc0{\unit}=\unit$。
\end{proof}

\begin{lem} \label{lem:pik-nconnected}
如果 $A$ 是 $n$-连通的并且 $a:A$，那么对于所有 $k\le{}n$，$\pi_k(A,a)=\unit$。
\end{lem}

\begin{proof}
  我们有以下等式序列：
  %
  \begin{narrowmultline*}
    \pi_k(A,a) = \trunc0{\Omega^k(A,a)}
    = \Omega^k(\trunc k{(A,a)})
    = \Omega^k(\trunc k{\trunc n{(A,a)}})
    = \narrowbreak
    \Omega^k(\trunc k{\unit})
    = \Omega^k(\unit)
    = \unit。
  \end{narrowmultline*}
  %
  第三个等式使用了 $k\le{}n$ 的事实，以便使用 $\truncf k\circ\truncf n=\truncf k$，第四个等式使用了 $A$ 是 $n$-连通的事实。
\end{proof}

\begin{cor}
  对于 $k < n$，$\pi_k(\Sn ^n) = \unit$。
\end{cor}
\begin{proof}
  根据 \cref{cor:sn-connected}，球体 $\Sn^n$ 是 $(n-1)$-连通的，因此我们可以应用 \cref{lem:pik-nconnected}。
\end{proof}

\section{纤维序列和长确界序列 (Fiber sequences and the long exact sequence)}
\label{sec:long-exact-sequence-homotopy-groups}

\index{fiber sequence|(}%
\index{sequence!fiber|(}%

如果一个函数 $f:X\to Y$ 的余域 (codomain) 装备了一个基点 $y_0:Y$，那么我们称 $f$ 在 $y_0$ 上的纤维 $F\defeq \hfib f {y_0}$ 为 \define{函数 $f$ 的纤维 (the fiber of $f$)}\index{fiber}。
（如果 $Y$ 是连通的，那么 $F$ 是仅凭等价确定的 (determined up to mere equivalence)；参见 \cref{ex:unique-fiber}。）
我们现在表明，如果 $X$ 也是有基点的，并且 $f$ 保持基点，那么 $F$、$X$ 和 $Y$ 的同伦群之间存在一个长确界序列 (long exact sequence) 的关系。
我们通过与这样的 $f$ 相关联的纤维序列 (fiber sequence) 来推导这一点。

\begin{defn}\label{def:pointedmap}
有基点类型 $(X,x_0)$ 和 $(Y,y_0)$ 之间的一个 \define{有基点映射 (pointed map)}\index{pointed!map}%
\indexsee{function!pointed}{pointed map} 是一个映射 $f:X\to Y$ 以及一个路径 $f_0:f(x_0)=y_0$。
\end{defn}

对于任何有基点类型 $(X,x_0)$ 和 $(Y,y_0)$，存在一个有基点映射 $(\lam{x} y_0) : X\to Y$，它在基点处是常值的 (constant)。
我们将此称为 \define{零映射 (zero map)}\index{zero!map}\index{function!zero} 并有时将其记作 $0:X\to Y$。

回顾一下，每个有基点类型 $(X,x_0)$ 都有一个环空间 (loop space)\index{loop space} $\Omega (X,x_0)$。
我们现在注意到，该操作在有基点映射上是函子性的 (functorial)。\index{loop space!functoriality of}\index{functor!loop space}

\begin{defn}\label{def:loopfunctor}
给定有基点类型之间的一个有基点映射 $f:X \to Y$，我们定义有基点映射 $\Omega f:\Omega X
\to \Omega Y$ 如下：
\[(\Omega f)(p) \defeq \rev{f_0}\ct\ap{f}{p}\ct f_0。\]
路径 $(\Omega f)_0 : (\Omega f) (\refl{x_0}) = \refl{y_0}$，它展示了 $\Omega f$ 作为有基点映射，是以下类型的显然路径：
\[\rev{f_0}\ct\ap{f}{\refl{x_0}}\ct f_0=\refl{y_0}。\]
\end{defn}

在有基点映射上还有另一个函子，它将 $f:X\to Y$ 映射到 $\proj1 : \hfib f {y_0} \to X$。
当 $f$ 是有基点映射时，我们总是认为 $\hfib f {y_0}$ 是有基点的，其基点是 $(x_0,f_0)$，在这种情况下，$\proj1$ 也是一个有基点映射，其见证 (witness) 是 $(\proj1)_0 \defeq \refl{x_0}$。
因此，此操作可以迭代。

\begin{defn}
  一个有基点映射 $f:X\to Y$ 的 \define{纤维序列 (fiber sequence)}\index{fiber sequence}%
  \index{sequence!fiber} 是以下无限序列的有基点类型和有基点映射：
  \[\xymatrix{\dots \ar[r]^{f^{(n+1)}} & X^{(n+1)} \ar[r]^{f^{(n)}} & X^{(n)} \ar^-{f^{(n-1)}}[r] & \dots \ar[r] & X^{(2)} \ar^-{f^{(1)}}[r] & X^{(1)} \ar[r]^{f^{(0)}} & X^{(0)}}\]
  该序列递归地定义为
  \[ X^{(0)} \defeq Y\qquad
  X^{(1)} \defeq X\qquad
  f^{(0)} \defeq f\qquad
  \]
  以及
  \begin{alignat*}{2}
    X^{(n+1)} &\defeq \hfib {f^{(n-1)}}{x^{(n-1)}_0}\\
    f^{(n)} &\defeq \proj1 &: X^{(n+1)} \to X^{(n)}。
  \end{alignat*}
  其中 $x^{(n)}_0$ 表示 $X^{(n)}$ 的基点，如上所述递归选择。
\end{defn}

因此，此纤维序列中的任何相邻的映射对都具有以下形式：
\[ \xymatrix{ X^{(n+1)} \jdeq \hfib{f^{(n-1)}}{x^{(n-1)}_0} \ar[rr]^-{f^{(n)}\jdeq \proj1} && X^{(n)} \ar[r]^{f^{(n-1)}} & X^{(n-1)}。} \]
特别是，我们有 $f^{(n-1)} \circ f^{(n)} = 0$。
我们现在注意到，在此序列中出现的类型是基空间 $Y$ 的迭代环空间\index{loop space!iterated}、总空间\index{total!space} $X$ 和纤维 $F\defeq \hfib f {y_0}$，映射也是如此。

\begin{lem}\label{thm:fiber-of-the-fiber}
设 $f:X\to Y$ 是有基点空间的有基点映射。那么：
\begin{enumerate}
  \item $f^{(1)}\defeq \proj1 : \hfib f {y_0} \to X$ 的纤维是与 $\Omega Y$ 等价的。\label{item:fibseq1}
  \item 类似地，$f^{(2)} : \Omega Y \to \hfib f {y_0}$ 的纤维是与 $\Omega X$ 等价的。\label{item:fibseq2}
  \item 在这些等价的情况下，有基点映射 $f^{(3)} : \Omega X\to \Omega Y$ 与有基点映射 $\Omega f\circ\rev{(\blank)}$ 是一致的。\label{item:fibseq3}
\end{enumerate}
\end{lem}
\begin{proof}
  对于~\ref{item:fibseq1}，我们有
  \begin{align*}
    \hfib{f^{(1)}}{x_0}
    &\defeq \sm{z:\hfib{f}{y_0}} (\proj{1}(z) = x_0)\\
    &\eqvsym \sm{x:X}{p:f(x)=y_0} (x = x_0) &\text{(根据 \cref{ex:sigma-assoc})}\\
    &\eqvsym (f(x_0) = y_0) &\text{(因为 $\tsm{x:X} (x=x_0)$ 是可收缩的)}\\
    &\eqvsym (y_0 = y_0) &\text{(根据 $(f_0 \ct \blank)$)}\\
    &\jdeq \Omega Y。
  \end{align*}
  追溯下去，我们看到这个等价映射将 $((x,p),q)$ 映射到 $\opp{f_0} \ct \ap{f}{\opp q} \ct p$，而它的逆映射将 $r:y_0=y_0$ 映射到 $((x_0, f_0 \ct r), \refl{x_0})$。
  特别是，$\hfib{f^{(1)}}{x_0}$ 的基点 $((x_0,f_0),\refl{x_0})$ 被映射到 $\opp{f_0} \ct \ap{f}{\opp {\refl{x_0}}} \ct f_0$，这等于 $\refl{y_0}$。
  因此此等价映射是一个有基点映射 (参见 \cref{ex:pointed-equivalences})。
  此外，在此等价映射下，$f^{(2)}$ 被识别为映射 $\lam{r} (x_0, f_0 \ct r): \Omega Y \to \hfib f {y_0}$。

  \cref{item:fibseq2} 立即通过将~\ref{item:fibseq1} 应用于 $f^{(1)}$ 代替 $f$ 来得出。
  % 结果等价映射将 $(((x,p),p'),q') : \hfib{f^{(2)}}{(x_0,f_0)}$ 映射到 $\ap{f}{\opp {q'}} \ct p'$，而它的逆映射将 $s:x_0=x_0$ 映射到 $(((x_0,f_0), s), \refl{(x_0,f_0)})$。
  由于 $(f^{(1)})_0 \defeq \refl{x_0}$，在此等价映射下 $f^{(3)}$ 被识别为映射 $\Omega X \to \hfib {f^{(1)}}{x_0}$，该映射由 $s \mapsto ((x_0,f_0),s)$ 定义。
  因此，当我们与先前的等价映射 $\hfib {f^{(1)}}{x_0} \eqvsym \Omega Y$ 组合时，我们看到 $s$ 被映射到 $\opp{f_0} \ct \ap{f}{\opp s} \ct f_0$，这根据定义是 $(\Omega f)(\opp s)$。我们省略了证明这是一个有基点映射的证明，而不仅仅是函数的等价性。
\end{proof}

因此，$f:X\to Y$ 的纤维序列可以表示为：
\[\xymatrix@C=1.5pc{
  \dots \ar[r] &
  \Omega^2 X \ar[r]^-{\Omega^2 f} &
  \Omega^2 Y \ar[r]^-{-\Omega \partial} &
  \Omega F \ar[r]^-{-\Omega i} &
  \Omega X \ar[r]^-{-\Omega f} &
  \Omega Y \ar[r]^-{\partial} &
  F \ar[r]^-{i} &
  X \ar[r]^{f} & Y。}\]
其中负号表示与路径逆序 (path inversion) $\rev{(\blank)}$ 的组合。
请注意，根据 \cref{ex:ap-path-inversion}，我们有
\[ \Omega\left(\Omega f\circ \opp{(\blank)}\right) \circ \opp{(\blank)}
= \Omega^2 f \circ \opp{(\blank)} \circ \opp{(\blank)}
= \Omega^2 f。
\]
因此，当 $k$ 为奇数时，$k$ 次环映射上的符号是负号。

从这个纤维序列中，我们将推导出一个 \emph{有基点集的确界序列 (exact sequence of pointed sets)}。
\index{image}%
设 $A$ 和 $B$ 是集合，并且 $f:A\to B$ 是一个函数，并且回顾在 \cref{defn:modal-image} 中图像 $\im(f)$ 的定义，它可以视为 $B$ 的子集：
\[\im(f) \defeq \setof{b:B | \exis{a:A} f(a)=b}。 \]
如果 $A$ 和 $B$ 另外是有基点的，基点分别为 $a_0$ 和 $b_0$，并且 $f$ 是一个有基点映射，我们定义 $f$ 的 \define{核 (kernel)}\index{kernel}%
\index{pointed!map!kernel of}%
作为 $A$ 的以下子集：
\symlabel{kernel}
\[\ker(f) \defeq \setof{x:A | f(x) = b_0}。 \]
当然，这只是 $f$ 在基点 $b_0$ 上的纤维；它是 $A$ 的一个子集，因为 $B$ 是一个集合。

请注意，任何群都是一个有基点的集合，其单位元素作为基点，并且任何群同态 (group homomorphism) 都是一个有基点映射。
在这种情况下，核和图像与群论中的通常概念是一致的。

\begin{defn}
  一个 \define{有基点集的确界序列 (exact sequence of pointed sets)}\index{exact sequence}%
  \index{sequence!exact} 是一个（可能有界的）有基点集和有基点映射的序列：
  \[\xymatrix{\dots \ar[r] & A^{(n+1)} \ar[r]^-{f^{(n)}} & A^{(n)} \ar[r]^{f^{(n-1)}} & A^{(n-1)} \ar[r] &
  \dots}\]
  对于每个 $n$，$f^{(n)}$ 的图像作为 $A^{(n)}$ 的一个子集，等于 $f^{(n-1)}$ 的核。
  换句话说，对于所有 $a:A^{(n)}$，我们有
  \[ (f^{(n-1)}(a) = a^{(n-1)}_0) \iff \exis{b:A^{(n+1)}} (f^{(n)}(b)=a)。 \]
  其中 $a^{(n)}_0$ 表示 $A^{(n)}$ 的基点。
\end{defn}

通常，确界序列中的大多数或全部有基点集是群，通常是阿贝尔群。
当我们谈论一个 \define{群的确界序列 (exact sequence of groups)} 时，默认假设映射是群同态，而不仅仅是有基点映射。

\index{exact sequence}
\begin{thm}\label{thm:les}
设 $f:X \to Y$ 是有基点空间之间的一个有基点映射，其纤维为 $F\defeq \hfib f {y_0}$。
然后我们得到以下长确界序列，它由群组成，除了最后三个项，以及阿贝尔群，除了最后六个项。

\[
  \xymatrix@R=1.2pc@C=3pc{
    \vdots & \vdots & \vdots \ar[lld] \\
    \pi_k(F) \ar[r] & \pi_k(X) \ar[r] & \pi_k(Y) \ar[lld] \\
    \vdots & \vdots & \vdots \ar[lld] \\
    \pi_2(F) \ar[r] & \pi_2(X) \ar[r] & \pi_2(Y) \ar[lld] \\
    \pi_1(F) \ar[r] & \pi_1(X) \ar[r] & \pi_1(Y) \ar[lld]\\
    \pi_0(F) \ar[r] & \pi_0(X) \ar[r] & \pi_0(Y)}
\]
\end{thm}

\vspace*{0pt plus 10ex}
\goodbreak

\begin{proof}
  我们首先证明一个纤维序列的 0-截断是有基点集的确界序列。
  因此，我们需要证明，对于纤维序列中的任何相邻映射对：
  %
  \[\xymatrix{\hfib{f}{z_0} \ar^-g[r] & W \ar^-f[r] & Z}\]
  %
  其中 $g\defeq \proj1$，序列
  %
  \[\xymatrix{\trunc{0}{\hfib{f}{z_0}} \ar^-{\trunc0g}[r] & \trunc0{W}
    \ar^-{\trunc0{f}}[r] & \trunc0{Z}}\]
  %
  是确界的，即 $\im(\trunc0g)\subseteq\ker(\trunc0f)$ 和 $\ker(\trunc0f)\subseteq\im(\trunc0g)$。

  第一个包含等价于 $\trunc0g\circ\trunc0f=0$，这通过 $\truncf0$ 的函子性和 $g\circ f=0$ 的事实得到证明。
  对于第二个，我们假设 $w':\trunc0W$ 并且 $p':\trunc0f(w')=\tproj0{z_0}$ 并展示仅存在 $t:\hfib{f}{z_0}$ 使得 $g(t)=w'$。
  由于我们的目标是一个简单命题，我们可以假设 $w'$ 的形式为 $\tproj0w$ 对于某些 $w:W$。
  现在根据 \cref{thm:path-truncation}，$p' : \tproj0{f(w)}=\tproj0{z_0}$ 产生 $p'': \trunc{-1}{f(w)=z_0}$，因此通过进一步的截断归纳，我们可以假设存在一些 $p:f(w)=z_0$。
  但是现在我们有 $\tproj0{(w,p)}:\tproj0{\hfib{f}{z_0}}$，其在 $\trunc0g$ 下的映像是 $\tproj0w\jdeq w'$，如所愿。

  因此，将 $\truncf0$ 应用于 $f$ 的纤维序列，我们得到一个长确界序列，其中涉及到 $\pi_k(F)$、$\pi_k(X)$ 和 $\pi_k(Y)$ 的有基点集，并按所需顺序排列。
  当然，$\pi_k$ 是 $k\ge1$ 时的群，是环空间的 0-截断，并且 $k\ge 2$ 时是阿贝尔群，根据 Eckmann--Hilton 论证
  \index{Eckmann--Hilton argument} (\cref{thm:EckmannHilton})。
  此外，\cref{thm:fiber-of-the-fiber} 允许我们将此确界序列中的映射 $\pi_k(F) \to \pi_k(X)$ 和 $\pi_k(X) \to \pi_k(Y)$ 识别为 $(-1)^k \pi_k(i)$ 和 $(-1)^k \pi_k(f)$。

  更一般地，除了最后三个之外，此长确界序列中的每个映射都是 $\trunc0{\Omega h}$ 或 $\trunc0{-\Omega h}$ 形式的映射。
  在前一种情况下，它是群同态，而在后一种情况下，如果这些群是阿贝尔群，它是同态；否则它是“反同态”。
  但是，群同态的核和图像在我们将其替换为其负值时保持不变，因此涉及到它的任何序列的确界性也是如此。
  因此，我们可以修改我们的长确界序列，以获得一个涉及 $\pi_k(i)$ 和 $\pi_k(f)$ 的序列，并且所有映射都是群同态（除了最后三个）。
\end{proof}

通常的阿贝尔群的确界序列\index{group!abelian!exact sequence of} 的性质可以按常规证明。特别是我们有：
\begin{lem}\label{thm:ses}
假设给定一个阿贝尔群的确界序列：
%
\[\xymatrix{K \ar[r]& G \ar^f[r] & H \ar[r] & Q。}\]
%
\begin{enumerate}
  \item 如果 $K=0$，则 $f$ 是单射。\label{item:sesinj}
  \item 如果 $Q=0$，则 $f$ 是满射。\label{item:sessurj}
  \item 如果 $K=Q=0$，则 $f$ 是同构。\label{item:sesiso}
\end{enumerate}
\end{lem}
\begin{proof}
  由于 $f$ 的核是 $K\to G$ 的图像，如果 $K=0$，则 $f$ 的核是 $\{0\}$；
  因此 $f$ 是单射，因为它是群同态。
  类似地，由于 $f$ 的图像是 $H\to Q$ 的核，如果 $Q=0$，则 $f$ 的图像是所有 $H$，因此 $f$ 是满射。
  最后，~\ref{item:sesiso} 通过 \cref{thm:mono-surj-equiv} 从~\ref{item:sesinj} 和~\ref{item:sessurj} 得出。
\end{proof}

作为一个直接的应用，我们现在可以量化 $n$-连通性的一个映射比在 $n$-截断上诱导一个等价关系要强。

\begin{cor}\label{thm:conn-pik}
设 $f:A\to B$ 是 $n$-连通的并且 $a:A$，定义 $b\defeq f(a)$。那么：
\begin{enumerate}
  \item 如果 $k\le n$，则 $\pi_k(f):\pi_k(A,a) \to \pi_k(B,b)$ 是同构。\label{item:conn-pik1}
  \item 如果 $k=n+1$，则 $\pi_k(f):\pi_k(A,a) \to \pi_k(B,b)$ 是满射。\label{item:conn-pik2}
\end{enumerate}
\end{cor}
\begin{proof}
  对于 $k=0$，部分~\ref{item:conn-pik1} 由 \cref{lem:connected-map-equiv-truncation} 得出，注意到 $\pi_0(f)\equiv\trunc 0f$。
  对于 $k=0$，部分~\ref{item:conn-pik2} 由 \cref{ex:is-conn-trunc-functor} 得出，注意到一个函数是满射当且仅当它是 $(-1)$-连通的，通过 \cref{thm:minusoneconn-surjective}。
  对于 $k>0$，我们在长确界序列中有一个确界序列
  \[\xymatrix{\pi_k(\hfib f b) \ar[r]& \pi_k(A,a) \ar^f[r] & \pi_k(B,b) \ar[r] & \pi_{k-1}(\hfib f b)。}\]
  现在由于 $f$ 是 $n$-连通的，$\trunc n{\hfib f b}$ 是可缩的。
  因此，如果 $k\le n$，则 $\pi_k(\hfib f b) = \trunc0{\Omega^k(\hfib f b)} = \Omega^k(\trunc k{\hfib f b})$ 也是可缩的。
  因此，根据 \cref{thm:ses}\ref{item:sesiso}，$k\le n$ 时 $\pi_k(f)$ 是同构，而对于 $k=n+1$，根据 \cref{thm:ses}\ref{item:sessurj} 它是满射。
\end{proof}

在 \cref{sec:whitehead} 中，我们将看到 \cref{thm:conn-pik} 的逆命题也是成立的。

\index{fiber sequence|)}%
\index{sequence!fiber|)}%

\section{霍普夫纤维丛 (The Hopf fibration)}
\label{sec:hopf}

在本节中，我们将定义\define{霍普夫纤维丛 (Hopf fibration)}。
\indexdef{霍普夫!纤维丛 (Hopf!fibration)}%

\begin{thm}[霍普夫纤维丛 (Hopf Fibration)]\label{thm:hopf-fibration}
存在一个在 $\Sn^2$ 上的纤维丛 $H$，其基点上的纤维是 $\Sn^1$，总空间是 $\Sn^3$。
\end{thm}

霍普夫纤维丛将使我们能够计算多个球面上的同伦群。
确实，它得出了以下的同伦群的长确界序列
\index{同伦!群!球面 (homotopy!group!of sphere)}
\index{确界序列 (sequence!exact)}
(参见 \cref{sec:long-exact-sequence-homotopy-groups})：
%
\[
  \xymatrix@R=1.2pc{
    \pi_k(\Sn^1) \ar[r] & \pi_k(\Sn^3) \ar[r] & \pi_k(\Sn^2) \ar[lld] \\
    \vdots & \vdots & \vdots \ar[lld] \\
    \pi_2(\Sn^1) \ar[r] & \pi_2(\Sn^3) \ar[r] & \pi_2(\Sn^2) \ar[lld] \\
    \pi_1(\Sn^1) \ar[r] & \pi_1(\Sn^3) \ar[r] & \pi_1(\Sn^2)}
\]
%
我们已经计算出了所有 $\pi_n(\Sn^1)$ 和 $\pi_k(\Sn^n)$，对于 $k<n$ 的情况，这就变成了以下的形式：
%
\[
  \xymatrix@R=1.2pc{
    0 \ar[r] & \pi_k(\Sn^3) \ar[r] & \pi_k(\Sn^2) \ar[lld] \\
    \vdots & \vdots & \vdots \ar[lld] \\
    0 \ar[r] & \pi_3(\Sn^3) \ar[r] & \pi_3(\Sn^2) \ar[lld] \\
    0 \ar[r] & 0 \ar[r] & \pi_2(\Sn^2) \ar[lld] \\
    \Z \ar[r] & 0 \ar[r] & 0}
\]
%
特别地，我们得到了以下结果：

\begin{cor} \label{cor:pis2-hopf}
我们有 $\eqv{\pi_2(\Sn^2)}{\Z}$ 和 $\eqv{\pi_k(\Sn^3)}{\pi_k(\Sn^2)}$ 对于每个 $k\ge3$ (其中该映射是由霍普夫纤维丛诱导的，从总空间 $\Sn^3$ 到基空间 $\Sn^2$)。
\end{cor}

事实上，我们可以说更多：霍普夫纤维丛的纤维序列将表明 $\Omega^3(\Sn^3)$ 是从 $\Omega^3(\Sn^2)$ 到 $\Omega^2(\Sn^1)$ 的映射的纤维。
由于 $\Omega^2(\Sn^1)$ 是可收缩的，我们有 $\eqv{\Omega^3(\Sn^3)}{\Omega^3(\Sn^2)}$。
在经典同伦论中，这一事实将是 \cref{cor:pis2-hopf} 和怀特海德定理的结果，但怀特海德定理在同伦类型论中不一定成立 (参见 \cref{sec:whitehead})。
不过，我们在此不会使用更精确的版本。

\subsection{推送中的纤维丛 (Fibrations over pushouts)}
\label{sec:fib-over-pushout}

我们首先从一个引理开始，解释如何构造推送中的纤维丛。
\index{推送 (pushout)}%

\begin{lem}\label{lem:fibration-over-pushout}
令 $\Ddiag=(Y\xleftarrow{j}X\xrightarrow{k}Z)$ 是一个跨图\index{跨图 (span)}，并假设我们有
\begin{itemize}
  \item 两个纤维丛 $E_Y:Y\to\type$ 和 $E_Z:Z\to\type$。
  \item 一个等价性 $e_X$，在 $E_Y\circ j:X\to\type$ 和 $E_Z\circ k:X\to\type$ 之间，即
  \[e_X:\prd{x:X}\eqv{E_Y(j(x))}{E_Z(k(x))}。\]
\end{itemize}

然后我们可以构造一个纤维丛 $E:Y\sqcup^XZ\to\type$ 使得
\begin{itemize}
  \item 对于所有 $y:Y$，$E(\inl(y))\judgeq E_Y(y)$。
  \item 对于所有 $z:Z$，$E(\inr(z))\judgeq E_Z(z)$。
  \item 对于所有 $x:X$，$\map E{\glue(x)}=\ua(e_X(x))$ (注意方程两边都是在 $\type$ 中从 $E_Y(j(x))$ 到 $E_Z(k(x))$ 的路径)。
\end{itemize}
此外，这个纤维丛的总空间符合以下推送方框：
\[\xymatrix{ \sm{x:X}E_Y(j(x)) \ar[r]_\sim^{\idfunc\times e_X}
  \ar[d]_{j\times\idfunc} &
  \sm{x:X}E_Z(k(x)) \ar[r]^-{k\times\idfunc}
  & \sm{z:Z}E_Z(z) \ar[d]^\inr \\
  \sm{y:Y}E_Y(y) \ar[rr]_\inl & & \sm{t:Y\sqcup^XZ}E(t) }\]
\end{lem}

\begin{proof}
  我们通过 $Y\sqcup^XZ$ 的推送递归原理来定义 $E$。为此，我们需要指定 $E$ 在 $\inl(y)$ 和 $\inr(z)$ 形式的元素上的值，以及 $E$ 在 $\glue(x)$ 路径上的作用，因此我们可以选择以下值：
  \begin{align*}
    E(\inl(y)) & \defeq E_Y(y)，\\
    E(\inr(z)) & \defeq E_Z(z)，\\
    \map E{\glue(x)} & \defid \ua(e_X(x))。
  \end{align*}
%
  为了看到该纤维丛的总空间是一个推送，我们应用展平引理 (\cref{thm:flattening})，使用以下值：\index{展平引理 (flattening lemma)}
  \begin{itemize}
    \item $A\defeq Y+Z$，$B\defeq X$，并且 $f,g:B\to A$ 通过 $f(x)\defeq\inl(j(x))$，$g(x)\defeq\inr(k(x))$ 来定义，
    \item 类型族 $C:A\to\type$ 定义为
    \begin{equation*}
      C(\inl(y)) \defeq E_Y(y)
      \qquad\text{和}\qquad
      C(\inr(z)) \defeq E_Z(z)，
    \end{equation*}
    \item 等价族 $D:\prd{b:B}C(f(b))\eqvsym C(g(b))$ 被定义为 $e_X$。
  \end{itemize}
%
  展平引理的基本高阶归纳类型 $W$ 与推送 $Y\sqcup^XZ$ 等价，类型族 $P:Y\sqcup^XZ\to\type$ 与上述定义的 $E$ 等价。

  因此，展平引理告诉我们 $\sm{t:Y\sqcup^XZ}E(t)$ 与具有以下生成器的高阶归纳类型 ${E^{\mathrm{tot}}}'$ 等价：
%
  \begin{itemize}
    \item 一个函数 $\mathsf{z}:\sm{a:Y+Z}C(a)\to {E^{\mathrm{tot}}}'$，
    \item 对于每个 $x:X$ 和 $t:E_Y(j(x))$，一个路径
    \narrowequation{\mathsf{z}(\inl(j(x)),t)=\mathsf{z}(\inr(k(x)),e_X(t))。}
  \end{itemize}
%
  再使用展平引理或直接计算，容易看出 $\eqv{\sm{a:Y+Z}C(a)}{\sm{y:Y}E_Y(y)+\sm{z:Z}E_Z(z)}$，因此 ${E^{\mathrm{tot}}}'$ 与具有以下生成器的高阶归纳类型 $E^{\mathrm{tot}}$ 等价：
%
  \begin{itemize}
    \item 一个函数 $\inl:\sm{y:Y}E_Y(y)\to E^{\mathrm{tot}}$，
    \item 一个函数 $\inr:\sm{z:Z}E_Z(z)\to E^{\mathrm{tot}}$，
    \item 对于每个 $(x,t):\sm{x:X}E_Y(j(x))$，一个路径
    \narrowequation{\glue(x,t):\inl(j(x),t) = \inr(k(x),e_X(t))。}
  \end{itemize}
%
  因此，$E$ 的总空间是 $E_Y$ 和 $E_Z$ 的总空间的推送，如所需。
\end{proof}

\subsection{霍普夫构造 (The Hopf construction)}

\begin{defn}
  \define{H-空间 (H-space)}
  \indexdef{H-空间 (H-space)}%
  包括
  \begin{itemize}
    \item 一个类型 $A$，
    \item 一个基点 $e:A$，
    \item 一个二元操作 $\mu:A\times A\to A$，以及
    \item 对于每个 $a:A$，等式 $\mu(e,a)=a$ 和 $\mu(a,e)=a$。
  \end{itemize}
\end{defn}

\begin{lem}
  设 $A$ 是一个连通的 H-空间。对于每个 $a:A$，映射 $\mu(a,\blank):A\to A$ 和 $\mu(\blank,a):A\to A$ 是等价的。
\end{lem}

\begin{proof}
  我们证明对于每个 $a:A$，映射 $\mu(a,\blank)$ 是等价的。另一个命题是对称的。
%
  声明 $\mu(a,\blank)$ 是等价的对应于一个类型族 $P:A\to\prop$，证明它对应于找到该类型族的一个截面。

  类型 $\prop$ 是一个集 (\cref{thm:hleveln-of-hlevelSn})，因此我们可以通过 $P'(\tproj0a)\defeq P(a)$ 定义一个新的类型族 $P':\trunc0A\to\prop$。但根据假设，$A$ 是连通的，因此 $\trunc0A$ 是可收缩的。这意味着为了找到 $P'$ 的一个截面，足以找到 $P'$ 在 $\tproj0e$ 处的纤维中的一个点。但我们有 $P'(\tproj0e)=P(e)$，它是居住的，因为根据 H-空间的定义，$\mu(e,\blank)$ 等于恒等映射，因此是等价的。

  我们已经证明，对于每个 $x:\trunc0A$，命题 $P'(x)$ 是正确的，因此特别地对于每个 $a:A$，命题 $P(a)$ 是正确的，因为 $P(a)$ 是 $P'(\tproj0a)$。
\end{proof}

\begin{defn}
  设 $A$ 是一个连通的 H-空间。我们使用 \cref{lem:fibration-over-pushout} 定义在 $\susp A$ 上的纤维丛。

  给定 $\susp A$ 是推送 $\unit\sqcup^A\unit$，我们可以通过指定
  \begin{itemize}
    \item 两个在 $\unit$ 上的纤维丛（即两个类型 $F_1$ 和 $F_2$），以及
    \item 一个等价族 $e:A\to(\eqv{F_1}{F_2})$，在 $F_1$ 和 $F_2$ 之间，对于 $A$ 的每个元素。
  \end{itemize}
%
  我们取 $A$ 作为 $F_1$ 和 $F_2$，并为每个 $a:A$ 取等价 $\mu(a,\blank)$ 为 $e(a)$。
\end{defn}

根据 \cref{lem:fibration-over-pushout}，我们有以下的图表：
%
\[\xymatrix{A \ar@{->>}[d] & A \times A \ar[l]_-{\proj2} \ar@{->>}_{\proj1}[d]
  \ar[r]^-{\mu} & A \ar@{->>}[d] \\
  1 & A \ar[r] \ar[l] & 1}\]
%
我们刚刚构建的纤维丛是一个在 $\susp A$ 上的纤维丛，其总空间是顶线上推送的结果。

此外，使用 $f(x,y)\defeq(\mu(x,y),y)$，我们有以下的图表：
%
\[\xymatrix{A \ar_\idfunc[d] & A \times A \ar[l]_-{\proj2} \ar^f[d]
  \ar[r]^-{\mu} & A \ar^\idfunc[d] \\
  A & A\times A \ar^-{\proj2}[l] \ar_-{\proj1}[r] & A}\]
%
该图表是可交换的，三个垂直映射都是等价的，$f$ 的逆映射是由
\[g(u,v)\defeq(\opp{\mu(\blank,v)}(u),v)\]
定义的。
%
这表明两个线条是等价（因此是相等）的跨图，因此我们构造的纤维丛的总空间等价于底线推送的结果。
根据定义，后者的推送是 $A$ 与自身的\emph{连接 (join)}（参见 \cref{sec:colimits}）。
%
我们已经证明了：

\begin{lem}\label{lem:hopf-construction}
给定一个连通的 H-空间 $A$，存在一个纤维丛，称为\define{霍普夫构造 (Hopf construction)}，
\indexdef{霍普夫!构造 (Hopf!construction)}%
在 $\susp A$ 上，其纤维是 $A$，总空间是 $A*A$。
\end{lem}

\subsection{霍普夫纤维丛 (The Hopf fibration)}

\index{霍普夫纤维丛|(Hopf fibration|(}
\indexsee{纤维丛!霍普夫 (fibration!Hopf)}{霍普夫纤维丛 (Hopf fibration)}
我们首先将在 $\Sn^1$ 圆周上构造一个 H-空间的结构，因此根据 \cref{lem:hopf-construction}，我们将获得一个在 $\Sn^2$ 上的纤维丛，其纤维是 $\Sn^1$，总空间是 $\Sn^1*\Sn^1$。然后我们将证明这个连接等价于 $\Sn^3$。

\begin{lem}\label{lem:hspace-S1}
在 $\Sn^1$ 圆周上存在一个 H-空间结构。
\end{lem}
\begin{proof}
  对于 H-空间结构的基点，我们选择 $\base$。
%
  现在我们需要定义乘法操作 $\mu:\Sn^1\times\Sn^1\to\Sn^1$。
  我们将通过 $\Sn^1$ 的递归定义乘法的柯里化形式 $\widetilde\mu:\Sn^1\to(\Sn^1\to\Sn^1)$：
  \begin{equation*}
    \widetilde\mu(\base) \defeq\idfunc[\Sn^1]，
    \qquad\text{和}\qquad
    \ap{\widetilde\mu}{\lloop} \defid\funext(h)。
  \end{equation*}
  其中 $h:\prd{x:\Sn^1}(x=x)$ 是在 \cref{thm:S1-autohtpy} 中定义的函数，
  其性质是 $h(\base) \defeq\lloop$。

  现在我们只需要证明 $\mu(x,\base)=\mu(\base,x)=x$ 对于每个 $x:\Sn^1$。
%
  根据定义，如果 $x:\Sn^1$，我们有 $\mu(\base,x)=\widetilde\mu(\base)(x)=\idfunc[\Sn^1](x)=x$。对于等式 $\mu(x,\base)=x$，我们通过在 $x:\Sn^1$ 上的归纳法来进行：
  \begin{itemize}
    \item 如果 $x$ 是 $\base$，那么根据定义，$\mu(\base,\base)=\base$，所以我们有 $\refl\base:\mu(\base,\base)=\base$。
    \item 当 $x$ 随着 $\lloop$ 变化时，我们需要证明
    \[\refl\base\ct\apfunc{\lam{x}x}({\lloop})=
    \apfunc{\lam{x}\mu(x,\base)}({\lloop})\ct\refl\base。\]
    左边等于 $\lloop$，对于右边，我们有：
    \begin{align*}
      \apfunc{\lam{x}\mu(x,\base)}({\lloop})\ct\refl\base &=
      \apfunc{\lam{x}(\widetilde\mu(x))(\base)}({\lloop})\\
      &=\happly(\apfunc{\lam{x}(\widetilde\mu(x))}({\lloop}),\base)\\
      &=\happly(\funext(h),\base)\\
      &=h(\base)\\
      &=\lloop。 \qedhere
    \end{align*}
  \end{itemize}
\end{proof}

现在回想 \cref{sec:colimits}，类型 $A$ 和 $B$ 的\emph{连接 (join)} $A*B$ 是以下图表的推送：
\index{连接!类型 (join!of types)}%
\[A \xleftarrow{\proj1}A\times B \xrightarrow{\proj2} B.\]

\begin{lem}
  \index{连接的结合律 (associativity!of join)}%
  连接操作是结合的：如果 $A$、$B$ 和 $C$ 是三个类型，那么我们有一个等价 $\eqv{(A*B)*C}{A*(B*C)}$。
\end{lem}

\begin{proof}
  我们通过归纳定义一个映射 $f:(A*B)*C\to A*(B*C)$。首先需要通过归纳法定义 $f\circ\inl:A*B\to A*(B*C)$，然后定义 $f\circ\inr:C\to A*(B*C)$，最后定义 $\apfunc{f}\circ\glue:\prd{t:(A*B)\times C}f(\inl(\fst(t)))=f(\inr(\snd(t)))$，这将通过对 $t$ 的第一个分量进行归纳来完成：
  \begin{align*}
  (f\circ\inl)(\inl(a)) &\defeq \inl(a)， \\
  (f\circ\inl)(\inr(b)) &\defeq \inr(\inl(b))， \\
  \apfunc{f\circ\inl}(\glue(a,b)) &\defid \glue(a,\inl(b))， \\
  f(\inr(c)) &\defeq \inr(\inr(c))，\\
  \apfunc{f}(\glue(\inl(a),c)) &\defid \glue(a,\inr(c))，\\
  \apfunc{f}(\glue(\inr(b),c)) &\defid \apfunc{\inr}(\glue(b,c))，\\
  \apdfunc{\lam{x}\apfunc{f}(\glue(x,c))}(\glue(a,b)) &\defid
  ``\apdfunc{\lam{x}\glue(a,x)}(\glue(b,c))''。
  \end{align*}
%
  对于最后一个等式，注意右边的类型是
  \[\transfib{\lam{x}\inl(a)=\inr(x)}{\glue(b,c)}{\glue(a,\inl(b))}=
  \glue(a,\inr(c))，\]
  而它应该是
%
  \begin{narrowmultline*}
    \transfib{\lam{x}f(\inl(x))=f(\inr(c))}{\glue(a,b)}{\apfunc{f}(\glue(\inl(a),c))}
    = \narrowbreak
    \apfunc{f}(\glue(\inr(b),c)) 的类型。
  \end{narrowmultline*}
%
  但是根据定义中的前述条款，这两种类型都等价于以下类型：
  \[\glue(a,\inr(c))=\glue(a,\inl(b))\ct\apfunc\inr(\glue(b,c))，\]
  所以我们可以通过等价来进行强制转换以获得必要的元素。
%
  类似地，我们可以定义一个映射 $g:A*(B*C)\to (A*B)*C$，并检查 $f$ 和 $g$ 是相互逆的，这是一个漫长而乏味但本质上直截了当的计算。
\end{proof}

一种更概念化的证明大纲如下。

\begin{proof}
  让我们考虑以下图表，其中映射是显然的投影：
  \[\xymatrix{
    A & A\times C \ar[l] \ar[r] & A\times C\\
    A\times B \ar[u] \ar[d] & A\times B\times C \ar[l]\ar[u]\ar[r]\ar[d] &
    A\times C \ar[u] \ar[d] \\
    B & B\times C \ar[l] \ar[r] & C}\]
%
  取列的极限（colimit）得到以下图表，其极限是 $(A*B)*C$：
  \[\xymatrix{A*B & (A*B)\times C \ar[l]\ar[r] & C}\]
%
  另一方面，取行的极限得到一个图表，其极限是 $A*(B*C)$。

  因此，使用我们尚未证明的极限的 Fubini 类似定理（Fubini-like theorem for colimits），我们有 $\eqv{(A*B)*C}{A*(B*C)}$ 的等价性。尽管如此，这个 Fubini 定理的证明仍然需要漫长而乏味的计算。
\end{proof}

\begin{lem}
  对于任意类型 $A$，存在一个等价 $\eqv{\susp A}{\bool*A}$。
\end{lem}

\begin{proof}
  定义两个映射来回并证明它们是相互逆的很容易。具体细节留作读者练习。
\end{proof}

我们现在可以构造霍普夫纤维丛：

\begin{thm}
  存在一个在 $\Sn^2$ 上的纤维丛，其纤维为 $\Sn^1$，总空间为 $\Sn^3$。
  \index{总空间 (total!space)}%
\end{thm}
\begin{proof}
  我们证明了 $\Sn^1$ 具有 H-空间的结构（参见 \cref{lem:hspace-S1}），因此根据 \cref{lem:hopf-construction}，存在一个在 $\Sn^2$ 上的纤维丛，其纤维是 $\Sn^1$，总空间是 $\Sn^1*\Sn^1$。但根据前两个结果和 \cref{thm:suspbool}，我们有：
  \begin{equation*}
    \Sn^1*\Sn^1 = (\susp\bool)*\Sn^1
    =(\bool*\bool)*\Sn^1
    =\bool*(\bool*\Sn^1)
    =\susp(\susp\Sn^1)
    =\Sn^3。 \qedhere
  \end{equation*}
\end{proof}
\index{霍普夫纤维丛 (Hopf fibration)|)}

\section{Freudenthal 悬吊定理 (The Freudenthal Suspension Theorem)}
\label{sec:freudenthal}

\index{Freudenthal 悬吊定理 (Freudenthal suspension theorem)|(}%
\index{定理!Freudenthal 悬吊 (theorem!Freudenthal suspension)|(}%

在证明 Freudenthal 悬吊定理之前，我们需要一些关于连通性 (connectedness) 的辅助引理。在 \cref{cha:hlevels} 中，我们证明了一些关于固定 $n$ 的 $n$-连通映射 ($n$-connected maps) 和 $n$-类型 ($n$-types) 的事实；现在我们感兴趣的是，当我们改变 $n$ 时会发生什么。例如，在 \cref{prop:nconnected_tested_by_lv_n_dependent types} 中，我们展示了 $n$-连通映射可以通过相对于 $n$-类型的族 (families of $n$-types) 的“归纳原理” (induction principle) 来表征。如果我们想要沿着一个 $n$-连通映射对 $k$-类型的族进行“归纳” (induct)，其中 $k > n$，我们不能立即知道是否有一个由这种归纳原理产生的函数，但以下引理表明至少可以量化我们的无知。

\begin{lem}\label{thm:conn-trunc-variable-ind}
如果 $f:A\to B$ 是 $n$-连通映射，并且 $P:B\to \ntype{k}$ 是一个 $k$-类型的族，其中 $k\ge n$，那么诱导的函数
\[ (\blank\circ f) : \Parens{\prd{b:B} P(b)} \to \Parens{\prd{a:A} P(f(a)) } \]
是 $(k-n-2)$-截断 (truncated) 的。
\end{lem}

\begin{proof}
  我们对自然数 $k-n$ 进行归纳。当 $k=n$ 时，这就是 \cref{prop:nconnected_tested_by_lv_n_dependent types}。
  %
  对于归纳步骤，假设 $f$ 是 $n$-连通的，并且 $P$ 是一个 $(k+1)$-类型的族。为了证明 $(\blank\circ f)$ 是 $(k-n-1)$-截断的，设 $\ell:\prd{a:A} P(f(a))$；那么我们有
  \[ \hfib{(\blank\circ f)}{\ell} \eqvsym \sm{g:\prd{b:B} P(b)} \prd{a:A} g(f(a)) = \ell(a)。\]
  令 $(g,p)$ 和 $(h,q)$ 位于此类型中，因此 $p:g\circ f \htpy \ell$ 并且 $q:h\circ f \htpy \ell$；然后我们也有
  \[ \big((g,p) = (h,q)\big) \eqvsym
  \Parens{\sm{r:g\htpy h} r\circ f = p \ct \opp{q}}。
  \]
  然而，这里的右侧是映射的一个纤维
  \[ (\blank\circ f) : \Parens{\prd{b:B} Q(b)} \to \Parens{\prd{a:A} Q(f(a)) } \]
  其中 $Q(b) \defeq (g(b)=h(b))$。
  由于 $P$ 是一个 $(k+1)$-类型的族，$Q$ 是一个 $k$-类型的族，因此归纳假设表明这个纤维是一个 $(k-n-2)$-类型。因此，$\hfib{(\blank\circ f)}{\ell}$ 的所有路径空间都是 $(k-n-2)$-类型，因此它是 $(k-n-1)$-类型的。
\end{proof}

回想一下，如果 $\pairr{A,a_0}$ 和 $\pairr{B,b_0}$ 是有基点的类型 (pointed types)，那么它们的\define{楔和 (wedge)}
\index{wedge}%
$A\vee B$ 被定义为 $A\xleftarrow{a_0} \unit\xrightarrow{b_0} B$ 的推挤 (pushout)。有一个规范映射 $i:A\vee B \to A\times B$，由两个映射 $\lam{a} (a,b_0)$ 和 $\lam{b} (a_0,b)$ 定义；以下引理本质上说明，如果 $A$ 和 $B$ 是高度连通的，则这个映射也是如此。然而，如果我们使用 \cref{prop:nconnected_tested_by_lv_n_dependent types} 中的连通性表征，并在推挤的通用性质中进行替换，那么证明和使用起来会更方便。

\begin{lem}[楔和连通性引理 (Wedge connectivity lemma)]\label{thm:wedge-connectivity}
假设 $\pairr{A,a_0}$ 和 $\pairr{B,b_0}$ 分别是 $n$-和 $m$-连通的有基点类型，且 $n,m\geq0$，并令
%
\narrowequation{P:A\to B\to \ntype{(n+m)}.}
%
那么对于任何 ${f:\prd{a:A} P(a,b_0)}$ 和 ${g:\prd{b:B} P(a_0,b)}$，其中 $p:f(a_0) = g(b_0)$，存在 $h:\prd{a:A}{b:B} P(a,b)$，并且存在同伦 (homotopies)
%
\begin{equation*}
  q:\prd{a:A} h(a,b_0)=f(a)
  \qquad\text{和}\qquad
  r:\prd{b:B} h(a_0,b)=g(b)
\end{equation*}
%
使得 $p = \opp{q(a_0)} \ct r(b_0)$。
\end{lem}

\begin{proof}
  定义 $Q:A\to\type$ 为
  \[ Q(a) \defeq \sm{k:\prd{b:B} P(a,b)} (f(a) = k(b_0))。\]
  然后我们有 $(g,p):Q(a_0)$。
  由于 $a_0:\unit\to A$ 是 $(n-1)$-连通的，如果 $Q$ 是一个 $(n-1)$-类型的族，那么我们将有 $\ell:\prd{a:A} Q(a)$，使得 $\ell(a_0) = (g,p)$，在这种情况下，我们可以定义 $h(a,b) \defeq \proj1(\ell(a))(b)$。
  然而，对于固定的 $a$，类型 $Q(a)$ 是 $f(a)$ 的纤维，映射为
  \[ \Parens{\prd{b:B} P(a,b) } \to P(a,b_0) \]
  由 $b_0:\unit\to B$ 的预组合给出。
  由于 $b_0:\unit\to B$ 是 $(m-1)$-连通的，要使这个纤维成为 $(n-1)$-截断的，根据 \cref{thm:conn-trunc-variable-ind}，只要每个类型 $P(a,b)$ 是 $(n+m)$-类型，这个条件就足够了。
\end{proof}

令 $(X,x_0)$ 为有基点类型，并回忆 \cref{sec:suspension} 中悬吊 (suspension) $\susp X$ 的定义，具有构造子 $\north,\south:\susp X$ 和 $\merid:X \to (\north=\south)$。
我们将 $\susp X$ 视为有基点空间，基点为 $\north$，因此我们有 $\Omega\susp X \defeq (\id[\susp X]\north\north)$。
然后有一个规范映射
\begin{align*}
  \sigma &: X \to \Omega\susp X\\
  \sigma(x) &\defeq \merid(x) \ct \opp{\merid(x_0)}。
\end{align*}

\begin{rmk}
  在经典的代数拓扑中，考虑的是\emph{约化悬吊 (reduced suspension)}，其中路径 $\merid(x_0)$ 被折叠为一个点，将 $\north$ 和 $\south$ 识别为一个点。约化和未约化的悬吊是同伦等价的，因此这个区别对我们纯粹的同伦论 (homotopy-theoretic) 眼光来说是不可见的——而高阶归纳类型只允许我们“识别”点到更高的路径上，无论如何，在同伦类型论中考虑约化悬吊没有意义。然而，我们的悬吊的“未约化性”是 $\sigma$ 的定义中出现 $\opp{\merid(x_0)}$（可能出乎意料）的原因。
\end{rmk}

我们的目标现在是证明以下定理。

\begin{thm}[Freudenthal 悬吊定理 (The Freudenthal Suspension Theorem)]\label{thm:freudenthal}
假设 $X$ 是 $n$-连通且有基点的，并且 $n\geq 0$。那么映射 $\sigma:X\to \Omega\susp(X)$ 是 $2n$-连通的。
\end{thm}

\index{编码-解码方法 (encode-decode method)|(}%

我们将使用编码-解码方法 (encode-decode method)，但会以稍微不同的方式应用它。到目前为止，在大多数情况下，我们使用它来将某些类型 $A$ 的回路空间 (loop space) $\Omega (A,a_0)$ 表征为某个其他类型 $B$，通过构造一个族 $\code:A\to \type$，其中 $\code(a_0)\defeq B$ 并且构造一个等价族 $\decode:\prd{x:A}\code(x) \eqvsym (a_0=x)$。
% 我们还通过一个等价族 $\prd{x:A}\code(x) \eqvsym \trunc n{a_0=x}$ 将其推广以表征回路空间的截断。

然而，在这种情况下，我们想要证明 $\sigma:X\to \Omega \susp X$ 是 $2n$-连通的。我们可以使用前述方法的截断版本，例如我们将在 \cref{sec:van-kampen} 中看到，来证明 $\trunc{2n}X\to \trunc{2n}{\Omega \susp X}$ 是一个等价——但这是一个稍微弱一点的声明，不能说明映射是 $2n$-连通的 (见 \cref{thm:conn-pik,thm:pik-conn})。然而，注意在一般情况下，为了证明 $\decode(x)$ 是一个等价，可以等效地证明它的纤维是收缩的 (contractible)，我们仍然可以对基类型进行归纳。这一点我们可以推广到证明进入回路空间的映射的连通性，即它的纤维的\emph{截断}是收缩的。此外，我们可以直接构造\emph{纤维的截断的编码 (codes for the truncations of the fibers)}的族，而不是分别构造 $\code$ 和 $\decode$。

\begin{defn}\label{thm:freudcode}
如果 $X$ 是 $n$-连通且有基点的，且 $n\geq 0$，那么存在一个族
\begin{equation}
  \code:\prd{y:\susp X} (\north=y) \to \type\label{eq:freudcode}
\end{equation}
使得
\begin{align}
  \code(\north,p) &\defeq \trunc{2n}{\hfib{\sigma}{p}}
  \jdeq \trunc{2n}{\tsm{x:X} (\merid(x) \ct \opp{\merid(x_0)} = p)}\label{eq:freudcodeN}\\
  \code(\south,q) &\defeq \trunc{2n}{\hfib{\merid}{q}}
  \jdeq \trunc{2n}{\tsm{x:X} (\merid(x) = q)}。\label{eq:freudcodeS}
\end{align}
\end{defn}

我们的最终目标是证明对于所有 $y:\susp X$ 和 $p:\north=y$，$\code(y,p)$ 是收缩的。将此应用于 $y\defeq \north$，将表明 $\sigma$ 的所有纤维都是 $2n$-连通的，从而 $\sigma$ 是 $2n$-连通的。

\begin{proof}[证明 \cref{thm:freudcode}]
  我们通过对 $y:\susp X$ 进行归纳来定义 $\code(y,p)$，其中前两个情况是~\eqref{eq:freudcodeN} 和~\eqref{eq:freudcodeS}。还需要构造，对于每个 $x_1:X$，一个依赖路径 (dependent path)
  \[ \dpath{\lam{y}(\north=y)\to\type}{\merid(x_1)}{\code(\north)}{\code(\south)}。 \]
  根据 \cref{thm:dpath-arrow}，这等价于给出一个路径族
  \[ \prd{q:\north=\south} \code(\north)(\transfib{\lam{y}(\north=y)}{\opp{\merid(x_1)}}{q}) = \code(\south)(q)。 \]
  并且根据可泛性和路径类型中的传输 (transport in path types)，这等价于一个等价族
  \[ \prd{q:\north=\south} \code(\north,q \ct \opp{\merid(x_1)}) \eqvsym \code(\south,q)。 \]
  我们将定义一个映射族
  \begin{equation}\label{eq:freudmap}
  \prd{q:\north=\south} \code(\north,q \ct \opp{\merid(x_1)}) \to \code(\south,q)。
  \end{equation}
  然后证明它们都是等价的。
  因此，令 $q:\north=\south$；根据截断的通用性质以及 $\code(\north,\blank)$ 和 $\code(\south,\blank)$ 的定义，对于每个 $x_2:X$，定义一个映射
  \begin{equation*}
    \big(\merid(x_2)\ct \opp{\merid(x_0)} = q \ct \opp{\merid(x_1)}\big)
    \to \trunc{2n}{\tsm{x:X} (\merid(x) = q)}。
  \end{equation*}
  现在对于每个 $x_1,x_2:X$，这个类型是 $2n$-截断的，而 $X$ 是 $n$-连通的。因此，根据 \cref{thm:wedge-connectivity}，只需要在 $x_1$ 为 $x_0$，$x_2$ 为 $x_0$ 时定义这个映射，并检查它们在 $x_0$ 时是否一致。

  当 $x_1$ 为 $x_0$ 时，假设 $r:\merid(x_2)\ct \opp{\merid(x_0)} = q \ct \opp{\merid(x_0)}$。因此，通过从 $r$ 中消去 $\opp{\merid(x_0)}$ 得到 $r':\merid(x_2)=q$，所以我们可以将图像定义为 $\tproj{2n}{(x_2,r')}。

  当 $x_2$ 为 $x_0$ 时，假设 $r:\merid(x_0)\ct \opp{\merid(x_0)} = q \ct \opp{\merid(x_1)}$。重新排列此路径，我们得到 $r'':\merid(x_1)=q$，我们可以将图像定义为 $\tproj{2n}{(x_1,r'')}。

  最后，当 $x_1$ 和 $x_2$ 都是 $x_0$ 时，足以证明得到的 $r'$ 和 $r''$ 一致；这可以通过一个关于路径组合的简单引理来证明。这完成了~\eqref{eq:freudmap} 的定义。要证明它是一个等价族，由于等价是一个纯粹命题，并且 $x_0:\unit\to X$ 是（至少）$(-1)$-连通的，所以我们可以假设 $x_1$ 是 $x_0$。在这种情况下，通过检查上面的构造，我们可以看到它本质上是消去 $\opp{\merid(x_0)}$ 的函数的 $2n$-截断，这是一个等价。
\end{proof}

除了~\eqref{eq:freudcodeN} 和~\eqref{eq:freudcodeS}，我们还需要从 $\code$ 的构造中提取出一些关于它如何作用于路径的信息。为此，我们使用以下引理。

\begin{lem}\label{thm:freudlemma}
令 $A:\UU$, $B:A\to \UU$, $C:\prd{a:A} B(a)\to\UU$，并且 $a_1,a_2:A$，假设 $m:a_1=a_2$ 并且 $b:B(a_2)$。那么函数
\[\transfib{\widehat{C}}{\pairpath(m,t)}{\blank} : C(a_1,\transfib{B}{\opp m}{b}) \to C(a_2,b),\]
其中 $t:\transfib{B}{m}{\transfib{B}{\opp m}{b}} = b$ 是显然的一致性路径，并且 $\widehat{C}:(\sm{a:A} B(a)) \to\type$ 是 $C$ 的非柯里化 (uncurried) 形式，它等价于从复合中通过可泛性获得的等价：
\begin{align}
  C(a_1,\transfib{B}{\opp m}{b})
  &= \transfib{\lam{a} B(a)\to \UU}{m}{C(a_1)}(b)
  \tag{by~\eqref{eq:transport-arrow}}\\
  &= C(a_2,b)。 \tag{by $\happly(\apd{C}{m},b)$}
\end{align}
\end{lem}

\begin{proof}
  通过路径归纳，我们可以假设 $a_2$ 是 $a_1$ 并且 $m$ 是 $\refl{a_1}$，在这种情况下两个函数都是恒等函数。
\end{proof}

我们应用这个引理，其中 $A\defeq\susp X$，$B\defeq \lam{y}(\north=y)$，$C\defeq\code$，$a_1\defeq\north$，$a_2\defeq\south$，$m\defeq \merid(x_1)$，其中 $x_1:X$，最后 $b\defeq q$ 是路径 $\north=\south$。
悬吊 $X$ 的归纳计算规则将 $\apd{C}{m}$ 识别为通过可泛性和函数外延性 (function extensionality) 的应用构造出的路径。由 \cref{thm:freudlemma} 所述的第二个函数本质上包括撤销这些可泛性和函数外延性的应用，减少回我们用 \cref{thm:wedge-connectivity} 定义的特定函数~\eqref{eq:freudmap}。因此，\cref{thm:freudlemma} 说明沿着 $\pairpath(q,t)$ 进行传输 (transport) 本质上恢复了这些函数。

最后，通过构造，当 $x_1$ 或 $x_2$ 与 $x_0$ 重合并且输入位于 $\tproj{2n}{\blank}$ 的图像中时，我们可以更明确地知道这些函数是什么。因此，对于任意 $x_2:X$，我们有
\begin{equation}
  \transfib{\hat{\code}}{\pairpath(\merid(x_0),t)}{\tproj{2n}{(x_2,r)}}
  =\tproj{2n}{(x_1,r')}。\label{eq:freudcompute1}
\end{equation}
其中 $r:\merid(x_2) \ct \opp{\merid(x_0)} = \transfib{B}{\opp{\merid(x_0)}}{q}$ 是任意的，$r':\merid(x_2)=q$ 通过将它的终点与 $q \ct \opp{\merid(x_0)}$ 识别并消去 $\opp{\merid(x_0)}$ 得到。同样，对于任意 $x_1:X$，我们有
\begin{equation}
  \transfib{\hat{\code}}{\pairpath(\merid(x_1),t)}{\tproj{2n}{(x_0,r)}}
  = \tproj{2n}{(x_1,r'')}。\label{eq:freudcompute2}
\end{equation}
其中 $r:\merid(x_0) \ct \opp{\merid(x_0)} = \transfib{B}{\opp{\merid(x_1)}}{q}$，并且 $r'':\merid(x_1)=q$ 是通过识别它的终点和重排路径得到的。

\begin{proof}[证明 \cref{thm:freudenthal}]
  现在我们需要证明对于每个 $y:\susp X$ 和 $p:\north=y$，$\code(y,p)$ 是收缩的。首先我们必须选择一个收缩中心，设 $c(y,p):\code(y,p)$。这对应于在我们之前的证明中定义 $\encode$ 函数，因此我们通过传输来定义它。注意在特殊情况下，当 $y$ 是 $\north$ 且 $p$ 是 $\refl{\north}$ 时，我们有
  \[\code(\north,\refl{\north}) \jdeq \trunc{2n}{\tsm{x:X} (\merid(x) \ct \opp{\merid(x_0)} = \refl{\north})}。\]
  因此，我们可以选择 $c(\north,\refl{\north})\defeq \tproj{2n}{(x_0,\mathsf{rinv}_{\merid(x_0)})}$，其中 $\mathrm{rinv}_q$ 是一个显然的路径 $q\ct\opp q = \refl{}$ 对于任何 $q$。我们现在可以通过对 $p$ 进行路径归纳得到 $c:\prd{y:\susp X}{p:\north=y} \code(y,p)$，但下面很重要的是我们还可以通过传输给出一个具体的定义：
  \[ c(y,p) \defeq \transfib{\hat{\code}}{\pairpath(p,\mathsf{tid}_p)}{c(\north,\refl{\north})}
  \]
  其中 $\hat{\code}: \big(\sm{y:\susp X} (\north=y)\big) \to \type$ 是 $\code$ 的非柯里化形式，并且 $\mathsf{tid}_p:\trans{p}{\refl{}} = p$ 是一个标准引理。

  接下来，我们必须证明 $\code(y,p)$ 的每个元素都等于 $c(y,p)$。同样，通过路径归纳，我们可以假设 $y$ 是 $\north$ 并且 $p$ 是 $\refl{\north}$。事实上，我们将更普遍地证明当 $y$ 是 $\north$ 并且 $p$ 是任意时。也就是说，我们将证明对于任何 $p:\north=\north$ 和 $d:\code(\north,p)$，我们有 $d = c(\north,p)$。由于这个等式是一个 $(2n-1)$-类型，我们可以假设 $d$ 的形式为 $\tproj{2n}{(x_1,r)}$，其中 $x_1:X$ 并且 $r:\merid(x_1) \ct \opp{\merid(x_0)} = p$。

  现在通过进一步的路径归纳，我们可以假设 $r$ 是反身性，并且 $p$ 是 $\merid(x_1) \ct \opp{\merid(x_0)}$。这就是为什么我们将其推广到任意 $p$ 的原因。因此，我们必须证明
  \begin{equation}
    \tproj{2n}{(x_1, \refl{\merid(x_1) \ct \opp{\merid(x_0)}})}
    \;=\;
    c\left(\north,\refl{\merid(x_1) \ct \opp{\merid(x_0)}}\right)。\label{eq:freudgoal}
  \end{equation}
  根据定义，这个等式的右侧是
  \begin{multline*}
    \Transfib{\hat{\code}}{\pairpath(\merid(x_1) \ct \opp{\merid(x_0)}, \nameless)}{\tproj{2n}{(x_0,\nameless)}} \\
    = \transfibf{\hat{\code}}
    \begin{aligned}[t]
      \Big(
      &{\pairpath(\opp{\merid(x_0)}, \nameless)},\\
      &{\Transfib{\hat{\code}}{\pairpath(\merid(x_1), \nameless)}{\tproj{2n}{(x_0,\nameless)}}}
      \Big)
    \end{aligned}
    \\
    = \Transfib{\hat{\code}}{\pairpath(\opp{\merid(x_0)}, \nameless)}{\tproj{2n}{(x_1,\nameless)}}
    = \tproj{2n}{(x_1,\nameless)}
  \end{multline*}
  其中下划线 $\nameless$ 应该用合适的一致性路径填充。这里的第一步是传输的函子性，第二步调用了~\eqref{eq:freudcompute2}，第三步调用了~\eqref{eq:freudcompute1}（并将传输移至另一侧）。因此我们具有~\eqref{eq:freudgoal} 左侧相同的第一分量。我们留给读者验证所有的一致性路径都会消去，给出第二分量中的反身性。
\end{proof}

% 作为推论，我们有以下等价。

\begin{cor}[Freudenthal 等价 (Freudenthal Equivalence)] \label{cor:freudenthal-equiv}
假设 $X$ 是 $n$-连通且有基点的，并且 $n\geq 0$。那么 $\eqv{\trunc{2n}{X}}{\trunc{2n}{\Omega\susp(X)}}$。
\end{cor}

\begin{proof}
  根据 \cref{thm:freudenthal}，$\sigma$ 是 $2n$-连通的。根据 \cref{lem:connected-map-equiv-truncation}，因此它在 $2n$-截断上是一个等价。
\end{proof}

\index{编码-解码方法|)}%

\index{Freudenthal 悬吊定理|)}%
\index{定理!Freudenthal 悬吊|)}%

\index{同伦!球面 (homotopy!group!of sphere)}%
\index{稳定性!球面同伦群的稳定性 (stability!of homotopy groups of spheres)}%
\index{类型!n-球面 (type!n-sphere@$n$-sphere)}%
Freudenthal 悬吊定理的一个重要推论是球面 (sphere) 的同伦群 (homotopy group) 在某个范围内是稳定的（这些是 \cref{tab:homotopy-groups-of-spheres} 中从东北到西南的对角线）：

\begin{cor}[球面稳定性 (Stability for Spheres)] \label{cor:stability-spheres}
如果 $k \le 2n-2$，则 $\pi_{k+1}(S^{n+1}) = \pi_{k}(S^{n})$。
\end{cor}

\begin{proof}
  假设 $k \le 2n-2$。
%
  根据 \cref{cor:sn-connected}，$\Sn ^{n}$ 是 $\nminusone$-连通的。因此，根据 \cref{cor:freudenthal-equiv}，
  \[
    \trunc{2(n-1)}{\Omega(\susp(\Sn^{n}))} = \trunc{2(n-1)}{\Sn^{n}}。
  \]
  根据 \cref{lem:truncation-le}，由于 $k \le 2(n-1)$，对两边应用 $\trunc{k}{\blank}$ 显示这个等式对 $k$ 成立：
  \begin{equation}\label{eq:freudenthal-for-spheres}
  \trunc{k}{\Omega(\susp(\Sn^{n}))} = \trunc{k}{\Sn^{n}}。
  \end{equation}
%
  那么，证明的主要思路如下；我们省略了这些等价对这些空间的基点的作用检查，并且对于 $k > 0$，等价尊重乘法：
%
  \begin{align*}
    \pi_{k+1}(\Sn^{n+1}) &\jdeq \trunc{0}{\Omega^{k+1}(\Sn^{n+1})} \\
    &\jdeq \trunc{0}{\Omega^k(\Omega(\Sn^{n+1}))} \\
    &\jdeq \trunc{0}{\Omega^k(\Omega(\susp(\Sn^{n})))} \\
    &= \Omega^k(\trunc{k}{(\Omega(\susp(\Sn^{n})))})
    \tag{by \cref{thm:path-truncation}}\\
    &= \Omega^k(\trunc{k}{\Sn^{n}})
    \tag{by \eqref{eq:freudenthal-for-spheres}}\\
    &= \trunc{0}{\Omega^k(\Sn^{n})}
    \tag{by \cref{thm:path-truncation}}\\
    &\jdeq \pi_k(\Sn^{n})。 \qedhere
  \end{align*}
%
\end{proof}

这意味着一旦我们计算出这些稳定对角线中的一个条目，我们就知道它们的全部。例如：

\begin{thm}\label{thm:pinsn}
对于每个 $n\geq 1$，$\pi_n(\Sn^n)=\Z$。
\end{thm}

\begin{proof}
  证明是对 $n$ 的归纳。我们已经有 $\pi_1(\Sn ^1) = \Z$ (\cref{cor:pi1s1}) 和 $\pi_2(\Sn ^2) = \Z$ (\cref{cor:pis2-hopf})。
  当 $n \ge 2$ 时，$n \le (2n - 2)$。因此，根据 \cref{cor:stability-spheres}，$\pi_{n+1}(S^{n+1}) = \pi_{n}(S^{n})$，并且这个等价结合归纳假设，给出了结果。
\end{proof}

\begin{cor}
  对于任何 $n\ge -1$，$\Sn^{n+1}$ 不是 $n$-类型。
\end{cor}

\begin{cor}\label{thm:pi3s2}
$\pi_3(\Sn^2)=\Z$。
\end{cor}
\begin{proof}
  根据 \cref{cor:pis2-hopf}，$\pi_3(\Sn^2) = \pi_3(\Sn^3)$。
  但根据 \cref{thm:pinsn}，$\pi_3(\Sn^3) = \Z$。
\end{proof}
\section{van Kampen 定理 (The van Kampen theorem)}
\label{sec:van-kampen}

\index{van Kampen 定理|(van Kampen theorem|(}%
\index{定理!van Kampen|(theorem!van Kampen|(}%

\index{基本!群 (fundamental!group)}%
van Kampen 定理计算了空间的 (同伦) 推挤的基本群 $\pi_1$。传统上，它被表述为一个拓扑空间 $X$，其为两个开子空间 $U$ 和 $V$ 的并集，但从同伦论的角度来看，这只是确保 $X$ 是 $U$ 和 $V$ 在它们的交集上的推挤的一种便捷方式。因此，我们将证明 van Kampen 定理的一个版本，适用于任意的推挤。

在本节中，我们将描述一个 van Kampen 定理的证明，它使用了与在 \cref{sec:pi1-s1-intro} 中用于 $\pi_1(\Sn^1)$ 的相同的编码-解码方法 (encode-decode method)。还有一种更同伦论的处理方法；见 \cref{ex:rezk-vankampen}。

我们需要一个更精细的编码-解码方法版本。在 \cref{sec:pi1-s1-intro}（以及在 \cref{sec:compute-coprod,sec:compute-nat}）中，我们用它来刻画 (更高) 归纳类型 $W$ 的路径空间——由此推导出其循环空间 $\Omega(W)$ 的刻画，从而也推导出其 0-截断 $\pi_1(W)$ 的刻画。在 van Kampen 定理中，我们的目标只是刻画基本\emph{群} $\pi_1(W)$，而我们没有可以使用的循环空间或路径空间的显式描述。

事实证明，我们可以直接使用相同的技术来处理路径纤维化的截断版本，从而不仅刻画基本\emph{群} $\pi_1(W)$，还刻画整个基本\emph{群胚} (groupoid)。\index{基本!准群胚 (fundamental!pregroupoid)}具体来说，对于类型 $X$，将 $\Pi_1 X: X\to X\to \type$ 表示为其恒等类型的 $0$-截断，即 $\Pi_1 X(x,y) \defeq \trunc0{x=y}$。注意，我们有诱导的群胚运算：
\begin{align*}
(\blank\ct\blank) &\;:\; \Pi_1X(x,y) \to \Pi_1X(y,z) \to \Pi_1X(x,z)\\
\opp{(\blank)} &\;:\; \Pi_1X(x,y) \to \Pi_1X(y,x)\\
\refl{x} &\;:\; \Pi_1X(x,x)\\
\apfunc{f} &\;:\; \Pi_1X(x,y) \to \Pi_1Y(fx,fy)
\end{align*}
对于这些运算，我们使用与路径上相应运算相同的符号。

\subsection{朴素的 van Kampen}
\label{sec:naive-vankampen}

我们从 van Kampen 定理的一个“朴素”版本开始，这个版本有用但不如经典版本有用。在 \cref{sec:better-vankampen} 中，我们将改进它，使其更加有用。

\index{编码-解码方法|(encode-decode method|(}%

给定类型 $A,B,C$ 和函数 $f:A\to B$ 以及 $g:A\to C$，设 $P$ 为它们的推挤 $B\sqcup^A C$。如我们在 \cref{sec:colimits} 中所见，$P$ 是由以下生成的更高归纳类型：
\begin{itemize}
  \item $i:B\to P$，
  \item $j:C\to P$，以及
  \item 对于所有 $x:A$，存在一条路径 $k x:ifx = jgx$。
\end{itemize}
通过对 $P$ 进行双重归纳来定义 $\code:P\to P\to \type$，具体如下。
\begin{itemize}
  \item $\code(ib,ib')$ 是一组对序列的集合商 (set-quotient) (见 \cref{sec:set-quotients}) 类型
  \[ (b, p_0, x_1, q_1, y_1, p_1, x_2, q_2, y_2, p_2, \dots, y_n, p_n, b') \]
  其中
  \begin{itemize}
    \item $n:\mathbb{N}$
    \item $x_k:A$ 和 $y_k:A$ 对于 $0<k \le n$
    \item $p_0:\Pi_1B(b,f x_1)$ 和 $p_n:\Pi_1B(f y_n, b')$ 对于 $n>0$，以及 $p_0:\Pi_1B(b,b')$ 对于 $n=0$
    \item $p_k:\Pi_1B(f y_k, fx_{k+1})$ 对于 $1\le k < n$
    \item $q_k:\Pi_1C(gx_k, gy_k)$ 对于 $1\le k\le n$
  \end{itemize}
  该商是通过以下等式生成的：
  \begin{align*}
  (\dots, q_k, y_k, \refl{fy_k}, y_k, q_{k+1},\dots)
    &= (\dots, q_k\ct q_{k+1},\dots)\\
    (\dots, p_k, x_k, \refl{gx_k}, x_k, p_{k+1},\dots)
    &= (\dots, p_k\ct p_{k+1},\dots)
  \end{align*}
  （见 \cref{rmk:naive} 下面）。我们留给读者将此序列类型精确定义为归纳类型。
  \item $\code(jc,jc')$ 是相同的，角色转换了 $B$ 和 $C$。我们也在记号上反转了 $x$ 和 $y$ 以及 $p$ 和 $q$ 的角色。
  \item $\code(ib,jc)$ 和 $\code(jc,ib)$ 类似，奇偶性 (parity) 改变，因此它们从一个类型开始并结束于另一个类型。
  \item 对于 $a:A$ 和 $b:B$，我们需要一个等价：
  \begin{equation}
    \code(ib, ifa) \eqvsym \code(ib,jga)。\label{eq:bfa-bga}
  \end{equation}
  我们将其定义为通过以下序列定义的两个函数的组合：
  \begin{align*}
  (\dots, y_n, p_n,fa) &\mapsto (\dots,y_n,p_n,a,\refl{ga},ga),\\
  (\dots, x_n, p_n, a, \refl{fa}, fa) &\mapsfrom (\dots, x_n, p_n, ga)。
  \end{align*}
  这两个函数很容易看出是尊重等价关系的，因此定义了类型代码上的函数。这两个复合函数 (left-to-right-to-left composite) 是
  \[ (\dots, y_n, p_n,fa) \mapsto
  (\dots,y_n,p_n,a,\refl{ga},a,\refl{fa},fa)
  \]
  通过集合商的生成等式，它等同于恒等映射。另一个复合也是类似的。因此我们定义了等价关系~\eqref{eq:bfa-bga}。
  \item 类似地，我们需要以下等价关系：
  \begin{align*}
    \code(jc,ifa) &\eqvsym \code(jc,jga)\\
    \code(ifa,ib)&\eqvsym (jga,ib)\\
    \code(ifa,jc)&\eqvsym (jga,jc)
  \end{align*}
  所有这些都以完全相同的方式定义（后两个通过在开头而不是结尾添加反身性 (reflexivity) 项）。
  \item 最后，我们需要知道对于 $a,a':A$，以下图表是交换的：
  \begin{equation}\label{eq:bfa-bga-comm}
  \vcenter{\xymatrix{
    \code(ifa,ifa') \ar[r]\ar[d] &
    \code(ifa,jga')\ar[d]\\
    \code(jga,ifa')\ar[r] &
    \code(jga,jga')
  }}
  \end{equation}
  这意味着，如果我们在序列的开头添加某物，然后在结尾添加某物，我们不妨按照另一种顺序进行。
\end{itemize}

\begin{rmk}\label{rmk:naive}
在 $\code$ 的定义中，您可能期望看到一些额外的集合商生成等式，例如：
\begin{align*}
(\dots, p_{k-1} \ct fw, x_{k}', q_{k}, \dots) &=
(\dots, p_{k-1}, x_{k}, gw \ct q_{k}, \dots)
\tag{for $w:\Pi_1A(x_{k},x_{k}')$}\\
(\dots, q_k \ct gw, y_k', p_k, \dots) &=
(\dots, q_k, y_k, fw \ct p_k, \dots)。
\tag{for $w:\Pi_1A(y_k, y_k')$}
\end{align*}
但是，这些是多余的！事实上，它们自动地通过路径归纳得到。这是“朴素”van Kampen 定理和我们将在下一小节中考虑的更精细版本之间的主要区别。
\end{rmk}

继续，我们可以刻画在纤维化 $\code$ 中的传输：
\begin{itemize}
  \item 对于 $p:b=_B b'$ 和 $u:P$，我们有
  \[ \mathsf{transport}^{b\mapsto \code(u,ib)}(p, (\dots, y_n,p_n,b))
  = (\dots,y_n,p_n\ct p,b')。
  \]
  \item 对于 $q:c=_C c'$ 和 $u:P$，我们有
  \[ \mathsf{transport}^{c\mapsto \code(u,jc)}(q, (\dots, x_n,q_n,c))
  = (\dots,x_n,q_n\ct q,c')。
  \]
\end{itemize}
这里我们在符号上滥用了同一个名字来表示 $X$ 中的路径及其在 $\Pi_1X$ 中的图像。注意，在 $\Pi_1X$ 中的传输也是通过路径的图像进行连接 (concatenation)。从这一点出发，我们可以通过归纳法证明上述陈述。我们还有：
\begin{itemize}
  \item 对于 $a:A$ 和 $u:P$，
  \[ \mathsf{transport}^{v\mapsto \code(u,v)}(ha, (\dots, y_n,p_n,fa))
  = (\dots,y_n,p_n,a,\refl{ga},ga)。
  \]
\end{itemize}
这实际上是从 $\code$ 的定义中得出的。

我们还构建了一个函数
\[ r : \prd{u:P} \code(u,u) \]
通过归纳法对 $u$ 进行如下定义：
\begin{align*}
  rib &\defeq (b,\refl{b},b)\\
  rjc &\defeq (c,\refl{c},c)
\end{align*}
对于 $rka$，我们取复合等式
\begin{align*}
(ka,ka)_* (fa,\refl{fa},fa)
&= (ga,\refl{ga},a,\refl{fa},a,\refl{ga},ga) \\
&= (ga,\refl{ga},ga)
\end{align*}
其中第一个等式通过上面关于 $\code$ 中传输的观察得到，第二个等式是定义 $\code$ 的集合商关系的实例。

我们现在将证明：
\begin{thm}[朴素 van Kampen 定理 (Naive van Kampen theorem)]\label{thm:naive-van-kampen}
对于所有 $u,v:P$ 存在一个等价
\[ \Pi_1P(u,v) \eqvsym \code(u,v)。\]
\end{thm}
\begin{proof}

  要定义一个函数
  \[ \encode : \Pi_1P(u,v) \to \code(u,v) \]
  只需定义一个函数 $(u=_P v) \to \code(u,v)$，因为 $\code(u,v)$ 是一个集合。我们通过传输来实现这一点：
  \[\encode(p) \defeq \mathsf{transport}^{v\mapsto \code(u,v)}(p,r(u))。\]
  现在要定义
  \[ \decode: \code(u,v) \to \Pi_1P(u,v) \]
  我们照常通过归纳法对 $u,v:P$ 进行处理。在每种情况下，对于 $u$ 和 $v$，我们将 $i$ 或 $j$ 应用于所有 $p_k$ 和 $q_k$ 的等式，并使用 $h$ 连接这些结果在 $P$ 中的结果。例如，当 $u\jdeq ib$ 和 $v\jdeq ib'$ 时，我们定义
  \begin{narrowmultline}\label{eq:decode}
  \decode(b, p_0, x_1, q_1, y_1, p_1, \dots, y_n, p_n, b') \defeq\narrowbreak
  (p_0)\ct h(x_1) \ct j(q_1) \ct \opp{h(y_1)} \ct i(p_1) \ct \cdots \ct \opp{h(y_n)}\ct i(p_n)。
  \end{narrowmultline}
  这尊重集合商的等价关系和等价关系 (equivalences) 例如~\eqref{eq:bfa-bga}，因为 $h: fi \htpy gj$ 是自然的，且 $f$ 和 $g$ 是函子性的。

  与往常一样，要显示复合
  \[ \Pi_1P(u,v) \xrightarrow{\encode} \code(u,v) \xrightarrow{\decode} \Pi_1P(u,v) \]
  是恒等式，首先去掉 0-截断（因为同域是一个集合），然后应用路径归纳法。输入 $\refl{u}$ 转换为 $ru$，然后再转换回 $\refl u$（应用进一步的归纳法对 $u$ 进行分解 $\decode(ru)$）。

  最后，考虑复合
  \[  \code(u,v) \xrightarrow{\decode} \Pi_1P(u,v) \xrightarrow{\encode} \code(u,v) \]
  我们通过归纳法处理 $u,v:P$。当 $u\jdeq ib$ 和 $v\jdeq ib'$ 时，此复合为
%
  \begin{narrowmultline*}
  (b, p_0, x_1, q_1, y_1, p_1, \dots, y_n, p_n, b')
    \narrowbreak
    \begin{aligned}[t]
      &\mapsto \Big(ip_0\ct hx_1 \ct jq_1 \ct \opp{hy_1} \ct ip_1 \ct \cdots \ct \opp{hy_n}\ct ip_n\Big)_*(rib)\\
      &= (ip_n)_* \cdots(jq_1)_* (hx_1)_*(ip_0)_*(b,\refl{b},b)\\
      &= (ip_n)_* \cdots(jq_1)_* (hx_1)_*(b,p_0,ifx_1)\\
      &= (ip_n)_* \cdots(jq_1)_* (b,p_0,x_1,\refl{gx_1},jgx_1)\\
      &= (ip_n)_* \cdots (b,p_0,x_1,q_1,jgy_1)\\
      &= \quad\vdots\\
      &= (b, p_0, x_1, q_1, y_1, p_1, \dots, y_n, p_n, b')。
    \end{aligned}
  \end{narrowmultline*}
%
  即，恒等函数。(为准确起见，这里需要一个隐式的归纳论证。)其他三种点情况是类似的，由于所有类型都是集合，路径情况是平凡的。
\end{proof}

\index{编码-解码方法|encode-decode method|)}%

\cref{thm:naive-van-kampen} 使我们能够计算许多类型的基本群，前提是 $A$ 是一个集合，因为在这种情况下，每个 $\code(u,v)$ 是通过关系定义的一个集合的集合商。

\begin{eg}\label{eg:circle}
设 $A\defeq \bool$，$B\defeq\unit$，$C\defeq \unit$。则 $P \eqvsym S^1$。检查定义，例如 $\code(i(\ttt),i(\ttt))$，我们看到路径可能全是平凡的，所以唯一的信息在于序列中的元素 $x_1,y_1,\dots,x_n,y_n: \bool$。此外，如果我们有 $x_k=y_k$ 或 $y_k=x_{k+1}$ 对于任何 $k$，则集合商关系允许我们剔除这些元素。因此，每个这样的序列都等同于一个标准的\emph{化简}序列，其中没有两个相邻的元素相等。显然，这样的化简序列唯一地由其长度（自然数 $n$）确定，若 $n>1$，还需要知道 $x_1$ 是 $\bfalse$ 还是 $\btrue$，因为这决定了序列的其余部分。这些数据当然可以与一个整数相等，其中 $n$ 是绝对值，$x_1$ 编码符号。因此，我们恢复 $\pi_1(S^1)\cong \Z$。
\end{eg}

由于 \cref{thm:naive-van-kampen} 仅断言集合族的双射，这个同构 $\pi_1(S^1)\cong \Z$ 也仅是集合的双射。然而，我们可以在 $\code$ 上定义一个连接运算（通过连接序列），并证明 $\encode$ 和 $\decode$ 形成一个尊重这种结构的同构。（在 \cref{cha:category-theory} 的语言中，这些将是“准群胚”。）我们把细节留给读者。

\index{基本!群|(fundamental!group|(}%

\begin{eg}\label{eg:suspension}
更一般地，设 $B\defeq\unit$ 和 $C\defeq \unit$，但 $A$ 是任意的，因此 $P$ 是 $A$ 的悬挂 (suspension)。那么路径 $p_k$ 和 $q_k$ 再次是平凡的，因此路径代码中的唯一信息是序列中的元素 $x_1,y_1,\dots,x_n,y_n: A$。前两个生成等式表明相邻的相等元素可以被取消，因此可以将此序列视为如下形式的单词
\[ x_1 y_1^{-1} x_2 y_2^{-1} \cdots x_n y_n^{-1} \]
在一个群中。实际上，它看起来类似于 $A$ 上的自由群 (free group)（或等价于在 $\trunc0A$ 上；见 \cref{thm:freegroup-nonset}），但我们只考虑以未反转元素开头、在反转和未反转元素之间交替并以反转元素结束的单词。这实际上减少了生成集合的大小。例如，如果 $A$ 有一个点 $a:A$，则我们可以将 $\pi_1(\susp A)$ 与 $\trunc0A$ 作为生成器的群等同起来，关系为 $\tproj0a = e$；参见 \cref{ex:vksusppt,ex:vksuspnopt} 获取详细信息。
\end{eg}

\begin{eg}\label{eg:wedge}
设 $A\defeq\unit$ 并且 $B$ 和 $C$ 是任意的，因此 $f$ 和 $g$ 只是给 $B$ 和 $C$ 赋予基点 $b$ 和 $c$。然后 $P$ 是 $B$ 和 $C$ 的\emph{楔形 (wedge)} $B\vee C$（在基空间范畴中的余积）。在这种情况下，是元素 $x_k$ 和 $y_k$ 是平凡的，因此唯一的信息是循环序列 $(p_0,q_1,p_1,\dots,p_n)$，其中 $p_k:\pi_1(B,b)$ 和 $q_k:\pi_1(C,c)$。这种序列，可通过我们施加的等价关系轻松识别为 $\pi_1(B\vee C) \cong \pi_1(B) * \pi_1(C)$ 的显式描述，正如在 \cref{sec:free-algebras} 中构建的那样。因此，我们有 $\pi_1(B\vee C) \cong \pi_1(B) * \pi_1(C)$。
\end{eg}

\index{基本!群|(fundamental!group|)}%

然而，\cref{thm:naive-van-kampen} 与完整的经典 van Kampen 定理略有不同，后者处理 $A$ 不是集合的情况，并且声明 $\pi_1(B\sqcup^A C) \cong \pi_1(B) *_{\pi_1(A)} \pi_1(C)$（基点来自 $A$）。确实，\cref{thm:naive-van-kampen} 的结论完全没有涉及 $\pi_1(A)$；路径 $A$ 中的路径“内建在等价关系”中，这种类型论的方式使得显式提取信息变得困难，因为 $\code(u,v)$ 是通过关系定义的一个非集合的集合商。出于这个原因，在下一小节中我们将考虑 van Kampen 定理的更好版本。

\subsection{带有基点集合的 van Kampen 定理}
\label{sec:better-vankampen}

\index{basepoint!set of}%
我们现在提出的 van Kampen 的改进与经典代数拓扑中的类似改进密切相关，在经典代数拓扑中，$A$ 配有一个\emph{基点集合} $S$。实际上，事实证明，在我们的证明中无需假设“基点集合”是一个\emph{集合}——它可能是一个任意类型；假设 $S$ 是一个集合的实用性在于稍后的应用定理以获得计算。重要的是，$S$ 包含 $A$ 的每个连通分量中的至少一个点。我们在类型论中通过一个类型 $S$ 和一个函数 $k:S \to A$ 来表达这一点，该函数是满射，即 $(-1)$-连通。如果 $S\jdeq A$ 且 $k$ 是恒等函数，那么我们将恢复朴素的 van Kampen 定理。要牢记的另一个例子是当 $A$ 是有基点的且 (0-) 连通时，并且 $k:\unit\to A$ 是基点：根据 \cref{thm:minusoneconn-surjective,thm:connected-pointed}，该映射是满射恰好是当 $A$ 是 0-连通时。

设 $A,B,C,f,g,P,i,j,h$ 如上一节所述。现在我们定义给定我们的满射映射 $k:S\to A$ 的辅助类型，该类型可以改善 $k$ 的连通性。设 $T$ 是由以下生成的高阶归纳类型：
\begin{itemize}
  \item 一个函数 $\ell:S\to T$，以及
  \item 对每个 $s,s':S$，一个函数 $m:(\id[A]{ks}{ks'}) \to (\id[T]{\ell s}{\ell s'})$。
\end{itemize}
存在一个显然的诱导函数 $\kbar:T\to A$，使得 $\kbar \ell = k$，并且任何 $p:ks=ks'$ 等于复合 $ks = \kbar \ell s \overset{\kbar m p}{=} \kbar \ell s' = k s'$。

\begin{lem}\label{thm:kbar}
$\kbar$ 是 0-连通的。
\end{lem}
\begin{proof}
  我们必须展示对于所有 $a:A$，类型 $\sm{t:T}(\kbar t = a)$ 的 0-截断是收缩的。由于收缩性是一个纯粹命题，并且 $k$ 是 $(-1)$-连通的，我们可以假设 $a=ks$ 对于某个 $s:S$。现在我们可以取收缩中心为 $\tproj0{(\ell s,q)}$，其中 $q$ 是等式 $\kbar\ell s = k s$。

  剩下的是展示对于任何 $\phi:\trunc0{\sm{t:T} (\kbar t = ks)}$ 我们有 $\phi = \tproj0{(\ell s,q)}$。由于后者是一个纯粹命题，且特别是一个集合，我们可以假设 $\phi=\tproj0{(t,p)}$ 对于某个 $t:T$ 和 $p:\kbar t = ks$。

  现在我们可以对 $t:T$ 进行归纳。如果 $t\jdeq\ell s'$，则 $ks' = \kbar \ell s' \overset{p}{=} ks$ 通过 $m$ 得到一个等式 $\ell s = \ell s'$。因此根据 $\kbar$ 和同伦纤维中的等式的定义，我们得到等式 $(ks',p) = (ks,q)$，因此 $\tproj0{(ks',p)} = \tproj0{(ks,q)}$。接下来我们必须展示当 $t$ 沿着 $m$ 变化时这些等式是一致的。但它们是集合中的等式（即 $\trunc0{\sm{t:T} (\kbar t = ks)}$），因此这是自动的。
\end{proof}

\begin{rmk}
  \index{kernel!pair}%
  $T$ 可以看作 $k$ 的“核对偶对 (kernel pair)”的（同伦）余等化子。如果 $S$ 和 $A$ 是集合，那么 $(-1)$-连通性 $k$ 意味着 $A$ 是这个余等化子的 0-截断（见 \cref{cha:set-math}）。对于一般类型，高阶拓扑理论表明，$(-1)$-连通性 $k$ 将意味着 $A$ 是这个“单形核 (simplicial kernel)”的余极限（又名“几何实现 (geometric realization)”）。\index{.infinity1-topos@$(\infty,1)$-topos}\index{geometric realization}\index{simplicial!kernel}\index{kernel!simplicial}类型 $T$ 是这个单形核的“1-骨架 (1-skeleton)”的余极限，因此它改善了 $k$ 的连通性 1。更一般地，我们可以预期 $n$-骨架的余极限\index{skeleton!of a CW-complex}将连通性提高 $n$。
\end{rmk}

\index{encode-decode method|(}%

现在我们通过双重归纳来定义 $\code:P\to P\to \type$ 如下：
\begin{itemize}
  \item $\code(ib,ib')$ 现在是类型的一个集合商
  \[ (b, p_0, x_1, q_1, y_1, p_1, x_2, q_2, y_2, p_2, \dots, y_n, p_n, b') \]
  其中
  \begin{itemize}
    \item $n:\mathbb{N}$，
    \item $x_k:S$ 和 $y_k:S$ 对于 $0<k \le n$，
    \item $p_0:\Pi_1B(b,f k x_1)$ 和 $p_n:\Pi_1B(f k y_n, b')$ 对于 $n>0$，且 $p_0:\Pi_1B(b,b')$ 对于 $n=0$，
    \item $p_k:\Pi_1B(fk y_k, fkx_{k+1})$ 对于 $1\le k < n$，
    \item $q_k:\Pi_1C(gkx_k, gky_k)$ 对于 $1\le k\le n$。
  \end{itemize}
  生成集合商的等式如下（见 \cref{rmk:naive}）：
  \begin{align*}
  (\dots, q_k, y_k, \refl{fy_k}, y_k, q_{k+1},\dots)
    &= (\dots, q_k\ct q_{k+1},\dots)\\
    (\dots, p_k, x_k, \refl{gx_k}, x_k, p_{k+1},\dots)
    &= (\dots, p_k\ct p_{k+1},\dots)\\
    (\dots, p_{k-1} \ct fw, x_{k}', q_{k}, \dots) &=
    (\dots, p_{k-1}, x_{k}, gw \ct q_{k}, \dots)
    \tag{for $w:\Pi_1A(kx_{k},kx_{k}')$}\\
    (\dots, q_k \ct gw, y_k', p_k, \dots) &=
    (\dots, q_k, y_k, fw \ct p_k, \dots)。
    \tag{for $w:\Pi_1A(ky_k, ky_k')$}
  \end{align*}
  我们需要下面 $\decode$ 的情况定义，该定义与之前类似，将所有路径 $p_k$ 和 $q_k$ 连接在一起并与 $h$ 的实例一起给出 $\Pi_1P(ifb,ifb')$ 的元素，参见~\eqref{eq:decode}。如前所述，其他三种点情况几乎相同。
  \item 对于 $a:A$ 和 $b:B$，我们需要一个等价
  \begin{equation}
    \code(ib, ifa) \eqvsym \code(ib,jga)。\label{eq:bfa-bga2}
  \end{equation}
  由于 $\code$ 是集合值的，根据 \cref{thm:kbar} 我们可以假设 $a=\kbar t$ 对于某个 $t:T$。接下来，我们可以对 $t$ 进行归纳。如果 $t\jdeq \ell s$ 对于 $s:S$，那么我们定义~\eqref{eq:bfa-bga2} 如在 \cref{sec:naive-vankampen} 中一样：
  \begin{align*}
  (\dots, y_n, p_n,fks) &\mapsto (\dots,y_n,p_n,s,\refl{gks},gks),\\
  (\dots, x_n, p_n, s, \refl{fks}, fks) &\mapsfrom (\dots, x_n, p_n, gks)。
  \end{align*}
  这些等式关系，并且正如之前一样定义准逆。现在假设 $t$ 沿着 $m_{s,s'}(w)$ 对某个 $w:ks=ks'$ 变化；我们必须证明~\eqref{eq:bfa-bga2} 尊重沿着 $\kbar mw$ 的传输。根据 $\kbar$ 的定义，这实质上归结为沿着 $w$ 自身的传输。根据路径类型中的传输特性，我们需要展示的是
  \[ w_*(\dots, y_n, p_n,fks) = (\dots,y_n, p_n \ct fw, fks') \]
  被映射到~\eqref{eq:bfa-bga2}
  \[ w_*(\dots,y_n,p_n,s,\refl{gks},gks) = (\dots, y_n, p_n, s, \refl{gks} \ct gw, gks') \]
  但这直接从我们施加的定义 \code 的生成等式关系得到。
  \item 其他三个所需的等价定义类似。
  \item 最后，由于交换性~\eqref{eq:bfa-bga-comm} 是一个纯粹命题，根据 $(-1)$-连通性 $k$ 我们可以假设 $a=ks$ 和 $a'=ks'$，在这种情况下它和以前一样跟随。
\end{itemize}

\begin{thm}[带有基点集合的 van Kampen]\label{thm:van-Kampen}
对于所有 $u,v:P$ 存在一个等价
\[ \Pi_1P(u,v) \eqvsym \code(u,v)。\]
\code 的定义如在本节中所述。
\end{thm}

\begin{proof}
  基本和之前一样。为了证明 $\decode$ 尊重新的集合商生成器，我们使用 $h$ 的自然性。并且为了证明 $\decode$ 尊重诸如~\eqref{eq:bfa-bga2} 的等价，我们需要对 $\kbar$ 和 $T$ 进行归纳，以便将这些等价分解为其定义，但随后它又成为 $f$ 和 $g$ 的简化函数性。其余的很容易。特别是对于 $\encode\circ\decode$ 不需要额外的论证，因为目标是证明集合中的等式，因此 $h$ 的情况是微不足道的。
\end{proof}

\index{encode-decode method|)}%

\index{基本!群|(fundamental!group|(}%
\cref{thm:van-Kampen} 允许我们计算空间 $A$ 的基本群，即使 $A$ 不是一个集合，前提是 $S$ 是一个集合，因为在这种情况下，每个 $\code(u,v)$ 是由一个关系定义的一个\emph{集合}的集合商。在这方面，它是 \cref{thm:naive-van-kampen} 的改进。

\begin{eg}\label{eg:clvk}
假设 $S\defeq \unit$，因此 $A$ 有一个基点 $a \defeq k(\ttt)$ 并且是连通的。然后推挤中的循环的代码可以与在 $\pi_1(B,f(a))$ 和 $\pi_1(C,g(a))$ 中的循环的交替序列相识别，模糊等价关系允许我们在它们之间滑动 $\pi_1(A,a)$ 的元素（在分别应用 $f$ 和 $g$ 之后）。因此，$\pi_1(P)$ 可以识别为\emph{并入自由积 (amalgamated free product)} $\pi_1(B) *_{\pi_1(A)} \pi_1(C)$（在群范畴中的推挤），如 \cref{sec:free-algebras} 中构建的那样。这（在 $B$ 和 $C$ 是 $P$ 的开子空间并且 $A$ 是它们的交集时）是 van Kampen 定理的最经典的版本。
\end{eg}

\begin{eg}\label{eg:cofiber}
\index{余纤维 (cofiber)}
作为 \cref{eg:clvk} 的一个特例，假设额外地 $C\defeq\unit$，因此 $P$ 是余纤维 $B/A$。然后在 $C$ 中的每个循环都是反身的，因此路径代码上的关系允许我们将所有序列压缩为 $B$ 中的一个单一循环。额外的关系要求通过 $\pi_1(A)$ 映射的在左边、右边或中间乘积的元素是单位元。因此我们可以将 $\pi_1(B/A)$ 识别为群 $\pi_1(B)$ 的商，商中子群是 $\pi_1(A)$ 的像生成的正则子群。
\end{eg}

\begin{eg}\label{eg:torus}
\index{环面 (torus)}
作为 \cref{eg:cofiber} 的进一步特例，设 $B\defeq S^1 \vee S^1$，设 $A\defeq S^1$，并且设 $f:A\to B$ 选取复合循环 $p \ct q \ct \opp p \ct \opp q$，其中 $p$ 和 $q$ 是组成 $B$ 的两个 $S^1$ 的生成循环。然后 $P$ 是环面 $T^2$ 的表示。实际上，将 $P$ 与 \cref{sec:hubs-spokes} 中描述的 $T^2$ 的表示联系起来并不难，使用了一个特定循环的锥形。因此，$\pi_1(T^2)$ 是由两个生成元的自由\emph{阿贝尔 (abelian)}群，即 $\Z\times\Z$ 。
\end{eg}


\begin{eg}
  \index{CW 复形 (CW complex)}
  \index{hub and spoke}
  更一般地，任何 CW 复形都可以通过反复“锥化 (coning off)”球面来获得，如 \cref{sec:hubs-spokes} 中描述的那样。也就是说，我们从一组点 $X_0$（“0-胞元 (0-cells)”）开始，它是 CW 复形的“0-骨架 (0-skeleton)”。我们采取推挤
  \begin{equation*}
    \vcenter{\xymatrix{
      S_1 \times \Sn^0\ar[r]^-{f_1}\ar[d] &
      X_0\ar[d]\\
      \unit \ar[r] &
      X_1
    }}
  \end{equation*}
  对于某个 1-胞元的集合 $S_1$ 和一些“附着映射 (attaching maps)” $f_1$，得到“1-骨架”$X_1$。\index{attaching map}% 然后我们采取推挤
  \begin{equation*}
    \vcenter{\xymatrix{
      S_2 \times \Sn^1\ar[r]^{f_2}\ar[d] &
      X_1\ar[d]\\
      \unit \ar[r] &
      X_2
    }}
  \end{equation*}
  对于某个 2-胞元的集合 $S_2$ 和一些附着映射 $f_2$，得到 2-骨架 $X_2$，依此类推。可以根据 van Kampen 定理计算每个推挤的基本群：我们获得了由 1-骨架导出的生成元和由 $S_2$ 和 $f_2$ 导出的关系。此阶段之后的推挤不会改变基本群，因为 $\pi_1(\Sn^n)$ 对于 $n>1$ 是平凡的（见 \cref{sec:pik-le-n}）。
\end{eg}


\begin{eg}\label{eg:kg1}
特别地，假设给定一个群 $G = \langle X \mid R \rangle$ 的表示（集合群），其中 $X$ 是生成元的集合 $R$ 是这些生成元的词。设 $B\defeq \bigvee_X S^1$ 并且 $A\defeq \bigvee_R S^1$，$f:A\to B$ 发送 $S^1$ 的每个拷贝到 $B$ 的生成循环中的相应词。由此可以得出 $\pi_1(P) \cong G$；因此我们构造了一个连通类型，其基本群为 $G$。如果我们对该类型进行 1-截断，我们得到一个唯一非平凡同伦群为 $G$ 的类型；这被称为\define{Eilenberg--Mac Lane 空间 (Eilenberg--Mac Lane space)} $K(G,1)$。%
\indexdef{Eilenberg--Mac Lane space}%
\end{eg}

\index{基本!群|)}%

\index{van Kampen 定理|)}%
\index{theorem!van Kampen|)}%

\section{Whitehead 定理和 Whitehead 原则}
\label{sec:whitehead}

在经典同伦理论中，一个映射 $f:A\to B$ 如果对 $A$ 中的所有点 $a$ 都诱导了同构 $\pi_n(A,a) \cong \pi_n(B,f(a))$ （并且 $\pi_0(A)\cong\pi_0(B)$ 也是同构），那么在 $A$ 和 $B$ 是“良好行为”空间（例如具有 CW 复形的同伦类型）时，该映射必然是同伦等价。这就是所谓的 \emph{Whitehead 定理 (Whitehead's theorem)}。
\index{theorem!Whitehead's}%
\index{Whitehead's!theorem}%
事实上，对于那些 Whitehead 定理失效的“行为不良”的空间，类型论是不可见的。大致来说，良好行为的拓扑空间足以表示 $\infty$-群胚 ($\infty$-groupoids)%
\index{.infinity-groupoid@$\infty$-groupoid}
，而同伦类型论 (Homotopy Type Theory) 直接处理 $\infty$-群胚，而不是实际的拓扑空间。因此，人们可能会期望 Whitehead 定理在一致性基础中成立。

然而，事实并非如此：Whitehead 定理无法证明。事实上，在一些模型中，这个定理是错误的，虽然其失效的原因与其在行为不良的拓扑空间中失效的原因完全不同。这些模型是“非超完全 $\infty$-拓扑范畴” (non-hypercomplete $\infty$-toposes)
\index{.infinity1-topos@$(\infty,1)$-topos}%
\index{.infinity1-topos@$(\infty,1)$-topos!non-hypercomplete}%
（参见~\cite{lurie:higher-topoi}）；大致而言，它们由在 $\infty$ 维基空间上面的 $\infty$-群胚的层 (sheaves) 组成。

\index{axiom!Whitehead's principle|(}%
\index{Whitehead's!principle|(}%

从基础理论的角度来看，因此我们可以将 \emph{Whitehead 原则 (Whitehead's principle)} 视为一种“经典性公理”，类似于 \LEM{} 和 \choice{}。它可以被一致地假设，但它不是计算动机类型论的一部分，也不在所有自然模型中成立。但是当从集合论基础出发时，这一原则是不可见的：在一个由集合构建的世界中（使用拓扑空间、单纯集合或任何其他此类模型），它无法失效。

这可能看起来很奇怪，但实际上并不奇怪。同伦类型论是同伦类型的 \emph{抽象} 理论，而集合论中的拓扑空间或单纯集合的同伦理论是该理论的 \emph{具体} 模型，就像整数是环的抽象理论的具体模型一样。可以预见的是，任何具体模型都会具有抽象理论所不具备的特殊性质，但有时我们可能希望将这些性质假设为额外的公理（例如，整数是主理想整环，但并非所有环都是）。

本书不打算描述任何类型论的模型，因此我们不会解释 Whitehead 原则在其中某些模型中如何可能失效。然而，我们可以证明，只要涉及的类型对于某个有限的 $n$ 是 $n$-截断的 (truncated)，那么 Whitehead 原则就成立，并且可以通过对 $n$ 的“向下”归纳来证明。除了它本身的兴趣（例如，它意味着 Eilenberg--Mac Lane 空间的本质唯一性），这一结果的证明还希望能为我们无法在没有截断假设的情况下证明类似定理的原因提供一些直观的解释。

我们从 \cref{thm:mono-surj-equiv} 的以下修改开始，它将最终为截断的 Whitehead 原则的证明提供归纳步骤。可以将其视为类型论的、$\infty$-群胚的版本的经典陈述：一个完全忠实且本质上满射的函子是范畴的等价。

\begin{thm}\label{thm:whitehead0}
假设 $f:A\to B$ 是一个函数，使得
\begin{enumerate}
  \item $\trunc0 f : \trunc0 A \to \trunc0 B$ 是满射，且\label{item:whitehead01}
  \item 对于任意 $x,y:A$，函数 $\apfunc f : (\id[A]xy) \to (\id[B]{f(x)}{f(y)})$ 是等价的。\label{item:whitehead02}
\end{enumerate}
那么 $f$ 是等价映射。
\end{thm}
\begin{proof}
  注意~\ref{item:whitehead02} 恰好是 $f$ 是嵌入的陈述，参见~\cref{sec:mono-surj}。因此，根据 \cref{thm:mono-surj-equiv}，只需证明 $f$ 是满射的，即对于任意 $b:B$，我们有 $\trunc{-1}{\hfib f b}$。
  假设给定 $b$；那么由于 $\trunc0 f$ 是满射，因此仅仅存在一个 $a:A$ 使得 $\trunc 0 f(\tproj0a) = \tproj0b$。并且由于我们的目标是一个仅仅存在的命题，我们可以假设给定了这样的 $a$。
  然后我们有 $\tproj0{f(a)} = \trunc 0 f(\tproj0a) =\tproj0b$，因此 $\trunc{-1}{f(a)=b}$。
  再次，由于我们的目标仍然是一个仅仅存在的命题，我们可以假设 $f(a)=b$。
  因此 $\hfib f b$ 是有居留元的 (inhabited)，并且因此仅仅是有居留元的。
\end{proof}

由于同伦群 (homotopy groups) 是循环空间的截断 (truncations of loop spaces) \index{loop space}，而不是路径空间，因此我们需要修改此定理以讨论这些内容。回忆来自 \cref{def:loopfunctor} 的映射 $\Omega f$。

\begin{cor}\label{thm:whitehead1}
假设 $f:A\to B$ 是一个函数，使得
\begin{enumerate}
  \item $\trunc0 f : \trunc0 A \to \trunc0 B$ 是双射，且
  \item 对于任意 $x:A$，函数 $\Omega f : \Omega(A,x) \to \Omega(B,f(x))$ 是等价映射。
\end{enumerate}
那么 $f$ 是等价映射。
\end{cor}
\begin{proof}
  根据 \cref{thm:whitehead0}，只需证明 $\apfunc f : (\id[A]xy) \to (\id[B]{f(x)}{f(y)})$ 对于任意 $x,y:A$ 是等价的。
  根据 \cref{thm:equiv-inhabcod}，我们可以假设 $\id[B]{f(x)}{f(y)}$。
  特别地，$\tproj0{f(x)} = \tproj0{f(y)}$，因此由于 $\trunc0 f$ 是等价映射，我们有 $\tproj0 x = \tproj0y$，因此 $\tproj{-1}{x=y}$。
  由于我们正在尝试证明一个仅仅存在的命题（$\apfunc f$ 是等价的），我们可以假设给定 $p:x=y$。
  但是现在，以下图表最多齐次地 (up to homotopy) 交换：
  \begin{equation*}
    \vcenter{\xymatrix@C=3pc{
      \Omega(A,x)\ar[r]^-{\blank\ct p}\ar[d]_{\Omega f} &
      (\id[A]xy) \ar[d]^{\apfunc f}\\
      \Omega(B,f(x))\ar[r]_-{\blank\ct f(p)} &
      (\id[B]{f(x)}{f(y)}).
    }}
  \end{equation*}
  顶部和底部的映射是等价映射，左侧的映射是根据假设得出的等价映射。
  因此，根据 2-out-of-3 性质，右侧的映射也是等价的。
\end{proof}

现在我们可以证明截断的 Whitehead 原则。

\begin{thm}\label{thm:whiteheadn}
假设 $A$ 和 $B$ 是 $n$-类型 (n-types)，并且 $f:A\to B$ 使得
\begin{enumerate}
  \item $\trunc0f:\trunc0A \to \trunc0B$ 是双射，且\label{item:wh0}
  \item $\pi_k(f):\pi_k(A,x) \to \pi_k(B,f(x))$ 对于所有 $k\ge 1$ 和所有 $x:A$ 是双射。\label{item:whk}
\end{enumerate}
那么 $f$ 是等价映射。
\end{thm}

\noindent
条件~\ref{item:wh0} 几乎是 $k=0$ 时~\ref{item:whk} 的情况，除了它没有提到任何基点 $x:A$。

\begin{proof}
  我们通过对 $n$ 的归纳来证明。
  当 $n=-2$ 时，陈述是平凡的。
  因此，假设对于所有 $n$-类型之间的函数来说，它都是正确的，并且设 $A$ 和 $B$ 是 $(n+1)$-类型，并且 $f:A\to B$ 如上所述。
  \cref{thm:whitehead1} 中的第一个条件由假设得出，因此只需证明对于任意 $x:A$，函数 $\Omega f: \Omega(A,x) \to \Omega(B,f(x))$ 是等价映射即可。

  由于 $\Omega(A,x)$ 和 $\Omega(B,f(x))$ 是 $n$-类型，我们可以应用归纳假设。
  我们需要检查 $\trunc 0{\Omega f}$ 是双射，并且对于所有 $k\geq1$ 和 $p : x = x$，映射 $\pi_k(\Omega f):\pi_k(x = x,p) \to \pi_k(f(x) = f(x),\Omega f(p))$ 是双射。
  第一个陈述由假设成立，因为 $\trunc 0{\Omega f} \jdeq \pi_1(f)$。
  为了证明第二个陈述，我们首先将其泛化：我们证明对于所有 $y : A$ 和 $q : x = y$，我们有 $\pi_k(\apfunc f):\pi_k(x = y,q) \to \pi_k(f(x) = f(y),\apfunc f(q))$。
  这意味着所需的陈述，因为当 $y\defeq x$ 时，我们有 $\pi_k(\Omega f)=\pi_k(\apfunc f)$，等同于识别它们的基点 $\Omega f(p)=\apfunc f(p)$。
  为了证明泛化，通过路径归纳，足以证明当 $q$ 是 $\refl{a}$ 时的情况。
  在这种情况下，我们有 $\pi_k(\apfunc f) = \pi_k(\Omega f) = \pi_{k+1}(f)$，并且 $\pi_{k+1}(f)$ 根据原始假设是双射。
\end{proof}

请注意，如果 $A$ 和 $B$ 不是任何有限 $n$ 的 $n$-类型，那么归纳将无法启动。

\begin{cor}\label{thm:whitehead-contr}
如果 $A$ 是 $0$-连通的 $n$-类型，并且 $\pi_k(A,a)=0$ 对于所有 $k$ 和 $a:A$，那么 $A$ 是收缩的 (contractible)。
\end{cor}
\begin{proof}
  将 \cref{thm:whiteheadn} 应用于映射 $A\to\unit$。
\end{proof}

作为应用，我们可以推导出 \cref{thm:conn-pik} 的逆命题。

\begin{cor}\label{thm:pik-conn}
对于 $n\ge 0$，映射 $f:A\to B$ 是 $n$-连通的 (n-connected) 当且仅当以下所有条件成立：
\begin{enumerate}
  \item $\trunc0f:\trunc0A \to \trunc0B$ 是同构。
  \item 对于任何 $a:A$ 和 $k\le n$，映射 $\pi_k(f):\pi_k(A,a) \to \pi_k(B,f(a))$ 是同构。
  \item 对于任何 $a:A$，映射 $\pi_{n+1}(f):\pi_{n+1}(A,a) \to \pi_{n+1}(B,f(a))$ 是满射。
\end{enumerate}
\end{cor}
\begin{proof}
  ``只有当'' 的方向是 \cref{thm:conn-pik}。
  反过来，根据纤维束的长确序列 (long exact sequence of a fibration)（\cref{thm:les}），%
  \index{sequence!exact}%
  假设条件意味着 $\pi_k(\hfib f {f(a)})=0$ 对于所有 $k\le n$ 和 $a:A$，并且 $\trunc 0{\hfib f{f(a)}}$ 是收缩的。
  由于 $\pi_k(\hfib f {f(a)}) = \pi_k(\trunc n{\hfib f{f(a)}})$ 对于 $k\le n$，并且 $\trunc n{\hfib f{f(a)}}$ 是 $n$-连通的，根据 \cref{thm:whitehead-contr}，对于任何 $a$，它是收缩的。

  仍需证明 $\trunc n{\hfib f{b}}$ 是收缩的，对于 $b:B$ 不一定是 $f(a)$ 的形式。
  然而，根据假设，存在 $x:\trunc0A$ 使得 $\tproj 0b = \trunc0f(x)$。
  由于收缩性是一个仅仅存在的命题，我们可以假设 $x$ 是 $\tproj0a$ 的形式，对于 $a:A$，在这种情况下 $\tproj 0 b = \trunc0f(\tproj0a) = \tproj0{f(a)}$，因此 $\trunc{-1}{b=f(a)}$。
  再次，由于收缩性是一个仅仅存在的命题，我们可以假设 $b=f(a)$，结果由此得出。
\end{proof}

一个使得 $\trunc0f$ 是双射并且 $\pi_k(f)$ 对于所有 $k$ 是双射的映射称为 \define{$\infty$-连通}%
\indexdef{function!.infinity-connected@$\infty$-connected}%
\indexdef{.infinity-connected function@$\infty$-connected function}
或称为 \define{弱等价}%
\indexdef{equivalence!weak}%
\indexdef{weak equivalence!of types}。
这相当于要求 $f$ 对所有 $n$ 是 $n$-连通的。
一个类型 $Z$ 称为 \define{$\infty$-截断}%
\indexdef{type!.infinity-truncated@$\infty$-truncated}%
\indexdef{.infinity-truncated type@$\infty$-truncated type}
或 \define{超完全}%
\indexdef{type!hypercomplete}%
\indexdef{hypercomplete type}，如果诱导映射
\[(\blank\circ f):(B\to Z) \to (A\to Z)\]
在 $f$ 是 $\infty$-连通时是等价映射——即，如果 $Z$ 认为每个 $\infty$-连通映射都是等价的。
\indexdef{axiom!Whitehead's principle}%
那么如果我们想要将 Whitehead 原则作为公理假设，我们可以使用以下等价形式之一。
\begin{itemize}
  \item 每个 $\infty$-连通函数都是等价映射。
  \item 每个类型都是 $\infty$-截断的。
\end{itemize}
在高阶拓扑模型中，
\index{.infinity1-topos@$(\infty,1)$-topos}%
$\infty$-截断类型在 \cref{sec:modalities} 中的意义上构成一个反射子宇宙 (reflective subuniverse)（“超完全”的 $(\infty,1)$-拓扑），但我们不知道这在一般情况下是否成立。

\index{axiom!Whitehead's principle|)}%
\index{Whitehead's!principle|)}%

可能并不明显存在不属于任何 $n$-类型的类型，但事实上是存在的。实际上，在经典同伦理论中，$\Sn^n$ 对于任何 $n\ge 2$ 都具有这种性质。我们尚未在同伦类型论中证明这一事实，但还有其他类型我们可以证明其具有“无限截断层次”。

\begin{eg}
  假设我们有 $B:\nat\to\type$ 使得对于每个 $n$，类型 $B(n)$ 包含一个 $n$-环 (n-loop)\index{loop!n-@$n$-}，该 $n$-环不等于 $n$ 重的反身性，例如 $p_n:\Omega^n(B(n),b_n)$，且 $p_n \neq \refl{b_n}^n$。
  （例如，我们可以定义 $B(n)\defeq \Sn^n$，$p_n$ 是同构 $\pi_n(\Sn^n)\cong \Z$ 下的 $1:\Z$ 的像）。
  考虑 $C\defeq \prd{n:\nat} B(n)$，点 $c:C$ 由 $c(n)\defeq b_n$ 定义。
  由于循环空间与乘积交换，对于任意 $m$，我们有
  \[\eqvspaced{\Omega^m (C,c)}{\prd{n:\nat}\Omega^m(B(n),b_n)}。\]
  在此等价下，$\refl{c}^m$ 对应于函数 $(n\mapsto \refl{b_n}^m)$。
  现在在右侧类型中定义 $q_m$
  \[ q_m(n) \defeq
  \begin{cases}
    p_n &\quad m=n\\
    \refl{b_n}^m &\quad m\neq n。
  \end{cases}
  \]
  如果我们有 $q_m = (n\mapsto \refl{b_n}^m)$，那么我们将得到 $p_n = \refl{b_n}^n$，这不符合事实。
  因此，$q_m \neq (n\mapsto \refl{b_n}^m)$，所以存在 $\Omega^m(C,c)$ 中的点与 $\refl{c}^m$ 不相等。
  因此，$C$ 不是任意 $m:\nat$ 的 $m$-类型。
\end{eg}

我们还期望可以证明宇宙 $\UU$ 本身不是任何 $n$ 的 $n$-类型，使用它包含如 $\Sn^n$ 这样的高阶归纳类型 (higher inductive types) 对于所有 $n$。然而，这尚未完成。

\section{A general statement of the encode-decode method}
\label{sec:general-encode-decode}

\indexdef{encode-decode method}

We have used the encode-decode method to characterize the path spaces
of various types, including coproducts (\cref{thm:path-coprod}), natural
numbers (\cref{thm:path-nat}), truncations (\cref{thm:path-truncation}),
the circle (\cref{{cor:omega-s1}}), suspensions (\cref{thm:freudenthal}), and pushouts
(\cref{thm:van-Kampen}).  Variants of this technique are used in the
proofs of many of the other theorems mentioned in the introduction to
this chapter, such as a direct proof of $\pi_n(\Sn^n)$, the Blakers--Massey theorem, and the construction of Eilenberg--Mac Lane spaces.
While it is tempting to try to
abstract the method into a lemma, this is difficult because
slightly different variants are needed for different problems.  For
example, different variations on the same method  can be used to
characterize a loop space (as in \cref{thm:path-coprod,cor:omega-s1}) or
a whole path space (as in \cref{thm:path-nat}), to give a complete
characterization of a loop space (e.g.\ $\Omega^1(\Sn ^1)$) or only to
characterize some truncation of it (e.g.\ van Kampen), and to calculate
homotopy groups or to prove that a map is $n$-connected (e.g.\ Freudenthal and
Blakers--Massey).

However, we can state lemmas for specific variants of the method.
The proofs of these lemmas are almost trivial; the main point is to
clarify the method by stating them in generality.  The simplest
case is using an encode-decode method to characterize the loop space of a
type, as in \cref{thm:path-coprod} and \cref{{cor:omega-s1}}.

\begin{lem}[Encode-decode for Loop Spaces]\label{lem:encode-decode-loop}
  \index{loop space}%
Given a pointed type $(A,a_0)$ and a fibration
$\code : A \to \type$, if
\begin{enumerate}
\item $c_0 : \code(a_0)$,\label{item:ed1}
\item $\decode : \prd{x:A} \code(x) \to (\id{a_0}{x})$,\label{item:ed2}
\item for all $c : \code(a_0)$, \id{\transfib{\code}{\decode(c)}{c_0}}{c}, and\label{item:ed3}
\item $\id{\decode(c_0)}{\refl{}}$,\label{item:ed4}
\end{enumerate}
then $(\id{a_0}{a_0})$ is equivalent to $\code(a_0)$.
\end{lem}

\begin{proof}
Define
$\encode : \prd{x:A} (\id{a_0}{x}) \to \code(x)$ by
\[
\encode_x(\alpha) = \transfib{\code}{\alpha}{c_0}.
\]
We show that $\encode_{a_0}$ and $\decode_{a_0}$ are quasi-inverses.
The composition $\encode_{a_0} \circ \decode_{a_0}$ is immediate by
assumption~\ref{item:ed3}.  For the other composition, we show
\[
\prd{x:A}{p : \id{a_0}{x}} \id{\decode_{x} (\encode_{x} p)}{p}.
\]
By path induction, it suffices to show
$\id{{\decode_{{a_0}} (\encode_{{a_o}} \refl{})}}{\refl{}}$.
After reducing the $\mathsf{transport}$, it suffices to show
$\id{{\decode_{{a_0}} (c_0)}}{\refl{}}$, which is assumption~\ref{item:ed4}.
\end{proof}

If a fiberwise equivalence between $(\id{a_0}{\blank})$ and $\code$ is desired,
it suffices to strengthen condition (iii) to
\[
\prd{x:A}{c : \code(x)} \id{\encode_{x}(\decode_{x}(c))}{c}.
\]
However, to calculate a loop space (e.g. $\Omega(\Sn ^1)$), this
stronger assumption is not necessary.

Another variation, which comes up often when calculating homotopy
groups, characterizes the truncation of a loop space:

\begin{lem}[Encode-decode for Truncations of Loop Spaces]
Assume a pointed type $(A,a_0)$ and a fibration
$\code : A \to \type$, where for every $x$, $\code(x)$ is a $k$-type.
Define
\[
\encode : \prd{x:A} \trunc{k}{\id{a_0}{x}} \to \code(x)
\]
by truncation recursion (using the fact
that $\code(x)$ is a $k$-type), mapping $\alpha : \id{a_0}{x}$ to
\transfib{\code}{\alpha}{c_0}. Suppose:
\begin{enumerate}
\item $c_0 : \code(a_0)$,
\item $\decode : \prd{x:A} \code(x) \to \trunc{k}{\id{a_0}{x}}$,
\item \label{item:decode-encode-loop-iii}
  $\id{\encode_{a_0}(\decode_{a_0}(c))}{c}$ for all $c : \code(a_0)$, and
\item \label{item:decode-encode-loop-iv}
  $\id{\decode(c_0)}{\tproj{}{\refl{}}}$.
\end{enumerate}
Then $\trunc{k}{\id{a_0}{a_0}}$ is equivalent to $\code(a_0)$.
\end{lem}

\begin{proof}
That $\decode \circ \encode$ is identity is immediate by \ref{item:decode-encode-loop-iii}.
%
To prove $\encode \circ \decode$, we first do a truncation induction, by
which it suffices to show
\[
\prd{x:A}{p : \id{a_0}{x}} \id{\decode_{x}(\encode_{x}(\tproj{k}{p}))}{\tproj{k}{p}}.
\]
The truncation induction is allowed because paths in a $k$-type are a
$k$-type.  To show this type, we do a path induction, and after reducing
the \encode, use assumption~\ref{item:decode-encode-loop-iv}.
\end{proof}

\section{Additional Results}
\label{sec:moreresults}

Though we do not present the proofs in this chapter, following results have also been established in homotopy type theory.

\begin{thm}
\index{homotopy!group!of sphere}
There exists a $k$ such that for all $n \ge 3$, $\pi_{n+1}(\Sn ^n) =
\Z_k$.
\end{thm}

\begin{proof}[Notes on the proof.]
The proof consists of a calculation of $\pi_4(\Sn ^3)$, together with an
appeal to stability (\cref{cor:stability-spheres}).  In the classical
statement of this result, $k$ is $2$.  While we have not yet checked that
$k$ is in fact $2$, our calculation of $\pi_4(\Sn ^3)$ is constructive,\index{mathematics!constructive}
like all the rest of the proofs in this chapter.
(More precisely, it doesn't use any additional axioms such as \LEM{} or \choice{}, making it as constructive as
univalence and higher inductive types are.)  Thus, given a
computational interpretation of homotopy type theory, we could run the
proof on a computer to verify that $k$ is $2$.  This example is quite
intriguing, because it is the first calculation of a homotopy group
for which we have not needed to know the answer in advance.
\end{proof}

% Recall from \cref{sec:colimits} that $X \sqcup^C Y$ denotes the
% (homotopy) pushout of $X$ and $Y$ along $C$.
\index{pushout}%

\begin{thm}[Blakers--Massey theorem]\label{Blakers-Massey}
  \indexdef{theorem!Blakers--Massey}%
  \indexsee{Blakers--Massey theorem}{theorem, Blakers--Massey}%
  Suppose we are given maps $f : C  \rightarrow X$, and $g : C \rightarrow Y$. Taking first the pushout $X \sqcup^C Y $ of $f$ and $g$ and then the pullback of its inclusions $\inl : X \rightarrow X \sqcup^C Y \leftarrow Y : \inr$, we have an induced map $C \to X \times_{(X \sqcup^C Y)} Y$.

  If $f$ is $i$-connected and $g$ is $j$-connected, then this induced map is $(i+j)$-connected. In other words, for any points $x:X$, $y:Y$, the corresponding fiber $C_{x,y}$ of $(f,g) : C \to X \times Y $ gives an approximation to the path space $\id[X \sqcup^C Y]{\inl(x)}{\inr(y)}$ in the pushout.
\end{thm}

It should be noted that in classical algebraic topology, the Blakers--Massey theorem is often stated in a somewhat different form, where the maps $f$ and $g$ are replaced by inclusions of subcomplexes of CW complexes, and the homotopy pushout and homotopy pullback by a union and intersection, respectively.
In order to express the theorem in homotopy type theory, we have to replace notions of this sort with ones that are homotopy-invariant.
We have seen another example of this in the van Kampen theorem (\cref{sec:van-kampen}), where we had to replace a union of open subsets by a homotopy pushout.

\begin{thm}[Eilenberg--Mac Lane Spaces]\label{Eilenberg-Mac-Lane-Spaces}
\index{Eilenberg--Mac Lane space}
For any abelian\index{group!abelian} group $G$ and positive integer $n$, there is an $n$-type
$K(G,n)$ such that $\pi_n(K(G,n)) = G$, and  $\pi_k(K(G,n)) = 0$
for $k\neq n$.
\end{thm}

\begin{thm}[Covering spaces]\label{thm:covering-spaces}
  \index{covering space}%
  For a connected space $A$, there is an equivalence between covering spaces over $A$ and sets with an action of $\pi_1(A)$.
\end{thm}


\sectionNotes

%% For the spheres,  two
%% different definitions of the $n$-sphere $\Sn ^n$ have been used: the first as the
%% suspension of $\Sn ^ {n-1}$ (\cref{sec:suspension}), and the second
%% as a higher inductive type with one base point and one loop in
%% $\Omega^n$ (\cref{sec:circle}); we list the status for both
%% definitions.  The equivalence of the two can be deduced from the remarks
%% at the end of \cref{sec:suspension}.

{
\newcommand{\humancheck}{\ding{52}}
\newcommand{\computercheck}{\ding{52}\kern-0.5em\ding{52}}
\begin{table}[htb]
  \centering
\begin{tabular}{lcc}
\toprule
Theorem         & Status \\
\midrule
$\pi_1(\Sn ^1)$                     & \computercheck \\
$\pi_{k<n}(\Sn ^n)$                  & \computercheck \\
%% $\pi_{k<n}(\Sn ^n)$ --- suspension  & \computercheck \\
%% $\pi_2(\Sn ^2)$ --- suspension      & \computercheck \\
long-exact-sequence of homotopy groups & \computercheck    \\
total space of Hopf fibration is $\Sn ^3$ & \humancheck    \\
$\pi_2(\Sn ^2)$                     & \computercheck \\
$\pi_3(\Sn ^2)$                     & \humancheck    \\
$\pi_n(\Sn ^n)$                     & \computercheck \\
%% $\pi_n(\Sn ^n)$ --- suspension      & \computercheck \\
$\pi_4(\Sn ^3)$                     & \humancheck    \\
Freudenthal suspension theorem      & \computercheck \\
Blakers--Massey theorem              & \computercheck \\
Eilenberg--Mac Lane spaces $K(G,n)$ & \computercheck \\
van Kampen theorem                & \computercheck \\
covering spaces                     & \computercheck \\
Whitehead's principle for $n$-types & \computercheck \\
\bottomrule
\end{tabular}
\caption{Theorems from homotopy theory proved by
  hand (\humancheck) and by computer (\computercheck).}
  \label{tab:theorems}
\end{table}
}

The theorems described in this chapter are standard results in classical
homotopy theory; many are described by \cite{hatcher02topology}.  In these
notes, we review the development of the new synthetic proofs of them in homotopy
type theory.  \cref{tab:theorems} lists the homotopy-theoretic
theorems that have been proven in homotopy type theory, and whether they
have been computer-checked.
Almost all of these results were developed during the spring term at IAS
in 2013, as part of a significant collaborative effort.  Many people
contributed to these results, for example by being the principal author
of a proof, by suggesting problems to work on, by participating in many
discussions and seminars about these problems, or by giving feedback on
results.  The following people were the principal authors of the first
homotopy type theory proofs of the above theorems. Unless indicated otherwise, for the
theorems that have been computer-checked, the principal authors were
also the first ones to formalize\index{mathematics!formalized} the proof using a computer proof
assistant.
\begin{itemize}
\item
Shulman gave the homotopy-theoretic calculation of $\pi_1(\Sn^1)$.  Licata later discovered the
encode-decode proof and the encode-decode method.

\item
Brunerie calculated $\pi_{k<n}(\Sn ^ n)$.
Licata later gave an encode-decode version.

\item Voevodsky constructed the long exact sequence of homotopy groups.

\item Lumsdaine constructed the Hopf fibration.
  Brunerie proved that its total space is $\Sn ^3$, thereby calculating $\pi_2(\Sn ^2)$ and
  $\pi_3(\Sn ^3)$.

\item Licata and Brunerie gave a direct calculation of
$\pi_n(\Sn ^n)$.

\item
  Lumsdaine proved the Freudenthal suspension theorem; Licata and
  Lumsdaine formalized this proof.
\item Lumsdaine, Finster, and Licata proved the Blakers--Massey theorem;
  Lumsdaine, Brunerie, Licata, and Hou formalized it.

\item
Licata gave an encode-decode calculation of $\pi_2(\Sn ^2)$, and a
calculation of $\pi_n(\Sn ^n)$ using the Freudenthal suspension theorem; using similar
techniques, he constructed $K(G,n)$.

\item
Shulman proved the van Kampen theorem; Hou formalized this proof.

\item
Licata proved Whitehead's theorem for $n$-types.

\item Brunerie calculated $\pi_4(\Sn ^3)$.

\item
Hou established the theory of covering spaces and formalized it.
\end{itemize}

The interplay between homotopy theory and type theory was crucial to the
development of these results.  For example, the first proof that
$\pi_1(\Sn ^1)=\mathbb{Z}$ was the one given in \cref{subsec:pi1s1-homotopy-theory}, which follows a classical homotopy theoretic one.  A
type-theoretic analysis of this proof resulted in the development of the
encode-decode method.  The first calculation of $\pi_2(\Sn ^2)$ also followed
classical methods, but this led quickly to an encode-decode proof of the
result.  The encode-decode calculation generalized to $\pi_n(\Sn ^n)$, which
in turn led to the proof of the Freudenthal suspension theorem, by
combining an encode-decode argument with classical homotopy-theoretic
reasoning about connectedness, which in turn led to the Blakers--Massey
theorem and Eilenberg--Mac Lane spaces.  The rapid development of this
series of results illustrates the promise of our new understanding of
the connections between these two subjects.

\sectionExercises

\begin{ex}\label{ex:homotopy-groups-resp-prod}
  Prove that homotopy groups respect products: $\eqv{\pi_n(A\times B)}{\pi_n(A)\times \pi_n(B)}$.
\end{ex}

\begin{ex}\label{ex:decidable-equality-susp}
  \index{decidable!equality}%
  Prove that if $A$ is a set with decidable equality (see \cref{defn:decidable-equality}), then its suspension $\susp A$ is a 1-type.
  (It is an open question\index{open!problem} whether this is provable without the assumption of decidable equality.)
\end{ex}

\begin{ex}\label{ex:contr-infinity-sphere-colim}
  Define $\Sn^\infty$ to be the colimit of the sequence $\Sn^0 \to \Sn^1 \to \Sn^2 \to\cdots$.
  Prove that $\Sn^\infty$ is contractible.
\end{ex}

\begin{ex}\label{ex:contr-infinity-sphere-susp}
  Define $\Sn^\infty$ to be the higher inductive type generated by
  \begin{itemize}
  \item Two points $\north:\Sn^\infty$ and $\south:\Sn^\infty$, and
  \item For each $x:\Sn^\infty$, a path $\merid(x):\north=\south$.
  \end{itemize}
  In other words, $\Sn^\infty$ is its own suspension.
  Prove that $\Sn^\infty$ is contractible.
\end{ex}

\begin{ex}\label{ex:unique-fiber}
  Suppose $f:X\to Y$ is a function and $Y$ is connected.
  Show that for any $y_1,y_2:Y$ we have $\brck{\eqv{\hfib f {y_1}}{\hfib f {y_2}}}$.
\end{ex}

\begin{ex}\label{ex:ap-path-inversion}
  For any pointed type $A$, let $i_A : \Omega A \to \Omega A$ denote inversion of loops, $i_A \defeq \lam{p} \rev{p}$.
  Show that $i_{\Omega A} : \Omega^2 A \to \Omega^2 A$ is equal to $\Omega(i_A)$.
\end{ex}

\begin{ex}\label{ex:pointed-equivalences}
  Define a \textbf{pointed equivalence} to be a pointed map whose underlying function is an equivalence.
  \begin{enumerate}
  \item Show that the type of pointed equivalences between pointed types $(X,x_0)$ and $(Y,y_0)$ is equivalent to $\id[\pointed\type]{(X,x_0)}{(Y,y_0)}$.
  \item Reformulate the notion of pointed equivalence in terms of a pointed quasi-inverse and pointed homotopies, in one of the coherent styles from \cref{cha:equivalences}.
  \end{enumerate}
\end{ex}

\begin{ex}\label{ex:HopfJr}
  Following the example of the Hopf fibration in \cref{sec:hopf}, define the \define{junior Hopf fibration}
  \indexdef{Hopf!fibration!junior}%
as a fibration (that is, a type family) over $\Sn ^1$ whose fiber over the basepoint is $\Sn ^0$ and whose total space is $\Sn ^1$.  This is also called the ``twisted double cover'' of the circle $\Sn ^1$.
\end{ex}

\begin{ex}\label{ex:SuperHopf}
Again following the example of the Hopf fibration in \cref{sec:hopf}, define an analogous fibration over $\Sn ^4$ whose fiber over the basepoint is $\Sn ^3$ and whose total space is $\Sn ^7$.  This is an open problem\index{open!problem} in homotopy type theory (such a fibration is known to exist in classical homotopy theory).
\end{ex}

\begin{ex}\label{ex:vksusppt}
  Continuing from \cref{eg:suspension}, prove that if $A$ has a point $a:A$, then we can identify $\pi_1(\susp A)$ with the group presented by $\trunc0A$ as generators with the relation $\tproj0a = e$.
  Then show that if we assume excluded middle, this is also the free group on $\trunc0 A \setminus \{\tproj0 a \}$.
\end{ex}

\begin{ex}\label{ex:vksuspnopt}
  Again continuing from \cref{eg:suspension}, but this time without assuming $A$ to be pointed, show that we can identify $\pi_1(\susp A)$ with the group presented by generators $\trunc0A \times \trunc0A$ and relations
  \begin{equation*}
    (a,b) = \opp{(b,a)},
    \qquad
    (a,c) = (a,b)\cdot (b,c),
    \qquad\text{and}\qquad
    (a,a) = e.
  \end{equation*}
\end{ex}

\index{acceptance|)}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "hott-online"
%%% End:
