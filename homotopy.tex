\chapter{同伦理论 (Homotopy Theory)}
\label{cha:homotopy}

\index{acceptance|(}

在本章中，我们将在类型理论中发展一些同伦理论 (homotopy theory)。我们使用了在\cref{cha:basics}中介绍的\emph{综合方法} (synthetic approach) 来进行同伦理论的研究：空间 (spaces)、点 (points)、路径 (paths) 和同伦 (homotopies) 是基本概念，它们分别由类型 (types) 和类型的元素表示，特别是同一性类型 (identity type)。路径和同伦的代数结构由类型上自然的 $\infty$-群 (groupoid) 结构生成，这一结构是由同一性类型的规则生成的。使用在\cref{cha:hits}中引入的高阶归纳类型 (higher inductive types)，我们可以直接通过其泛性质来描述空间。

\index{synthetic mathematics}%
这种综合方法有几个有趣的方面。首先，它结合了具体模型（如拓扑空间 (topological spaces) 或单纯集合 (simplicial sets)）的优势与用于同伦理论的抽象范畴框架（如Quillen模型范畴 (Quillen model categories)）的优势。一方面，我们的证明看起来很基础，并且具体涉及类型中的点、路径和同伦。另一方面，我们的方法仍然抽象化了这些对象的任何具体表示——例如，路径连接的结合性是通过路径归纳法 (path induction) 证明的，而不是通过映射 $[0,1] \to X$ 的重参数化或通过角填充条件 (horn-filling conditions) 证明的。类型理论似乎是研究 $\infty$-群 (groupoid) 抽象同伦理论的非常方便的方法：通过使用同一性类型的规则，我们可以避免许多 $\infty$-群定义中涉及的复杂组合问题，并且只需在任何特定证明中说明所需的结构。

类型理论的抽象性质意味着我们的证明可以自动应用于各种环境中。特别是，如前所述，同伦类型理论 (homotopy type theory) 在Kan单纯集合 (Kan simplicial sets) 中有一个解释，这是一种 $\infty$-群同伦理论的模型。因此，我们的证明适用于这个模型，并且通过从单纯集合到拓扑空间的几何实现函子 (geometric realization functor) 转移它们，可以得到经典同伦理论中的对应定理。然而，尽管细节仍在进行中，我们也可以在看起来像 $\infty$-群的其他范畴（例如 $(\infty,1)$-拓扑 (toposes)）中解释类型理论。因此，在类型理论中证明的结果也将在这些环境中成立。这种额外的一般性在普通范畴逻辑中是众所周知的：同一性基础将其扩展到同伦理论中。

其次，我们的综合方法提出了一些新的类型理论方法和证明。我们的一些证明是经典证明的直接转录。其他证明则更具有类型理论的风格，主要包括使用 $\infty$-群操作的计算，这种风格与计算机科学家使用类型理论推理计算机程序非常相似。类型理论允许我们聚焦于同伦理论中不同于其他方法的方面：虽然工具如路径归纳法和高阶归纳类型的泛性质在像Kan单纯集合这样的环境中是可用的，但类型理论提升了它们的重要性，因为它们是处理这些类型的\emph{唯一}原始工具。聚焦于这些工具已经导致了对熟悉构造的新描述，例如圆的通用覆盖 (universal cover) 和Hopf纤维 (Hopf fibration)，这些描述仅使用高阶归纳类型的递归原则。这些描述非常直接，本章中的许多证明涉及到与这些纤维的计算计算。

\index{mathematics!constructive}%
我们的证明的另一个新方面是它们是构造性的（假设同一性和高阶归纳类型是构造性的）；我们将在\cref{sec:moreresults}中描述将其应用于球体的同伦群的一个应用。

\index{mathematics!formalized}%
\indexsee{formalization of mathematics}{mathematics, formalized}%
第三，我们的综合方法非常适合于在证明助手 (proof assistants)（如 \Coq 和 \Agda）中进行计算机验证的证明。本章中描述的几乎所有证明都经过了计算机验证，其中许多证明首先在证明助手中给出，然后为本书“非形式化”。计算机验证的证明与这里提出的非正式证明在长度和努力上是可比的，并且在某些情况下，它们甚至更短，更容易完成。

\mentalpause

在开始介绍我们的结果之前，我们将简要回顾一些基本概念和同伦理论中的定理，以便那些不熟悉这些概念的读者。我们还将概述本章中证明的结果。

\index{classical!homotopy theory|(}%
同伦理论是代数拓扑的一个分支，并使用抽象代数的工具（如群论 (group theory)）来研究空间的性质。同伦理论家研究的一个问题是如何判断两个空间是否相同，其中“相同”意味着\emph{同伦等价} (homotopy equivalence)（连续映射来回组合成同伦意义上的恒等映射——这给了“修正”那些不能完全组合成恒等映射的映射的机会）。判断两个空间是否相同的一种常见方法是计算与空间相关的\emph{代数不变量} (algebraic invariants)，其中包括其\emph{同伦群} (homotopy groups) 和\emph{同调群} (homology) 和\emph{上同调群} (cohomology groups)。同伦等价的空间具有同构的同伦/（上）同调群，因此如果两个空间具有不同的群，那么它们就不等价。因此，这些代数不变量提供了有关空间的全局信息，可用于区分空间，并补充了诸如连续性等概念所提供的局部信息。例如，圆环 (torus) 在局部看起来像2-球面 (2-sphere)，但它有一个全局差异，因为它有一个洞，这一差异在这两个空间的同伦群中是可见的。

最简单的同伦群的例子是空间的\emph{基本群} (fundamental group)，记为 $\pi_1(X,x_0)$：给定一个空间 $X$ 及其中的一个点 $x_0$，可以构造一个群，其元素是 $x_0$ 处的环路（从 $x_0$ 到 $x_0$ 的连续路径），在同伦意义上进行考虑，群运算由恒等路径（静止）、路径连接和路径反转给出。例如，2-球面的基本群是平凡的，但圆环的基本群不是，这表明球面和圆环不是同伦等价的。直观上，每个球面上的环路都是同伦等价于恒等的，因为它的内部可以填充。而在圆环上穿过圆环洞的环路不是同伦等价于恒等的，因此基本群中有非平凡元素。

\index{homotopy!group}
\emph{高阶同伦群} (higher homotopy groups) 提供了空间的更多信息。固定空间 $X$ 中的一个点 $x_0$，并考虑恒等路径 $\refl{x_0}$。那么，$\refl{x_0}$ 与自身之间同伦的同伦类构成一个群 $\pi_2(X,x_0)$，它告诉我们关于空间二维结构的一些信息。然后，$\pi_3(X,x_0)$ 是同伦之间的同伦类的群，依此类推。代数拓扑的一个基本问题是\emph{计算空间 $X$ 的同伦群}，这意味着给出 $\pi_k(X,x_0)$ 和一些更直接的群的描述（例如，通过乘法表或呈示）之间的群同构。令人惊讶的是，即使对于像球体 (spheres) 这样简单的空间，这个问题也是非常困难的。如\cref{tab:homotopy-groups-of-spheres} 所示，高阶同伦群的一些模式出现了，但没有一般公式，并且许多球体的同伦群目前仍然未知。

\bgroup
% Colors for the table of homotopy groups of spheres
\definecolor{xA}{\OPTcolormodel}{\OPTcolxA}
\definecolor{xB}{\OPTcolormodel}{\OPTcolxB}
\definecolor{xC}{\OPTcolormodel}{\OPTcolxC}
\definecolor{xD}{\OPTcolormodel}{\OPTcolxD}
\definecolor{xE}{\OPTcolormodel}{\OPTcolxE}
\definecolor{xF}{\OPTcolormodel}{\OPTcolxF}
\definecolor{xG}{\OPTcolormodel}{\OPTcolxG}
\definecolor{xH}{\OPTcolormodel}{\OPTcolxH}
\definecolor{xI}{\OPTcolormodel}{\OPTcolxI}
\definecolor{xJ}{\OPTcolormodel}{\OPTcolxJ}
\definecolor{xK}{\OPTcolormodel}{\OPTcolxK}
\definecolor{xL}{\OPTcolormodel}{\OPTcolxL}
\definecolor{xM}{\OPTcolormodel}{\OPTcolxM}

\newcommand{\cA}{\colorbox{xG}{\hbox to 20pt {\hfil$0$\hfil}}}
\newcommand{\cB}{\colorbox{xH}{\hbox to 20pt {\hfil$\Z$\hfil}}}
\newcommand{\cC}{\colorbox{xI}{\hbox to 20pt {\hfil$\Z_{2}$\hfil}}}
\newcommand{\cD}{\colorbox{xJ}{\hbox to 20pt {\hfil$\Z_{2}$\hfil}}}
\newcommand{\cE}{\colorbox{xK}{\hbox to 20pt {\hfil$\Z_{24}$\hfil}}}
\newcommand{\cF}{\colorbox{xL}{\hbox to 20pt {\hfil$0$\hfil}}}
\newcommand{\cG}{\colorbox{xM}{\hbox to 20pt {\hfil$0$\hfil}}}
\newcommand{\cH}{\colorbox{xF}{\hbox to 20pt {\hfil$0$\hfil}}}
\newcommand{\cI}{\colorbox{xE}{\hbox to 20pt {\hfil$0$\hfil}}}
\newcommand{\cJ}{\colorbox{xD}{\hbox to 20pt {\hfil$0$\hfil}}}
\newcommand{\cK}{\colorbox{xC}{\hbox to 20pt {\hfil$0$\hfil}}}
\newcommand{\cL}{\colorbox{xB}{\hbox to 20pt {\hfil$0$\hfil}}}
\newcommand{\cM}{\colorbox{xA}{\hbox to 20pt {\hfil$0$\hfil}}}

\begin{table}[htb]
  \centering\small
  \begin{tabular}{p{15pt}>{\centering\arraybackslash}p{\OPTspherescolwidth}>{\centering\arraybackslash}p{\OPTspherescolwidth}>{\centering\arraybackslash}p{\OPTspherescolwidth}>{\centering\arraybackslash}p{\OPTspherescolwidth}>{\centering\arraybackslash}p{\OPTspherescolwidth}>{\centering\arraybackslash}p{\OPTspherescolwidth}>{\centering\arraybackslash}p{\OPTspherescolwidth}>{\centering\arraybackslash}p{\OPTspherescolwidth}>{\centering\arraybackslash}p{\OPTspherescolwidth}}
    \toprule
    & $\Sn^0$ & $\Sn^1$ & $\Sn^{2}$ & $\Sn^{3}$ & $\Sn^{4}$ & $\Sn^{5}$ & $\Sn^{6}$ & $\Sn^{7}$ & $\Sn^{8}$ \\ \addlinespace[3pt] \midrule
    $\pi_{1}$  & $0$     & $\Z$    & \cA       & \cH       & \cI       & \cJ       & \cK       & \cL       & \cM       \\ \addlinespace[3pt]
    $\pi_{2}$  & $0$     & $0$     & \cB       & \cA       & \cH       & \cI       & \cJ       & \cK       & \cL       \\ \addlinespace[3pt]
    $\pi_{3}$  & $0$     & $0$     & $\Z$      & \cB       & \cA       & \cH       & \cI       & \cJ       & \cK       \\ \addlinespace[3pt]
    $\pi_{4}$  & $0$     & $0$     & $\Z_{2}$  & \cC       & \cB       & \cA       & \cH       & \cI       & \cJ       \\ \addlinespace[3pt]
    $\pi_{5}$  & $0$     & $0$     & $\Z_{2}$  & $\Z_{2}$  & \cC       & \cB       & \cA       & \cH       & \cI       \\ \addlinespace[3pt]
    $\pi_{6}$  & $0$     & $0$     & $\Z_{12}$ & $\Z_{12}$ & \cD       & \cC       & \cB       & \cA       & \cH       \\ \addlinespace[3pt]
    $\pi_{7}$  & $0$     & $0$     & $\Z_{2}$  & $\Z_{2}$  & {\footnotesize $\Z {\times} \Z_{12}$} & \cD & \cC & \cB     & \cA    \\ \addlinespace[3pt]
    $\pi_{8}$  & $0$     & $0$     & $\Z_{2}$  & $\Z_{2}$  & $\Z_{2}^{2}$ & \cE & \cD & \cC & \cB \\ \addlinespace[3pt]
    $\pi_{9}$  & $0$     & $0$     & $\Z_{3}$  & $\Z_{3}$  & $\Z_{2}^{2}$ & $\Z_{2}$ & \cE & \cD & \cC \\ \addlinespace[3pt]
    $\pi_{10}$ & $0$     & $0$     & $\Z_{15}$ & $\Z_{15}$ & \footnotesize{$$\Z_{24} {\times} \Z_{3}$$} & $\Z_{2}$ & \cF & \cE & \cD \\ \addlinespace[3pt]
    $\pi_{11}$ & $0$     & $0$     & $\Z_{2}$  & $\Z_{2}$  & $\Z_{15}$ & $\Z_{2}$ & $\Z$ & \cF & \cE \\ \addlinespace[3pt]
    $\pi_{12}$ & $0$     & $0$     & $\Z_{2}^{2}$ & $\Z_{2}^{2}$ & $\Z_{2}$ & $\Z_{30}$ & $\Z_{2}$ & \cG & \cF \\ \addlinespace[3pt]
    $\pi_{13}$ & $0$     & $0$     & {\footnotesize $\Z_{12} {\times} \Z_{2}$} & {\footnotesize $\Z_{12} {\times} \Z_{2}$} & $\Z_{2}^{3}$ & $\Z_{2}$ & $\Z_{60}$ & $\Z_{2}$ & \cG \\ \addlinespace[3pt]
%$\pi_{14}$ & $0$     & $0$     & $\Z_{84} {\times} \Z_{2}^{2}$ & $\Z_{84} {\times} \Z_{2}^{2}$ & {\footnotesize $\Z_{120} {\times} $\Z_{12} {\times} \Z_{2}$} & $\Z_{2}^{3}$ & $\Z_{24} {\times} \Z_{2}$ & $\Z_{120}$ & $\Z_{2}$ \\ \addlinespace[3pt]
%$\pi_{15}$ & $0$     & $0$     & $\Z_{2}^{2}$ & $\Z_{2}^{2}$ & $\Z_{84} {\times} $\Z_{2}^{5}$ & $\Z_{72} {\times} \Z_{2}$ & $\Z_{2}^{3}$ & $\Z_{2}^{3}$ & $\Z {\times} \Z_{120}$ \\ \addlinespace[3pt]
    \bottomrule
  \end{tabular}

  \caption{球体的同伦群~\cite{wikipedia-groups}.\index{homotopy!group!of sphere}
    $n$ 维球面 $\Sn^n$ 的第 $k$ 同伦群 $\pi_k$ 同构于表中的群，其中 $\Z$ 是整数的加法群\index{integers}，$\Z_{m}$ 是阶数为 $m$ 的循环群\index{group!cyclic}\index{cyclic group}。
  }
  \label{tab:homotopy-groups-of-spheres}
\end{table}
\egroup

理解这种复杂性的一种方法是通过在\cref{cha:basics}中介绍的空间和 $\infty$-群的对应关系\index{.infinity-groupoid@$\infty$-groupoid}。如在\cref{sec:circle}中讨论的那样，2-球面由具有一个点和一个二维环的高阶归纳类型 (higher inductive type) 表示。因此，人们可能想知道为什么 $\pi_3(\Sn ^2)$ 是 $\Z$，当类型 $\Sn ^2$ 没有生成 3 维胞元的生成元时。事实证明，$\pi_3(\Sn ^2)$ 的生成元素是使用\cref{thm:EckmannHilton} 中描述的互换律构造的：$\infty$-群的代数结构包括各个层级之间的非平凡相互作用，这些相互作用产生了更高阶同伦群的元素。

\index{classical!homotopy theory|)}%

类型理论为研究这一结构提供了一个自然的环境，因为我们可以很容易地定义高阶同伦群。回顾\cref{def:loopspace}中的定义，对于 $n:\N$，以点类型 $(A,a)$ 的 $n$ 重迭代环空间\index{loop space!iterated} 递归定义为：
\begin{align*}
  \Omega^0(A,a)&=(A,a)\\
  \Omega^{n+1}(A,a)&=\Omega^n(\Omega(A,a)).
\end{align*}
%
这给出了 $n$ 维环的\emph{空间}（即类型），它本身具有更高阶的同伦。通过截断我们得到 $n$ 维环的集合（这也是在\cref{sec:free-algebras}中作为示例定义的）：

\begin{defn}[同伦群 (Homotopy Groups)]\label{def-of-homotopy-groups}
对于 $n\ge 1$ 和 $(A,a)$ 一个点类型，我们定义 $A$ 在 $a$ 处的\define{同伦群 (homotopy groups)}
\indexdef{homotopy!group}%
为
\[\pi_n(A,a)\defeq \Trunc0{\Omega^n(A,a)}\]
\end{defn}

\noindent
由于 $n\ge 1$，路径连接和反转操作在 $\Omega^n(A)$ 上诱导出 $\pi_n(A)$ 上的操作，使其成为群的方式非常简单。如果 $n\ge 2$，那么通过 Eckmann--Hilton 论证\index{Eckmann--Hilton argument} (\cref{thm:EckmannHilton})，群 $\pi_n(A)$ 是阿贝尔群\index{group!abelian}。将 $\pi_0(A) \defeq \trunc0 A$ 也是方便的，但这种情况有所不同：它不仅不是一个群，并且定义时不涉及 $A$ 中的任何基点。

\index{presentation!of an infinity-groupoid@of an $\infty$-groupoid}%
这个定义适合于研究同伦群，因为一个类型 $X$ 的（高阶）归纳定义将 $X$ 表现为一个自由类型，类似于一个自由 $\infty$-群 (groupoid)，并且这种表示\emph{决定}了 $X$ 的更高同一性类型，但并不\emph{显式地描述}。同一性类型由生成元（如圆的 $\lloop$）和对它们应用的所有群操作（恒等，复合，逆元，结合律，互换律，……）生成。因此，高阶归纳的空间表示允许我们提出问题“$X$ 的同一性类型最终是什么？” 尽管回答它可能需要一些重要的数学。这是类型理论中的一个更高维度的推广：即使 $X$ 是一个普通的归纳类型，如自然数或布尔值，刻画 $X$ 的同一性类型也可能需要一些工作。例如，$\bfalse$ 和 $\btrue$ 是不同的这个定理并不是从定义直接得出的；见\cref{sec:compute-coprod}。

\index{univalence axiom}%
同一性公理 (univalence axiom) 在计算同伦群时起着关键作用（没有同一性，类型理论可以兼容一种解释，其中所有路径，包括圆上的 $\lloop$，都是反射性的）。我们将在下面的圆的基本群的计算中看到这一点：从 $\Omega(\Sn^1)$ 到 $\Z$ 的映射是通过将圆上的环映射到集合 $\Z$ 的自同构\index{automorphism!of Z, successor@of $\Z$, successor} 来定义的，例如 $\lloop \ct \opp \lloop$ 被送到 $\mathsf{successor} \ct \mathsf{predecessor}$（其中 $\mathsf{successor}$ 和 $\mathsf{predecessor}$ 是 $\Z$ 的自同构，被视为宇宙中的路径），然后将自同构应用于 0。通过同一性，宇宙中产生了非平凡的路径，这被用来从高阶归纳类型中的路径中提取信息。

在本章中，我们首先计算一些球体的同伦群，包括 $\pi_k(\Sn ^1)$ (\cref{sec:pi1-s1-intro})，$k<n$ 时的 $\pi_{k}(\Sn ^n)$ (\cref{sec:conn-susp,sec:pik-le-n})，通过 Hopf 纤维 (\cref{sec:hopf}) 和长正合序列 (long-exact-sequence) 的论证 (\cref{sec:long-exact-sequence-homotopy-groups}) 计算 $\pi_2(\Sn ^2)$ 和 $\pi_3(\Sn ^2)$，以及通过 Freudenthal 悬挂定理 (\cref{sec:freudenthal}) 计算 $\pi_n(\Sn ^n)$。接着，我们讨论 van Kampen 定理 (\cref{sec:van-kampen})，它刻画了一个推挽 (pushout) 的基本群，以及 Whitehead 原理的状态（当一个映射在所有同伦群上引起等价时，它是否是一个等价？）(\cref{sec:whitehead})。最后，我们简要总结了书中未包括的其他结果，例如 $n\ge 3$ 时的 $\pi_{n+1}(\Sn ^n)$，Blakers--Massey 定理，以及 Eilenberg--Mac Lane 空间的构造 (\cref{sec:moreresults})。本章的先决条件包括\cref{cha:typetheory,cha:basics,cha:hits,cha:hlevels} 以及\cref{cha:logic}的部分内容。

\index{fundamental!group!of circle|(}

\section{\texorpdfstring{$\pi_1(S^1)$}{π₁(S¹)}}
\label{sec:pi1-s1-intro}

在本节中，我们的目标是证明 $\id {\pi_1(\Sn ^1)} {\Z}$。
实际上，我们将证明环空间（loop space）${\Omega(\Sn ^1)}$ 等价于 $\Z$。
这是一个更强的陈述，因为根据定义，$\id{\pi_1(\Sn ^1)} {\trunc 0 {\Omega(\Sn ^1)}}$；因此，如果 $\id {\Omega(\Sn ^1)} {\Z}$，那么通过一致性，$\id {\trunc 0 {\Omega(\Sn ^1)}} {\trunc 0 {\Z}}$，并且 $\Z$ 根据定义是一个集合（作为一个集合商；参见 \cref{defn-Z,Z-quotient-by-canonical-representatives}），所以 $\id {\trunc 0 {\Z}} {\Z}$。
此外，知道 ${\Omega(\Sn ^1)}$ 是一个集合将意味着 $\pi_n(\Sn^1)$ 对于 $n>1$ 是平凡的，因此我们实际上计算了 \emph{所有} 的 $\Sn^1$ 的同伦群。

\subsection{开始 (Getting started)}
\label{sec:pi1s1-initial-thoughts}

定义 $\Omega(\Sn^1)$ 和 $\Z$ 之间双向的函数并不困难。
通过将 \cref{thm:looptothe} 专门化为 $\lloop:\base=\base$，我们得到了一个函数 $\lloop^{\blank} : \Z \rightarrow (\id{\base}{\base})$，它（粗略地说）定义如下：
\[
  \lloop^n =
  \begin{cases}
    \underbrace{\lloop \ct \lloop \ct \cdots \ct \lloop}_{n}  & \text{如果 $n > 0$,} \\
    \underbrace{\opp \lloop \ct \opp \lloop \ct \cdots \ct \opp \lloop}_{-n} & \text{如果 $n < 0$,} \\
    \refl{\base} & \text{如果 $n = 0$.}
  \end{cases}
\]
%
定义一个函数 $g:\Omega(\Sn^1)\to\Z$ 在另一个方向上有点棘手。
注意，后继函数 $\Zsuc:\Z\to\Z$ 是一个等价，
\index{successor!isomorphism on Z@isomorphism on $\Z$}%
因此在宇宙 \type 中诱导出一个路径 $\ua(\Zsuc):\Z=\Z$。
因此，$\Sn^1$ 的递归原理诱导出一个映射 $c:\Sn^1\to\type$，其中 $c(\base)\defeq \Z$，而 $\apfunc c (\lloop) \defid \ua(\Zsuc)$。
然后我们有 $\apfunc{c} : (\base=\base) \to (\Z=\Z)$，并且我们可以定义 $g(p)\defeq \transfib{X\mapsto X}{\apfunc{c}(p)}{0}$。

通过这些定义，我们甚至可以证明对于任何 $n:\Z$，$g(\lloop^n)=n$，使用 \cref{thm:sign-induction} 的归纳原理。
（我们稍后将证明更一般的情况。）
然而，另一个等式 $\lloop^{g(p)}=p$ 则要困难得多。
显而易见的方法是路径归纳，但路径归纳不适用于像 $p:(\base=\base)$ 这样具有 \emph{两端固定} 的环路！
需要一个新的想法，这可以用经典的同伦理论和类型理论来解释。
我们从前者开始。

\subsection{经典证明 (The classical proof)}
\label{sec:pi1s1-classical-proof}

\index{classical!homotopy theory|(}%
在经典同伦理论中，有一个标准证明 $\pi_1(\Sn^1)=\Z$ 使用了通用覆盖空间。
我们的证明可以看作是这个证明的类型理论版本，其中覆盖空间在这里出现为纤维，其纤维是集合。
\index{fibration}%
\index{total!space}%
回顾一下，在同伦理论中，某个空间 $B$ 上的纤维对应于类型理论中的类型族 $B\to\type$。
\index{path!fibration}%
\index{fibration!of paths}%
特别地，对于一个点 $x_0:B$，类型族 $(x\mapsto (x_0=x))$ 对应于 \emph{路径纤维} $P_{x_0} B \to B$，其中 $P_{x_0} B$ 的点是从 $x_0$ 开始的 $B$ 中的路径，映射到 $B$ 选择了这种路径的另一端点。
这个总空间 $P_{x_0} B$ 是可收缩的，因为我们可以“收缩”任何路径到其初始端点 $x_0$ ——我们已经看到了类型理论版本的这一点，如 \cref{thm:contr-paths}。
此外，$x_0$ 之上的纤维是环空间（loop space）$\Omega(B,x_0)$ —— 在类型理论中这是显而易见的，因为这是环空间的定义。

\begin{figure}\centering
\begin{tikzpicture}[xscale=1.4,yscale=.6]
  \node (R) at (2,1) {$\mathbb{R}$};
  \node (S1) at (2,-2) {$S^1$};
  \draw[->] (R) -- node[auto] {$w$} (S1);
  \draw (0,-2) ellipse (1 and .4);
  \draw[dotted] (1,0) arc (0:-30:1 and .8);
  \draw (1,0) arc (0:90:1 and .8) arc (90:270:1 and .3) coordinate (t1);
  \draw[white,line width=4pt] (t1) arc (-90:90:1 and .8);
  \draw (t1) arc (-90:90:1 and .8) arc (90:270:1 and .3) coordinate (t2);
  \draw[white,line width=4pt] (t2) arc (-90:90:1 and .8);
  \draw (t2) arc (-90:90:1 and .8) arc (90:270:1 and .3) coordinate (t3);
  \draw[white,line width=4pt] (t3) arc (-90:90:1 and .8);
  \draw (t3) arc (-90:-30:1 and .8) coordinate (t4);
  \draw[dotted] (t4) arc (-30:0:1 and .8);
  \node[fill,circle,inner sep=1pt,label={below:\scriptsize \base}] at (0,-2.4) {};
  \node[fill,circle,inner sep=1pt,label={above left:\scriptsize 0}] at (0,.2) {};
  \node[fill,circle,inner sep=1pt,label={above left:\scriptsize 1}] at (0,1.2) {};
  \node[fill,circle,inner sep=1pt,label={above left:\scriptsize 2}] at (0,2.2) {};
\end{tikzpicture}
\caption{经典拓扑中的绕线映射 (The winding map in classical topology)}\label{fig:winding}
\end{figure}

现在在经典同伦理论中，$\Sn^1$ 被视为一个拓扑空间，我们可以如下进行。
\index{winding!map}%
考虑“绕线”映射 $w:\mathbb{R}\to \Sn ^1$，它看起来像是一个螺旋线投影到圆上（见 \cref{fig:winding}）。
这个映射 $w$ 将螺旋线上每一点映射到它“坐在上面”的圆上的点。
它是一个纤维，并且每个点的纤维与整数（integers）同构。
如果我们提升底部逆时针绕过的路径，我们在螺旋线上升一个级别，增加纤维中的整数。
类似地，顺时针绕过底部的路径对应于在螺旋线上下降一级，减少这个计数。
这个纤维称为圆的\emph{通用覆盖}（universal cover）。
\index{universal!cover}%
\index{cover!universal}%
\index{covering space!universal}%

现在，经典同伦理论中的一个基本事实是 $E_1\to E_2$ 是 $B$ 上纤维之间的映射，它是 $E_1$ 和 $E_2$ 之间的同伦等价，因而在所有纤维上诱导同伦等价。
（我们已经在 \cref{thm:total-fiber-equiv} 中看到了类型理论版本的这个事实。）
因为 $\mathbb{R}$ 和 $P_{\base} S^1$ 都是可收缩的拓扑空间，所以它们是同伦等价的，因此它们在基点之上的纤维 $\Z$ 和 $\Omega(\Sn ^1)$ 也是同伦等价的。

\index{classical!homotopy theory|)}%

\subsection{类型理论中的通用覆盖 (The universal cover in type theory)}
\label{sec:pi1s1-universal-cover}

\index{universal!cover|(}%
\index{cover!universal|(}%
\index{covering space!universal|(}%

让我们考虑如何在类型理论中表达前面的证明。
我们已经提到 $\Sn^1$ 的路径纤维由类型族 $(x\mapsto (\base=x))$ 表示。
我们也已经看到了一个好的候选通用覆盖 $\Sn^1$：它正是我们在 \cref{sec:pi1s1-initial-thoughts} 中定义的类型族 $c:\Sn^1\to\type$！
根据定义，这个家族在 $\base$ 上的纤维是 $\Z$，而绕过 $\lloop$ 的运输效应是增加一个——因此它的行为正如我们从 \cref{fig:winding} 所预期的那样。

然而，由于我们还不知道这个家族的行为是否像一个通用覆盖应该有的那样（例如，它的总空间是否是简单连通的），我们为它使用了一个不同的名字。
因此，我们再次重复定义以供参考。
\index{integers}

\begin{defn}[Universal Cover of $\Sn^1$] \label{S1-universal-cover}
通过圆递归定义 $\code : \Sn ^1 \to \type$，其中
\begin{align*}
  \code(\base) &\defeq \Z \\
  \apfunc{\code}({\lloop}) &\defid \ua(\Zsuc)。
\end{align*}
\end{defn}

我们简要强调一下这个家族的定义，因为它与经典同伦理论中通常定义覆盖空间的方式是如此不同。
要通过圆递归定义一个函数，我们需要在余码中找到一个点和一个环。
在这种情况下，余码是 $\type$，我们选择的点是 $\Z$，对应于我们期望的通用覆盖的纤维应该是整数。
我们选择的环是后继/前驱（successor/predecessor）
\index{successor!isomorphism on Z@isomorphism on $\Z$}%
\index{predecessor!isomorphism on Z@isomorphism on $\Z$}%
的同构， 它对应于基座上的环绕上升一级的事实。
在这一部分的证明中，等价性是必要的，因为我们需要将 $\Z$ 上的一个 \emph{非平凡} 等价转换为一个恒等式。

我们称这个纤维为“代码”（codes）的纤维，因为它的元素是组合数据，这些数据充当圆上路径的代码：整数 $n$ 为路径编码，该路径在圆上绕行 $n$ 次。

通过这个定义，很容易计算出使用 $\code$ 的运输会将 $\lloop$ 转换为后继函数，将 $\opp{\lloop}$ 转换为前驱函数：
\begin{lem} \label{lem:transport-s1-code}
\id{\transfib \code \lloop x} {x + 1} 和
\id{\transfib \code {\opp \lloop} x} {x - 1}。
\end{lem}
\begin{proof}
  对于第一个等式，我们按如下方式计算：
  \begin{align}
  {\transfib \code \lloop x}
    &= \transfib {A \mapsto A} {(\ap{\code}{\lloop})} x \tag{依据 \cref{thm:transport-compose}}\\
    &= \transfib {A \mapsto A} {\ua (\Zsuc)} x \tag{计算 \rec{\Sn^1}}\\
    &= x + 1 \tag{依据 \ua 的计算结果}。
  \end{align}
  第二个等式由第一个得出，因为 $\transfib{B}{p}{\blank}$ 和 $\transfib{B}{\opp p}{\blank}$ 总是相互逆转，因此 $\transfib\code {\opp \lloop}{\blank}$ 必须是 $\Zsuc$ 的逆函数。
\end{proof}

我们现在可以看到我们第一个方法的错误之处：我们仅在纤维 $\Omega(\Sn^1)$ 和 $\Z$ 上定义了 $f$ 和 $g$，而我们应该定义一个整个纤维上的态射（morphism）。
在类型理论中，这意味着我们应该定义具有以下类型的函数
\begin{align}
  \prd{x:\Sn^1} &((\base=x) \to \code(x)) \qquad\text{和/或} \label{eq:pi1s1-encode}\\
  \prd{x:\Sn^1} &(\code(x) \to (\base=x))\label{eq:pi1s1-decode}
\end{align}
而不仅仅是在 $x$ 为 \base 时的特殊情况。
这也是类型理论中常见的观察的一个例子：当尝试证明某些归纳类型的特定居民时，通常更容易将陈述泛化，使其涉及 \emph{所有} 此类类型的居民，然后我们可以通过归纳证明。
从这个角度来看，$\Omega(\Sn^1)=\Z$ 的证明符合与在 \cref{sec:compute-coprod,sec:compute-nat} 中的共产品和自然数的恒等类型的特征化相同的模式。

在这一点上，有两种方法可以完成证明。
我们可以继续模仿经典论证，构造~\eqref{eq:pi1s1-encode} 或~\eqref{eq:pi1s1-decode}（无论哪种都可以），证明总空间之间的同伦等价诱导纤维上的等价，然后证明通用覆盖的总空间是可收缩的。
$\Omega(\Sn^1)=\Z$ 的第一个类型论证遵循了这一模式；我们称之为 \emph{同伦理论} 证明。

然而，后来我们发现有一个替代的证明，它更具类型理论的感觉，更接近于 \cref{sec:compute-coprod,sec:compute-nat} 中的证明。
在这个证明中，我们直接构造了~\eqref{eq:pi1s1-encode} 和~\eqref{eq:pi1s1-decode}，并通过计算证明它们是互逆的。
我们称之为 \emph{编码-解码} 证明（encode-decode proof），因为我们将函数~\eqref{eq:pi1s1-encode} 和~\eqref{eq:pi1s1-decode} 分别称为 \emph{编码} 和 \emph{解码}。
两个证明都使用了上面给出的相同的覆盖结构。
在经典证明中，从总空间的等价诱导出纤维上的等价，而编码-解码证明则明确地构造了一个作为纤维之间映射的逆映射（\emph{解码}）。
在经典证明中使用了可收缩性，而在编码-解码证明中使用了路径归纳、圆归纳和整数归纳。
这些是用于证明可收缩性的相同工具——实际上，路径归纳 \emph{本质上} 是与 $\mathsf{transport}$ 组合的路径纤维的可收缩性——但它们以不同的方式应用。

由于这是一本关于同伦类型论的书，我们首先介绍编码-解码证明。
如果一个同伦理论者感到困惑，建议跳到同伦理论证明（\cref{subsec:pi1s1-homotopy-theory}）。

\index{universal!cover|)}%
\index{cover!universal|)}%
\index{covering space!universal|)}%

\subsection{编码-解码证明 (The encode-decode proof)}
\label{subsec:pi1s1-encode-decode}

\index{encode-decode method|(}%
\indexsee{encode}{encode-decode method}%
\indexsee{decode}{encode-decode method}%
我们首先介绍将路径映射到代码的函数~\eqref{eq:pi1s1-encode}：
\begin{defn}
  定义 $\encode : \prd{x : \Sn ^1} (\base=x) \rightarrow  \code(x)$，其中
  \[
    \encode \: p \defeq \transfib{\code} p 0
  \]
  （我们省略了参数 $x$）。
\end{defn}
编码是通过提升路径到通用覆盖中定义的，这确定了一个等价性，然后将结果等价性应用于 $0$。
这个函数有趣的地方在于，它从圆上的环上计算出一个具体的数字，而这个环是使用同伦类型论的抽象群结构表示的。
为了获得关于它如何做到这一点的直观理解，请注意，依据上面的引理，$\transfib \code \lloop x$ 是后继函数，而 $\transfib \code {\opp\lloop} x$ 是前驱函数。
此外，$\mathsf{transport}$ 是函子性的（\cref{cha:basics}），所以 $\transfib{\code} {\lloop \ct \lloop}{\blank}$ 是
\[(\transfib \code \lloop-) \circ (\transfib \code \lloop-)\]
依此类推。
因此，当 $p$ 是像
\[
  \lloop \ct \opp \lloop \ct \lloop \ct \cdots
\]
这样的组合时，$\transfib{\code}{p}{\blank}$ 将计算一个类似于
\[
  \Zsuc \circ \Zpred \circ \Zsuc \circ \cdots
\]
的函数组合。
将这个函数组合应用于 $0$ 将计算路径的\emph{绕线数}（winding number）——路径绕过圆的次数，在逆转被取消之后，标志其方向是正还是负。
因此，$\encode$ 的计算行为来自于高级归纳类型和等价性的简化规则，以及 $\mathsf{transport}$ 在组合和逆上的作用。

请注意，实例 $\encode' \defeq \encode_{\base}$ 的类型为 $(\id \base \base) \rightarrow \Z$。
这将是我们所需等价的一个部分；实际上，它正是我们在 \cref{sec:pi1s1-initial-thoughts} 中定义的函数 $g$。

类似地，函数~\eqref{eq:pi1s1-decode} 是 \cref{sec:pi1s1-initial-thoughts} 中函数 $\lloop^{\blank}$ 的推广。

\begin{defn}\label{thm:pi1s1-decode}
通过圆归纳（circle induction）在 $x$ 上定义 $\decode : \prd{x : \Sn ^1}\code(x) \rightarrow (\base=x)$。
它足以给出一个函数 ${\code(\base) \rightarrow (\base=\base)}$，我们使用 $\lloop^{\blank}$，并展示 $\lloop^{\blank}$ 是如何尊重这个环的。
\end{defn}

\begin{proof}
  要展示 $\lloop^{\blank}$ 是如何尊重这个环的，足以给出一个从 $\lloop^{\blank}$ 到它本身的路径，该路径位于 $\lloop$ 之上。
  依据依赖路径的定义，这意味着一个路径从
  \[\transfib {(x' \mapsto \code(x') \rightarrow (\base=x'))} {\lloop} {\lloop^{\blank}}\]
  到 $\lloop^{\blank}$。
  我们定义这样的路径如下：
  \begin{align*}
    \MoveEqLeft \transfib {(x' \mapsto \code(x') \rightarrow (\base=x'))} \lloop {\lloop^{\blank}}\\
    &= \transfibf {x'\mapsto (\base=x')}(\lloop) \circ {\lloop^{\blank}} \circ \transfibf \code ({\opp \lloop}) \\
    &= (- \ct \lloop) \circ (\lloop^{\blank}) \circ \transfibf \code ({\opp \lloop}) \\
    &= (- \ct \lloop) \circ (\lloop^{\blank}) \circ \Zpred \\
    &= (n \mapsto \lloop^{n - 1} \ct \lloop)。
  \end{align*}
  在第一行中，我们应用了 $\mathsf{transport}$ 的特征，当纤维的外连接是 $\rightarrow$ 时，这将 $\mathsf{transport}$ 简化为在域和余域类型上与 $\mathsf{transport}$ 的预组合和后组合。
  在第二行中，我们应用了 $\mathsf{transport}$ 的特征，当类型族是 $x\mapsto \id{\base}{x}$ 时，这是路径的后组合。
  在第三行中，我们使用了 \cref{lem:transport-s1-code} 中 $\code$ 对 $\opp \lloop$ 的作用。
  在第四行中，我们只是简化了函数组合。
  因此，足以证明对于所有 $n$，$\id{\lloop^{n - 1} \ct \lloop}{\lloop^{n}}$。
  这是 \cref{thm:sign-induction} 的一个简单应用，使用了群论的法则。
\end{proof}

我们现在可以展示 $\encode$ 和 $\decode$ 是准逆的。
以前困难的方向现在变得容易了！

\begin{lem} \label{lem:s1-decode-encode}
对于所有 $x: \Sn ^1$ 和 $p : \id \base x$，$\id
{\decode_x({{\encode_x(p)}})} p$。
\end{lem}

\begin{proof}
  通过路径归纳（path induction），足以证明
  \narrowequation{\id {\decode_{\base}({{\encode_{\base}(\refl{\base})}})} {\refl{\base}}。}
  但
  \narrowequation{\encode_{\base}(\refl{\base}) \jdeq \transfib{\code}{\refl{\base}} 0 \jdeq 0，}
  且 $\decode_{\base}(0) \jdeq \lloop^ 0 \jdeq \refl{\base}$。
\end{proof}

另一个方向并不困难。

\begin{lem} \label{lem:s1-encode-decode} 对于所有
$x: \Sn ^1$ 和 $c : \code(x)$，我们有 $\id
{\encode_x({{\decode_x(c)}})} c$。
\end{lem}

\begin{proof}
  证明是通过圆归纳（circle induction）进行的。
  足以证明 \base 的情况，因为 \lloop 的情况是 $\Z$ 中路径之间的路径，这很简单，因为 $\Z$ 是一个集合。

  因此，足以证明，对于所有 $n : \Z$，
  \[
    \id {\encode'(\lloop^n)} {n}。
  \]
  证明是通过使用 \cref{thm:sign-induction} 的归纳进行的。
%
  \begin{itemize}

    \item 对于 $0$ 的情况，结果根据定义为真。

    \item 对于 $n+1$ 的情况，
    \begin{align}
    {\encode'(\lloop^{n+1})}
      &= {\encode'(\lloop^{n} \ct \lloop)} \tag{依据 $\lloop^{\blank}$ 的定义} \\
      &= \transfib{\code}{(\lloop^{n} \ct \lloop)}{0} \tag{依据 $\encode$ 的定义}\\
      &= \transfib{\code}{\lloop}{(\transfib{\code}{\lloop^n}{0})} \tag{依据函子性}\\
      &= {(\transfib{\code}{\lloop^n}{0})} + 1 \tag{依据 \cref{lem:transport-s1-code}}\\
      &= n + 1。 \tag{依据归纳假设}
    \end{align}

    \item 负数的情况是类似的。  \qedhere
  \end{itemize}
\end{proof}

最后，我们总结定理。

\begin{thm}
  存在一个等价的族 $\prd{x : \Sn ^1} (\eqv {(\base=x)} {\code(x)})$。
\end{thm}
\begin{proof}
  $\encode$ 和 $\decode$ 是准逆的，通过
  \cref{lem:s1-decode-encode,lem:s1-encode-decode}。
\end{proof}

在 \base 实例化给出
\begin{cor}\label{cor:omega-s1}
$\eqv {\Omega(\Sn^1,\base)} {\Z}$。
\end{cor}

一个简单的归纳表明，这个等价性将加法带入组合，因此 $\Omega(\Sn ^1) = \Z$ 作为群体。

\begin{cor} \label{cor:pi1s1}
$\id{\pi_1(\Sn ^1)} {\Z}$，而 $\id{\pi_n(\Sn ^1)}0$ 对于 $n>1$。
\end{cor}
\begin{proof}
  对于 $n=1$，我们在 \cref{cor:omega-s1} 中概述了证明。
  对于 $n > 1$，我们有 $\trunc 0 {\Omega^{n}(\Sn ^1)} = \trunc 0 {\Omega^{n-1}(\Omega{\Sn ^1})} = \trunc 0 {\Omega^{n-1}(\Z)}$。
  由于 $\Z$ 是一个集合，$\Omega^{n-1}(\Z)$ 是可收缩的，因此这是平凡的。
\end{proof}

\index{encode-decode method|)}%

\subsection{同伦理论的证明 (The homotopy-theoretic proof)}
\label{subsec:pi1s1-homotopy-theory}

在 \cref{sec:pi1s1-universal-cover} 中，我们在类型理论中定义了推测的通用覆盖 $\code:\Sn^1\to\type$，并在 \cref{subsec:pi1s1-encode-decode} 中定义了从路径纤维到通用覆盖的映射 $\encode : \prd{x:\Sn^1} (\base=x) \to \code(x)$。
经典证明剩下的内容是证明这个映射在总空间上诱导等价，因为两者都是可收缩的，并从中推导出它在每个纤维上的等价。

\index{total!space}%
在 \cref{thm:contr-paths} 中，我们看到总空间 $\sm{x:\Sn^1} (\base=x)$ 是可收缩的。
对于另一个，我们有：

\begin{lem}\label{thm:iscontr-s1cover}
类型 $\sm{x:\Sn^1}\code(x)$ 是可收缩的。
\end{lem}
\begin{proof}
  我们应用 \cref{thm:flattening} 中的展平引理（flattening lemma），使用以下值：
  \begin{itemize}
    \item $A\defeq\unit$ 和 $B\defeq\unit$，$f$ 和 $g$ 是显然的函数。
    因此，展平引理中的基高阶归纳类型 $W$ 等价于 $\Sn^1$。
    \item $C:A\to\type$ 是常数 $\Z$。
    \item $D:\prd{b:B} (\eqv{\Z}{\Z})$ 是常数 $\Zsuc$。
  \end{itemize}
  然后，展平引理中定义的类型族 $P:\Sn^1\to\type$ 等价于 $\code:\Sn^1\to\type$。
  因此，展平引理告诉我们，$\sm{x:\Sn^1}\code(x)$ 等价于一个具有以下生成器的高阶归纳类型，我们将其标记为 $R$：
  \begin{itemize}
    \item 一个函数 $\mathsf{c}: \Z \to R$。
    \item 对于每个 $z:\Z$，一个路径 $\mathsf{p}_z:\mathsf{c}(z) = \mathsf{c}(\Zsuc(z))$。
  \end{itemize}
  我们可以称这个类型为\define{同伦实数}（homotopical reals）；
  \indexdef{real numbers!homotopical}%
  它与经典证明中的拓扑空间 $\mathbb{R}$ 起着相同的作用。

  因此，剩下的就是证明 $R$ 是可收缩的。
  作为收缩的中心，我们选择 $\mathsf{c}(0)$；我们现在必须证明 $x=\mathsf{c}(0)$ 对于所有 $x:R$。
  我们通过在 $R$ 上的归纳来做到这一点。
  首先，当 $x$ 是 $\mathsf{c}(z)$ 时，我们必须给出一个路径 $q_z:\mathsf{c}(0) = \mathsf{c}(z)$，我们可以通过对 $z:\Z$ 的归纳来做到这一点，使用 \cref{thm:sign-induction}：
  \begin{align*}
    q_0 &\defid \refl{\mathsf{c}(0)}\\
    q_{n+1} &\defid q_n \ct \mathsf{p}_n & &\text{对于 $n\ge 0$}\\
    q_{n-1} &\defid q_n \ct \opp{\mathsf{p}_{n-1}} & &\text{对于 $n\le 0$}。
  \end{align*}
  其次，我们必须证明对于任何 $z:\Z$，路径 $q_z$ 在 $\mathsf{p}_z$ 上的运输是 $q_{z+1}$。
  通过路径的运输，这意味着我们需要 $q_z \ct \mathsf{p}_z = q_{z+1}$。
  这通过 $z$ 的归纳很容易做到，使用 $q_z$ 的定义。
  这完成了 $R$ 是可收缩的证明，因此 $\sm{x:\Sn^1}\code(x)$ 也是可收缩的。
\end{proof}

\begin{cor}\label{thm:encode-total-equiv}
由 \encode 诱导的映射：
\[ \tsm{x:\Sn^1} (\base=x) \to \tsm{x:\Sn^1}\code(x) \]
是一个等价。
\end{cor}
\begin{proof}
  两种类型都是可收缩的。
\end{proof}

\begin{thm}
  $\eqv {\Omega(\Sn^1,\base)} {\Z}$。
\end{thm}
\begin{proof}
  将 \cref{thm:total-fiber-equiv} 应用于 $\encode$，使用 \cref{thm:encode-total-equiv}。
\end{proof}

本质上，这两个证明没有太大不同：编码-解码的证明可以看作是同伦理论证明的“简化”或“解包”。
每个都有其优势；两者之间的相互作用是该主题的一部分兴趣所在。
\index{fundamental!group!of circle|)}

\subsection{通用覆盖作为恒等系统 (The universal cover as an identity system)}
\label{sec:pi1s1-idsys}

请注意，纤维 $\code:\Sn^1\to\type$ 与 $0:\code(\base)$ 一起是 \cref{defn:identity-systems} 中所述的\emph{指向谓词}（pointed predicate）。
从这个角度来看，我们可以看到，在 \cref{subsec:pi1s1-encode-decode} 中的编码-解码证明由证明 \code 满足 \cref{thm:identity-systems}\ref{item:identity-systems3} 组成，而在 \cref{subsec:pi1s1-homotopy-theory} 中的同伦理论证明则由证明它满足 \cref{thm:identity-systems}\ref{item:identity-systems4} 组成。
这暗示了一种第三种方法。

\begin{thm}
  对于 $\base:\Sn^1$，对偶 $(\code,0)$ 是 \cref{defn:identity-systems} 中所定义的恒等系统（identity system）。
\end{thm}
\begin{proof}
  令 $D:\prd{x:\Sn^1} \code(x) \to \type$ 和 $d:D(\base,0)$ 已给出；我们要定义一个函数 $f:\prd{x:\Sn^1}{c:\code(x)} D(x,c)$。
  通过圆归纳，足以指定 $f(\base):\prd{c:\code(\base)} D(\base,c)$ 并验证 $\trans{\lloop}{f(\base)} = f(\base)$。

  当然，$\code(\base)\jdeq \Z$。
  通过 \cref{lem:transport-s1-code} 和对 $n$ 的归纳，我们可以为任何整数 $n$ 获得一个路径 $p_n : \transfib{\code}{\lloop^n}{0} = n$。
  因此，通过 $\Sigma$-类型的路径，我们在 $\sm{x:\Sn^1} \code(x)$ 中有一个路径 $\pairpath(\lloop^n,p_n) : (\base,0) = (\base,n)$。
  在与 $D$ 相关联的纤维 $\widehat{D}:(\sm{x:\Sn^1} \code(x)) \to\type$ 中沿着这个路径运输 $d$，我们获得 $D(\base,n)$ 的一个元素。
  我们定义这个元素为 $f(\base)(n)$：
  \[ f(\base)(n) \defeq \transfib{\widehat{D}}{\pairpath(\lloop^n,p_n)}{d}。 \]
  %
  现在我们需要 $\transfib{\lam{x} \prd{c:\code(x)} D(x,c)}{\lloop}{f(\base)} = f(\base)$。
  通过 \cref{thm:dpath-forall}，这意味着我们需要证明对于任何 $n:\Z$，
  %
  \begin{narrowmultline*}
    \transfib{\widehat D}{\pairpath(\lloop,\refl{\trans\lloop n})}{f(\base)(n)}
    =_{D(\base,\trans\lloop n)} \narrowbreak
    f(\base)(\trans\lloop n)。
  \end{narrowmultline*}
  %
  现在我们有一个路径 $q:\trans\lloop n = n+1$，所以沿着这个路径运输，足以证明
  \begin{multline*}
    \transfib{D(\base)}{q}{\transfib{\widehat D}{\pairpath(\lloop,\refl{\trans\lloop n})}{f(\base)(n)}}\\
    =_{D(\base,n+1)} \transfib{D(\base)}{q}{f(\base)(\trans\lloop n)}。
  \end{multline*}
  通过关于运输和依赖应用的几个引理，这等效于
  \[ \transfib{\widehat D}{\pairpath(\lloop,q)}{f(\base)(n)} =_{D(\base,n+1)} f(\base)(n+1)。 \]
  然而，展开 $f(\base)$ 的定义，我们有
  \begin{narrowmultline*}
    \transfib{\widehat D}{\pairpath(\lloop,q)}{f(\base)(n)}
    \narrowbreak
    \begin{aligned}[t]
      &= \transfib{\widehat D}{\pairpath(\lloop,q)}{\transfib{\widehat{D}}{\pairpath(\lloop^n,p_n)}{d}}\\
      &= \transfib{\widehat D}{\pairpath(\lloop^n,p_n) \ct \pairpath(\lloop,q)}{d}\\
      &= \transfib{\widehat D}{\pairpath(\lloop^{n+1},p_{n+1})}{d}\\
      &= f(\base)(n+1)。
    \end{aligned}
  \end{narrowmultline*}
  我们使用了运输的函子性，$\Sigma$-类型中的组合的特征（这是读者的练习），以及一个将 $p_n$ 和 $q$ 关联到 $p_{n+1}$ 的引理，我们将留给读者陈述和证明。

  这完成了函数 $f:\prd{x:\Sn^1}{c:\code(x)} D(x,c)$ 的构造。
  由于
  \[f(\base,0) \jdeq \trans{\pairpath(\lloop^0,p_0)}{d} = \trans{\refl{\base}}{d} = d，\]
  我们已经证明了 $(\code,0)$ 是一个恒等系统。
\end{proof}

\begin{cor}
  对于任何 $x:\Sn^1$，我们有 $\eqv{(\base=x)}{\code(x)}$。
\end{cor}
\begin{proof}
  通过 \cref{thm:identity-systems}。
\end{proof}

当然，这个证明也包含了前两个证明的基本元素。
大致上，我们可以说它统一了 \cref{thm:pi1s1-decode,lem:s1-encode-decode} 的证明，在一般情况下只执行一次所需的归纳论证。

\begin{rmk}
  请注意，所有上述证明 $\eqv{\pi_1(\Sn^1)}{\Z}$ 都在本质上使用了等价性公理。
  这是不可避免的：等价性或类似的东西是\emph{必要的}，以证明 $\eqv{\pi_1(\Sn^1)}{\Z}$。
  在没有等价性的情况下，可以假设“所有类型都是集合”的陈述（又称为“恒等证明的唯一性”或“Axiom K”，如 \cref{sec:hedberg} 中讨论的），该陈述则意味着 $\eqv{\pi_1(\Sn^1)}{\unit}$。
  实际上，$\pi_1(\Sn^1)$ 的（非）平凡性正好检测所有类型是否为集合：\cref{thm:loop-nontrivial} 的证明反过来表明，如果 $\lloop=\refl{\base}$，则所有类型都是集合。
\end{rmk}

\section{悬挂的连通性 (Connectedness of suspensions)}
\label{sec:conn-susp}

回顾在 \cref{sec:connectivity} 中提到的，如果一个类型 $A$ 被称为 \define{$n$-连通的 ($n$-connected)}，则 $\trunc nA$ 是可收缩的 (contractible)。
本节的目的是证明悬挂操作 (suspension operation) 会增加连通性，如 \cref{sec:suspension} 中所述。

\begin{thm} \label{thm:suspension-increases-connectedness}
如果 $A$ 是 $n$-连通的，那么 $A$ 的悬挂 (suspension) 是 $(n+1)$-连通的。
\end{thm}

\begin{proof}
  我们在 \cref{sec:colimits} 中提到，$A$ 的悬挂是推挤 (pushout) $\unit\sqcup^A\unit$，因此我们需要证明以下类型是可收缩的：
  %
  \[\trunc{n+1}{\unit\sqcup^A\unit}。\]
  %
  根据 \cref{reflectcommutespushout}，我们知道 $\trunc{n+1}{\unit\sqcup^A\unit}$ 是 $\typelep{n+1}$ 中以下图表的推挤：
  \[\xymatrix{\trunc{n+1}A \ar[d] \ar[r] & \trunc{n+1}{\unit} \\
  \trunc{n+1}{\unit} & }。\]
  %
  鉴于 $\trunc{n+1}{\unit}=\unit$，$\trunc{n+1}{\unit\sqcup^A\unit}$ 的类型在 $\typelep{n+1}$ 中也是以下图表的推挤（因为两个图表是相等的）：
  %
  \[\Ddiag=\vcenter{\xymatrix{\trunc{n+1}A \ar[d] \ar[r] & \unit \\
  \unit & }}。\]
  %
  我们现在将证明在 $\typelep{n+1}$ 中 $\unit$ 也是 $\Ddiag$ 的推挤。
  %
  设 $E$ 是一个 $(n+1)$-截断的类型；我们需要证明以下映射是一个等价 (equivalence)：
  %
  \[\function{(\unit \to E)}{\cocone{\Ddiag}{E}}{y}
  {(y,y,\lamu{u:{\trunc{n+1}A}} \refl{y(\ttt)})}。\]
  %
  我们回顾一下，$\cocone{\Ddiag}{E}$ 是以下类型：
  \[\sm{f:\unit \to E}{g:\unit \to E}(\trunc{n+1}A\to
  (f(\ttt)=_E{}g(\ttt)))。\]
  %
  映射 $\function{(\unit\to E)}{E}{f}{f(\ttt)}$ 是一个等价映射，因此我们也有
  \[\cocone{\Ddiag}{E}=\sm{x:E}{y:E}(\trunc{n+1}A\to(x=_Ey))。\]
  %
  现在 $A$ 是 $n$-连通的，因此 $\trunc{n+1}A$ 也是 $n$-连通的，因为 $\trunc n{\trunc{n+1}A}=\trunc nA=\unit$，而 $(x=_Ey)$ 是 $n$-截断的，因为 $E$ 是 $(n+1)$-截断的。因此，根据 \cref{connectedtotruncated}，以下映射是一个等价映射：
  %
  \[\function{(x=_Ey)}{(\trunc{n+1}A\to(x=_Ey))}{p}{\lam{z} p}\]
  %
  因此我们有
  %
  \[\cocone{\Ddiag}{E}=\sm{x:E}{y:E}(x=_Ey)。\]
  %
  但是以下映射是一个等价映射：
  %
  \[\function{E}{\sm{x:E}{y:E}(x=_Ey)}{x}{(x,x,\refl{x})}。\]
  %
  因此
  %
  \[\cocone{\Ddiag}{E}=E。\]
  %
  最后我们得到一个等价映射
  %
  \[(\unit \to E)\eqvsym\cocone{\Ddiag}{E}\]
  %
  我们现在可以展开定义以得到此映射的明确表达式，并且我们可以轻松地看到，这正是我们在开始时所得到的映射。

  因此我们证明了 $\unit$ 是 $\typelep{n+1}$ 中 $\Ddiag$ 的推挤。使用推挤的唯一性，我们得到 $\trunc{n+1}{\unit\sqcup^A\unit}=\unit$，这证明了 $A$ 的悬挂是 $(n+1)$-连通的。
\end{proof}

\begin{cor} \label{cor:sn-connected}
对于所有 $n:\N$，球体 $\Sn^n$ 是 $(n-1)$-连通的。
\end{cor}

\begin{proof}
  我们通过归纳法证明这一点。
  %
  对于 $n=0$，我们必须证明 $\Sn^0$ 仅仅是居住的 (inhabited)，这是显然的。
  %
  设 $n:\N$ 使得 $\Sn^n$ 是 $(n-1)$-连通的。根据定义，$\Sn^{n+1}$ 是 $\Sn^n$ 的悬挂，因此根据前面的引理，$\Sn^{n+1}$ 是 $n$-连通的。
\end{proof}

\section{\texorpdfstring{$n$-连通空间和 \texorpdfstring{$\pi_{k < n}(\Sn ^n)$}{π\_(k<n)(Sⁿ)} 的 \texorpdfstring{$\pi_{k \le n}$}{π\_(k≤n)}}
\label{sec:pik-le-n}

设 $(A,a)$ 是一个有基点的类型 (pointed type)，$n:\N$。回顾在 \cref{thm:homotopy-groups} 中提到的，如果 $n>0$，则集合 $\pi_n(A,a)$ 具有群结构 (group structure)，如果 $n>1$，则该群是阿贝尔群 (abelian group)\index{group!abelian}。

我们现在可以讨论 $n$-截断类型 (n-truncated type) 和 $n$-连通类型的同伦群 (homotopy groups)。

\begin{lem}
  如果 $A$ 是 $n$-截断的并且 $a:A$，那么对于所有 $k>n$，$\pi_k(A,a)=\unit$。
\end{lem}

\begin{proof}
  $n$-类型的环空间 (loop space) 是一个 $(n-1)$-类型，因此 $\Omega^k(A,a)$ 是一个 $(n-k)$-类型，并且我们有 $(n-k)\le-1$，所以 $\Omega^k(A,a)$ 是一个单纯命题 (mere proposition)。但是 $\Omega^k(A,a)$ 是居住的，因此它实际上是可收缩的，$\pi_k(A,a)=\trunc0{\Omega^k(A,a)}=\trunc0{\unit}=\unit$。
\end{proof}

\begin{lem} \label{lem:pik-nconnected}
如果 $A$ 是 $n$-连通的并且 $a:A$，那么对于所有 $k\le{}n$，$\pi_k(A,a)=\unit$。
\end{lem}

\begin{proof}
  我们有以下等式序列：
  %
  \begin{narrowmultline*}
    \pi_k(A,a) = \trunc0{\Omega^k(A,a)}
    = \Omega^k(\trunc k{(A,a)})
    = \Omega^k(\trunc k{\trunc n{(A,a)}})
    = \narrowbreak
    \Omega^k(\trunc k{\unit})
    = \Omega^k(\unit)
    = \unit。
  \end{narrowmultline*}
  %
  第三个等式使用了 $k\le{}n$ 的事实，以便使用 $\truncf k\circ\truncf n=\truncf k$，第四个等式使用了 $A$ 是 $n$-连通的事实。
\end{proof}

\begin{cor}
  对于 $k < n$，$\pi_k(\Sn ^n) = \unit$。
\end{cor}
\begin{proof}
  根据 \cref{cor:sn-connected}，球体 $\Sn^n$ 是 $(n-1)$-连通的，因此我们可以应用 \cref{lem:pik-nconnected}。
\end{proof}

\section{纤维序列和长确界序列 (Fiber sequences and the long exact sequence)}
\label{sec:long-exact-sequence-homotopy-groups}

\index{fiber sequence|(}%
\index{sequence!fiber|(}%

如果一个函数 $f:X\to Y$ 的余域 (codomain) 装备了一个基点 $y_0:Y$，那么我们称 $f$ 在 $y_0$ 上的纤维 $F\defeq \hfib f {y_0}$ 为 \define{函数 $f$ 的纤维 (the fiber of $f$)}\index{fiber}。
（如果 $Y$ 是连通的，那么 $F$ 是仅凭等价确定的 (determined up to mere equivalence)；参见 \cref{ex:unique-fiber}。）
我们现在表明，如果 $X$ 也是有基点的，并且 $f$ 保持基点，那么 $F$、$X$ 和 $Y$ 的同伦群之间存在一个长确界序列 (long exact sequence) 的关系。
我们通过与这样的 $f$ 相关联的纤维序列 (fiber sequence) 来推导这一点。

\begin{defn}\label{def:pointedmap}
有基点类型 $(X,x_0)$ 和 $(Y,y_0)$ 之间的一个 \define{有基点映射 (pointed map)}\index{pointed!map}%
\indexsee{function!pointed}{pointed map} 是一个映射 $f:X\to Y$ 以及一个路径 $f_0:f(x_0)=y_0$。
\end{defn}

对于任何有基点类型 $(X,x_0)$ 和 $(Y,y_0)$，存在一个有基点映射 $(\lam{x} y_0) : X\to Y$，它在基点处是常值的 (constant)。
我们将此称为 \define{零映射 (zero map)}\index{zero!map}\index{function!zero} 并有时将其记作 $0:X\to Y$。

回顾一下，每个有基点类型 $(X,x_0)$ 都有一个环空间 (loop space)\index{loop space} $\Omega (X,x_0)$。
我们现在注意到，该操作在有基点映射上是函子性的 (functorial)。\index{loop space!functoriality of}\index{functor!loop space}

\begin{defn}\label{def:loopfunctor}
给定有基点类型之间的一个有基点映射 $f:X \to Y$，我们定义有基点映射 $\Omega f:\Omega X
\to \Omega Y$ 如下：
\[(\Omega f)(p) \defeq \rev{f_0}\ct\ap{f}{p}\ct f_0。\]
路径 $(\Omega f)_0 : (\Omega f) (\refl{x_0}) = \refl{y_0}$，它展示了 $\Omega f$ 作为有基点映射，是以下类型的显然路径：
\[\rev{f_0}\ct\ap{f}{\refl{x_0}}\ct f_0=\refl{y_0}。\]
\end{defn}

在有基点映射上还有另一个函子，它将 $f:X\to Y$ 映射到 $\proj1 : \hfib f {y_0} \to X$。
当 $f$ 是有基点映射时，我们总是认为 $\hfib f {y_0}$ 是有基点的，其基点是 $(x_0,f_0)$，在这种情况下，$\proj1$ 也是一个有基点映射，其见证 (witness) 是 $(\proj1)_0 \defeq \refl{x_0}$。
因此，此操作可以迭代。

\begin{defn}
  一个有基点映射 $f:X\to Y$ 的 \define{纤维序列 (fiber sequence)}\index{fiber sequence}%
  \index{sequence!fiber} 是以下无限序列的有基点类型和有基点映射：
  \[\xymatrix{\dots \ar[r]^{f^{(n+1)}} & X^{(n+1)} \ar[r]^{f^{(n)}} & X^{(n)} \ar^-{f^{(n-1)}}[r] & \dots \ar[r] & X^{(2)} \ar^-{f^{(1)}}[r] & X^{(1)} \ar[r]^{f^{(0)}} & X^{(0)}}\]
  该序列递归地定义为
  \[ X^{(0)} \defeq Y\qquad
  X^{(1)} \defeq X\qquad
  f^{(0)} \defeq f\qquad
  \]
  以及
  \begin{alignat*}{2}
    X^{(n+1)} &\defeq \hfib {f^{(n-1)}}{x^{(n-1)}_0}\\
    f^{(n)} &\defeq \proj1 &: X^{(n+1)} \to X^{(n)}。
  \end{alignat*}
  其中 $x^{(n)}_0$ 表示 $X^{(n)}$ 的基点，如上所述递归选择。
\end{defn}

因此，此纤维序列中的任何相邻的映射对都具有以下形式：
\[ \xymatrix{ X^{(n+1)} \jdeq \hfib{f^{(n-1)}}{x^{(n-1)}_0} \ar[rr]^-{f^{(n)}\jdeq \proj1} && X^{(n)} \ar[r]^{f^{(n-1)}} & X^{(n-1)}。} \]
特别是，我们有 $f^{(n-1)} \circ f^{(n)} = 0$。
我们现在注意到，在此序列中出现的类型是基空间 $Y$ 的迭代环空间\index{loop space!iterated}、总空间\index{total!space} $X$ 和纤维 $F\defeq \hfib f {y_0}$，映射也是如此。

\begin{lem}\label{thm:fiber-of-the-fiber}
设 $f:X\to Y$ 是有基点空间的有基点映射。那么：
\begin{enumerate}
  \item $f^{(1)}\defeq \proj1 : \hfib f {y_0} \to X$ 的纤维是与 $\Omega Y$ 等价的。\label{item:fibseq1}
  \item 类似地，$f^{(2)} : \Omega Y \to \hfib f {y_0}$ 的纤维是与 $\Omega X$ 等价的。\label{item:fibseq2}
  \item 在这些等价的情况下，有基点映射 $f^{(3)} : \Omega X\to \Omega Y$ 与有基点映射 $\Omega f\circ\rev{(\blank)}$ 是一致的。\label{item:fibseq3}
\end{enumerate}
\end{lem}
\begin{proof}
  对于~\ref{item:fibseq1}，我们有
  \begin{align*}
    \hfib{f^{(1)}}{x_0}
    &\defeq \sm{z:\hfib{f}{y_0}} (\proj{1}(z) = x_0)\\
    &\eqvsym \sm{x:X}{p:f(x)=y_0} (x = x_0) &\text{(根据 \cref{ex:sigma-assoc})}\\
    &\eqvsym (f(x_0) = y_0) &\text{(因为 $\tsm{x:X} (x=x_0)$ 是可收缩的)}\\
    &\eqvsym (y_0 = y_0) &\text{(根据 $(f_0 \ct \blank)$)}\\
    &\jdeq \Omega Y。
  \end{align*}
  追溯下去，我们看到这个等价映射将 $((x,p),q)$ 映射到 $\opp{f_0} \ct \ap{f}{\opp q} \ct p$，而它的逆映射将 $r:y_0=y_0$ 映射到 $((x_0, f_0 \ct r), \refl{x_0})$。
  特别是，$\hfib{f^{(1)}}{x_0}$ 的基点 $((x_0,f_0),\refl{x_0})$ 被映射到 $\opp{f_0} \ct \ap{f}{\opp {\refl{x_0}}} \ct f_0$，这等于 $\refl{y_0}$。
  因此此等价映射是一个有基点映射 (参见 \cref{ex:pointed-equivalences})。
  此外，在此等价映射下，$f^{(2)}$ 被识别为映射 $\lam{r} (x_0, f_0 \ct r): \Omega Y \to \hfib f {y_0}$。

  \cref{item:fibseq2} 立即通过将~\ref{item:fibseq1} 应用于 $f^{(1)}$ 代替 $f$ 来得出。
  % 结果等价映射将 $(((x,p),p'),q') : \hfib{f^{(2)}}{(x_0,f_0)}$ 映射到 $\ap{f}{\opp {q'}} \ct p'$，而它的逆映射将 $s:x_0=x_0$ 映射到 $(((x_0,f_0), s), \refl{(x_0,f_0)})$。
  由于 $(f^{(1)})_0 \defeq \refl{x_0}$，在此等价映射下 $f^{(3)}$ 被识别为映射 $\Omega X \to \hfib {f^{(1)}}{x_0}$，该映射由 $s \mapsto ((x_0,f_0),s)$ 定义。
  因此，当我们与先前的等价映射 $\hfib {f^{(1)}}{x_0} \eqvsym \Omega Y$ 组合时，我们看到 $s$ 被映射到 $\opp{f_0} \ct \ap{f}{\opp s} \ct f_0$，这根据定义是 $(\Omega f)(\opp s)$。我们省略了证明这是一个有基点映射的证明，而不仅仅是函数的等价性。
\end{proof}

因此，$f:X\to Y$ 的纤维序列可以表示为：
\[\xymatrix@C=1.5pc{
  \dots \ar[r] &
  \Omega^2 X \ar[r]^-{\Omega^2 f} &
  \Omega^2 Y \ar[r]^-{-\Omega \partial} &
  \Omega F \ar[r]^-{-\Omega i} &
  \Omega X \ar[r]^-{-\Omega f} &
  \Omega Y \ar[r]^-{\partial} &
  F \ar[r]^-{i} &
  X \ar[r]^{f} & Y。}\]
其中负号表示与路径逆序 (path inversion) $\rev{(\blank)}$ 的组合。
请注意，根据 \cref{ex:ap-path-inversion}，我们有
\[ \Omega\left(\Omega f\circ \opp{(\blank)}\right) \circ \opp{(\blank)}
= \Omega^2 f \circ \opp{(\blank)} \circ \opp{(\blank)}
= \Omega^2 f。
\]
因此，当 $k$ 为奇数时，$k$ 次环映射上的符号是负号。

从这个纤维序列中，我们将推导出一个 \emph{有基点集的确界序列 (exact sequence of pointed sets)}。
\index{image}%
设 $A$ 和 $B$ 是集合，并且 $f:A\to B$ 是一个函数，并且回顾在 \cref{defn:modal-image} 中图像 $\im(f)$ 的定义，它可以视为 $B$ 的子集：
\[\im(f) \defeq \setof{b:B | \exis{a:A} f(a)=b}。 \]
如果 $A$ 和 $B$ 另外是有基点的，基点分别为 $a_0$ 和 $b_0$，并且 $f$ 是一个有基点映射，我们定义 $f$ 的 \define{核 (kernel)}\index{kernel}%
\index{pointed!map!kernel of}%
作为 $A$ 的以下子集：
\symlabel{kernel}
\[\ker(f) \defeq \setof{x:A | f(x) = b_0}。 \]
当然，这只是 $f$ 在基点 $b_0$ 上的纤维；它是 $A$ 的一个子集，因为 $B$ 是一个集合。

请注意，任何群都是一个有基点的集合，其单位元素作为基点，并且任何群同态 (group homomorphism) 都是一个有基点映射。
在这种情况下，核和图像与群论中的通常概念是一致的。

\begin{defn}
  一个 \define{有基点集的确界序列 (exact sequence of pointed sets)}\index{exact sequence}%
  \index{sequence!exact} 是一个（可能有界的）有基点集和有基点映射的序列：
  \[\xymatrix{\dots \ar[r] & A^{(n+1)} \ar[r]^-{f^{(n)}} & A^{(n)} \ar[r]^{f^{(n-1)}} & A^{(n-1)} \ar[r] &
  \dots}\]
  对于每个 $n$，$f^{(n)}$ 的图像作为 $A^{(n)}$ 的一个子集，等于 $f^{(n-1)}$ 的核。
  换句话说，对于所有 $a:A^{(n)}$，我们有
  \[ (f^{(n-1)}(a) = a^{(n-1)}_0) \iff \exis{b:A^{(n+1)}} (f^{(n)}(b)=a)。 \]
  其中 $a^{(n)}_0$ 表示 $A^{(n)}$ 的基点。
\end{defn}

通常，确界序列中的大多数或全部有基点集是群，通常是阿贝尔群。
当我们谈论一个 \define{群的确界序列 (exact sequence of groups)} 时，默认假设映射是群同态，而不仅仅是有基点映射。

\index{exact sequence}
\begin{thm}\label{thm:les}
设 $f:X \to Y$ 是有基点空间之间的一个有基点映射，其纤维为 $F\defeq \hfib f {y_0}$。
然后我们得到以下长确界序列，它由群组成，除了最后三个项，以及阿贝尔群，除了最后六个项。

\[
  \xymatrix@R=1.2pc@C=3pc{
    \vdots & \vdots & \vdots \ar[lld] \\
    \pi_k(F) \ar[r] & \pi_k(X) \ar[r] & \pi_k(Y) \ar[lld] \\
    \vdots & \vdots & \vdots \ar[lld] \\
    \pi_2(F) \ar[r] & \pi_2(X) \ar[r] & \pi_2(Y) \ar[lld] \\
    \pi_1(F) \ar[r] & \pi_1(X) \ar[r] & \pi_1(Y) \ar[lld]\\
    \pi_0(F) \ar[r] & \pi_0(X) \ar[r] & \pi_0(Y)}
\]
\end{thm}

\vspace*{0pt plus 10ex}
\goodbreak

\begin{proof}
  我们首先证明一个纤维序列的 0-截断是有基点集的确界序列。
  因此，我们需要证明，对于纤维序列中的任何相邻映射对：
  %
  \[\xymatrix{\hfib{f}{z_0} \ar^-g[r] & W \ar^-f[r] & Z}\]
  %
  其中 $g\defeq \proj1$，序列
  %
  \[\xymatrix{\trunc{0}{\hfib{f}{z_0}} \ar^-{\trunc0g}[r] & \trunc0{W}
    \ar^-{\trunc0{f}}[r] & \trunc0{Z}}\]
  %
  是确界的，即 $\im(\trunc0g)\subseteq\ker(\trunc0f)$ 和 $\ker(\trunc0f)\subseteq\im(\trunc0g)$。

  第一个包含等价于 $\trunc0g\circ\trunc0f=0$，这通过 $\truncf0$ 的函子性和 $g\circ f=0$ 的事实得到证明。
  对于第二个，我们假设 $w':\trunc0W$ 并且 $p':\trunc0f(w')=\tproj0{z_0}$ 并展示仅存在 $t:\hfib{f}{z_0}$ 使得 $g(t)=w'$。
  由于我们的目标是一个简单命题，我们可以假设 $w'$ 的形式为 $\tproj0w$ 对于某些 $w:W$。
  现在根据 \cref{thm:path-truncation}，$p' : \tproj0{f(w)}=\tproj0{z_0}$ 产生 $p'': \trunc{-1}{f(w)=z_0}$，因此通过进一步的截断归纳，我们可以假设存在一些 $p:f(w)=z_0$。
  但是现在我们有 $\tproj0{(w,p)}:\tproj0{\hfib{f}{z_0}}$，其在 $\trunc0g$ 下的映像是 $\tproj0w\jdeq w'$，如所愿。

  因此，将 $\truncf0$ 应用于 $f$ 的纤维序列，我们得到一个长确界序列，其中涉及到 $\pi_k(F)$、$\pi_k(X)$ 和 $\pi_k(Y)$ 的有基点集，并按所需顺序排列。
  当然，$\pi_k$ 是 $k\ge1$ 时的群，是环空间的 0-截断，并且 $k\ge 2$ 时是阿贝尔群，根据 Eckmann--Hilton 论证
  \index{Eckmann--Hilton argument} (\cref{thm:EckmannHilton})。
  此外，\cref{thm:fiber-of-the-fiber} 允许我们将此确界序列中的映射 $\pi_k(F) \to \pi_k(X)$ 和 $\pi_k(X) \to \pi_k(Y)$ 识别为 $(-1)^k \pi_k(i)$ 和 $(-1)^k \pi_k(f)$。

  更一般地，除了最后三个之外，此长确界序列中的每个映射都是 $\trunc0{\Omega h}$ 或 $\trunc0{-\Omega h}$ 形式的映射。
  在前一种情况下，它是群同态，而在后一种情况下，如果这些群是阿贝尔群，它是同态；否则它是“反同态”。
  但是，群同态的核和图像在我们将其替换为其负值时保持不变，因此涉及到它的任何序列的确界性也是如此。
  因此，我们可以修改我们的长确界序列，以获得一个涉及 $\pi_k(i)$ 和 $\pi_k(f)$ 的序列，并且所有映射都是群同态（除了最后三个）。
\end{proof}

通常的阿贝尔群的确界序列\index{group!abelian!exact sequence of} 的性质可以按常规证明。特别是我们有：
\begin{lem}\label{thm:ses}
假设给定一个阿贝尔群的确界序列：
%
\[\xymatrix{K \ar[r]& G \ar^f[r] & H \ar[r] & Q。}\]
%
\begin{enumerate}
  \item 如果 $K=0$，则 $f$ 是单射。\label{item:sesinj}
  \item 如果 $Q=0$，则 $f$ 是满射。\label{item:sessurj}
  \item 如果 $K=Q=0$，则 $f$ 是同构。\label{item:sesiso}
\end{enumerate}
\end{lem}
\begin{proof}
  由于 $f$ 的核是 $K\to G$ 的图像，如果 $K=0$，则 $f$ 的核是 $\{0\}$；
  因此 $f$ 是单射，因为它是群同态。
  类似地，由于 $f$ 的图像是 $H\to Q$ 的核，如果 $Q=0$，则 $f$ 的图像是所有 $H$，因此 $f$ 是满射。
  最后，~\ref{item:sesiso} 通过 \cref{thm:mono-surj-equiv} 从~\ref{item:sesinj} 和~\ref{item:sessurj} 得出。
\end{proof}

作为一个直接的应用，我们现在可以量化 $n$-连通性的一个映射比在 $n$-截断上诱导一个等价关系要强。

\begin{cor}\label{thm:conn-pik}
设 $f:A\to B$ 是 $n$-连通的并且 $a:A$，定义 $b\defeq f(a)$。那么：
\begin{enumerate}
  \item 如果 $k\le n$，则 $\pi_k(f):\pi_k(A,a) \to \pi_k(B,b)$ 是同构。\label{item:conn-pik1}
  \item 如果 $k=n+1$，则 $\pi_k(f):\pi_k(A,a) \to \pi_k(B,b)$ 是满射。\label{item:conn-pik2}
\end{enumerate}
\end{cor}
\begin{proof}
  对于 $k=0$，部分~\ref{item:conn-pik1} 由 \cref{lem:connected-map-equiv-truncation} 得出，注意到 $\pi_0(f)\equiv\trunc 0f$。
  对于 $k=0$，部分~\ref{item:conn-pik2} 由 \cref{ex:is-conn-trunc-functor} 得出，注意到一个函数是满射当且仅当它是 $(-1)$-连通的，通过 \cref{thm:minusoneconn-surjective}。
  对于 $k>0$，我们在长确界序列中有一个确界序列
  \[\xymatrix{\pi_k(\hfib f b) \ar[r]& \pi_k(A,a) \ar^f[r] & \pi_k(B,b) \ar[r] & \pi_{k-1}(\hfib f b)。}\]
  现在由于 $f$ 是 $n$-连通的，$\trunc n{\hfib f b}$ 是可缩的。
  因此，如果 $k\le n$，则 $\pi_k(\hfib f b) = \trunc0{\Omega^k(\hfib f b)} = \Omega^k(\trunc k{\hfib f b})$ 也是可缩的。
  因此，根据 \cref{thm:ses}\ref{item:sesiso}，$k\le n$ 时 $\pi_k(f)$ 是同构，而对于 $k=n+1$，根据 \cref{thm:ses}\ref{item:sessurj} 它是满射。
\end{proof}

在 \cref{sec:whitehead} 中，我们将看到 \cref{thm:conn-pik} 的逆命题也是成立的。

\index{fiber sequence|)}%
\index{sequence!fiber|)}%

\section{霍普夫纤维丛 (The Hopf fibration)}
\label{sec:hopf}

在本节中，我们将定义\define{霍普夫纤维丛 (Hopf fibration)}。
\indexdef{霍普夫!纤维丛 (Hopf!fibration)}%

\begin{thm}[霍普夫纤维丛 (Hopf Fibration)]\label{thm:hopf-fibration}
存在一个在 $\Sn^2$ 上的纤维丛 $H$，其基点上的纤维是 $\Sn^1$，总空间是 $\Sn^3$。
\end{thm}

霍普夫纤维丛将使我们能够计算多个球面上的同伦群。
确实，它得出了以下的同伦群的长确界序列
\index{同伦!群!球面 (homotopy!group!of sphere)}
\index{确界序列 (sequence!exact)}
(参见 \cref{sec:long-exact-sequence-homotopy-groups})：
%
\[
  \xymatrix@R=1.2pc{
    \pi_k(\Sn^1) \ar[r] & \pi_k(\Sn^3) \ar[r] & \pi_k(\Sn^2) \ar[lld] \\
    \vdots & \vdots & \vdots \ar[lld] \\
    \pi_2(\Sn^1) \ar[r] & \pi_2(\Sn^3) \ar[r] & \pi_2(\Sn^2) \ar[lld] \\
    \pi_1(\Sn^1) \ar[r] & \pi_1(\Sn^3) \ar[r] & \pi_1(\Sn^2)}
\]
%
我们已经计算出了所有 $\pi_n(\Sn^1)$ 和 $\pi_k(\Sn^n)$，对于 $k<n$ 的情况，这就变成了以下的形式：
%
\[
  \xymatrix@R=1.2pc{
    0 \ar[r] & \pi_k(\Sn^3) \ar[r] & \pi_k(\Sn^2) \ar[lld] \\
    \vdots & \vdots & \vdots \ar[lld] \\
    0 \ar[r] & \pi_3(\Sn^3) \ar[r] & \pi_3(\Sn^2) \ar[lld] \\
    0 \ar[r] & 0 \ar[r] & \pi_2(\Sn^2) \ar[lld] \\
    \Z \ar[r] & 0 \ar[r] & 0}
\]
%
特别地，我们得到了以下结果：

\begin{cor} \label{cor:pis2-hopf}
我们有 $\eqv{\pi_2(\Sn^2)}{\Z}$ 和 $\eqv{\pi_k(\Sn^3)}{\pi_k(\Sn^2)}$ 对于每个 $k\ge3$ (其中该映射是由霍普夫纤维丛诱导的，从总空间 $\Sn^3$ 到基空间 $\Sn^2$)。
\end{cor}

事实上，我们可以说更多：霍普夫纤维丛的纤维序列将表明 $\Omega^3(\Sn^3)$ 是从 $\Omega^3(\Sn^2)$ 到 $\Omega^2(\Sn^1)$ 的映射的纤维。
由于 $\Omega^2(\Sn^1)$ 是可收缩的，我们有 $\eqv{\Omega^3(\Sn^3)}{\Omega^3(\Sn^2)}$。
在经典同伦论中，这一事实将是 \cref{cor:pis2-hopf} 和怀特海德定理的结果，但怀特海德定理在同伦类型论中不一定成立 (参见 \cref{sec:whitehead})。
不过，我们在此不会使用更精确的版本。

\subsection{推送中的纤维丛 (Fibrations over pushouts)}
\label{sec:fib-over-pushout}

我们首先从一个引理开始，解释如何构造推送中的纤维丛。
\index{推送 (pushout)}%

\begin{lem}\label{lem:fibration-over-pushout}
令 $\Ddiag=(Y\xleftarrow{j}X\xrightarrow{k}Z)$ 是一个跨图\index{跨图 (span)}，并假设我们有
\begin{itemize}
  \item 两个纤维丛 $E_Y:Y\to\type$ 和 $E_Z:Z\to\type$。
  \item 一个等价性 $e_X$，在 $E_Y\circ j:X\to\type$ 和 $E_Z\circ k:X\to\type$ 之间，即
  \[e_X:\prd{x:X}\eqv{E_Y(j(x))}{E_Z(k(x))}。\]
\end{itemize}

然后我们可以构造一个纤维丛 $E:Y\sqcup^XZ\to\type$ 使得
\begin{itemize}
  \item 对于所有 $y:Y$，$E(\inl(y))\judgeq E_Y(y)$。
  \item 对于所有 $z:Z$，$E(\inr(z))\judgeq E_Z(z)$。
  \item 对于所有 $x:X$，$\map E{\glue(x)}=\ua(e_X(x))$ (注意方程两边都是在 $\type$ 中从 $E_Y(j(x))$ 到 $E_Z(k(x))$ 的路径)。
\end{itemize}
此外，这个纤维丛的总空间符合以下推送方框：
\[\xymatrix{ \sm{x:X}E_Y(j(x)) \ar[r]_\sim^{\idfunc\times e_X}
  \ar[d]_{j\times\idfunc} &
  \sm{x:X}E_Z(k(x)) \ar[r]^-{k\times\idfunc}
  & \sm{z:Z}E_Z(z) \ar[d]^\inr \\
  \sm{y:Y}E_Y(y) \ar[rr]_\inl & & \sm{t:Y\sqcup^XZ}E(t) }\]
\end{lem}

\begin{proof}
  我们通过 $Y\sqcup^XZ$ 的推送递归原理来定义 $E$。为此，我们需要指定 $E$ 在 $\inl(y)$ 和 $\inr(z)$ 形式的元素上的值，以及 $E$ 在 $\glue(x)$ 路径上的作用，因此我们可以选择以下值：
  \begin{align*}
    E(\inl(y)) & \defeq E_Y(y)，\\
    E(\inr(z)) & \defeq E_Z(z)，\\
    \map E{\glue(x)} & \defid \ua(e_X(x))。
  \end{align*}
%
  为了看到该纤维丛的总空间是一个推送，我们应用展平引理 (\cref{thm:flattening})，使用以下值：\index{展平引理 (flattening lemma)}
  \begin{itemize}
    \item $A\defeq Y+Z$，$B\defeq X$，并且 $f,g:B\to A$ 通过 $f(x)\defeq\inl(j(x))$，$g(x)\defeq\inr(k(x))$ 来定义，
    \item 类型族 $C:A\to\type$ 定义为
    \begin{equation*}
      C(\inl(y)) \defeq E_Y(y)
      \qquad\text{和}\qquad
      C(\inr(z)) \defeq E_Z(z)，
    \end{equation*}
    \item 等价族 $D:\prd{b:B}C(f(b))\eqvsym C(g(b))$ 被定义为 $e_X$。
  \end{itemize}
%
  展平引理的基本高阶归纳类型 $W$ 与推送 $Y\sqcup^XZ$ 等价，类型族 $P:Y\sqcup^XZ\to\type$ 与上述定义的 $E$ 等价。

  因此，展平引理告诉我们 $\sm{t:Y\sqcup^XZ}E(t)$ 与具有以下生成器的高阶归纳类型 ${E^{\mathrm{tot}}}'$ 等价：
%
  \begin{itemize}
    \item 一个函数 $\mathsf{z}:\sm{a:Y+Z}C(a)\to {E^{\mathrm{tot}}}'$，
    \item 对于每个 $x:X$ 和 $t:E_Y(j(x))$，一个路径
    \narrowequation{\mathsf{z}(\inl(j(x)),t)=\mathsf{z}(\inr(k(x)),e_X(t))。}
  \end{itemize}
%
  再使用展平引理或直接计算，容易看出 $\eqv{\sm{a:Y+Z}C(a)}{\sm{y:Y}E_Y(y)+\sm{z:Z}E_Z(z)}$，因此 ${E^{\mathrm{tot}}}'$ 与具有以下生成器的高阶归纳类型 $E^{\mathrm{tot}}$ 等价：
%
  \begin{itemize}
    \item 一个函数 $\inl:\sm{y:Y}E_Y(y)\to E^{\mathrm{tot}}$，
    \item 一个函数 $\inr:\sm{z:Z}E_Z(z)\to E^{\mathrm{tot}}$，
    \item 对于每个 $(x,t):\sm{x:X}E_Y(j(x))$，一个路径
    \narrowequation{\glue(x,t):\inl(j(x),t) = \inr(k(x),e_X(t))。}
  \end{itemize}
%
  因此，$E$ 的总空间是 $E_Y$ 和 $E_Z$ 的总空间的推送，如所需。
\end{proof}

\subsection{霍普夫构造 (The Hopf construction)}

\begin{defn}
  \define{H-空间 (H-space)}
  \indexdef{H-空间 (H-space)}%
  包括
  \begin{itemize}
    \item 一个类型 $A$，
    \item 一个基点 $e:A$，
    \item 一个二元操作 $\mu:A\times A\to A$，以及
    \item 对于每个 $a:A$，等式 $\mu(e,a)=a$ 和 $\mu(a,e)=a$。
  \end{itemize}
\end{defn}

\begin{lem}
  设 $A$ 是一个连通的 H-空间。对于每个 $a:A$，映射 $\mu(a,\blank):A\to A$ 和 $\mu(\blank,a):A\to A$ 是等价的。
\end{lem}

\begin{proof}
  我们证明对于每个 $a:A$，映射 $\mu(a,\blank)$ 是等价的。另一个命题是对称的。
%
  声明 $\mu(a,\blank)$ 是等价的对应于一个类型族 $P:A\to\prop$，证明它对应于找到该类型族的一个截面。

  类型 $\prop$ 是一个集 (\cref{thm:hleveln-of-hlevelSn})，因此我们可以通过 $P'(\tproj0a)\defeq P(a)$ 定义一个新的类型族 $P':\trunc0A\to\prop$。但根据假设，$A$ 是连通的，因此 $\trunc0A$ 是可收缩的。这意味着为了找到 $P'$ 的一个截面，足以找到 $P'$ 在 $\tproj0e$ 处的纤维中的一个点。但我们有 $P'(\tproj0e)=P(e)$，它是居住的，因为根据 H-空间的定义，$\mu(e,\blank)$ 等于恒等映射，因此是等价的。

  我们已经证明，对于每个 $x:\trunc0A$，命题 $P'(x)$ 是正确的，因此特别地对于每个 $a:A$，命题 $P(a)$ 是正确的，因为 $P(a)$ 是 $P'(\tproj0a)$。
\end{proof}

\begin{defn}
  设 $A$ 是一个连通的 H-空间。我们使用 \cref{lem:fibration-over-pushout} 定义在 $\susp A$ 上的纤维丛。

  给定 $\susp A$ 是推送 $\unit\sqcup^A\unit$，我们可以通过指定
  \begin{itemize}
    \item 两个在 $\unit$ 上的纤维丛（即两个类型 $F_1$ 和 $F_2$），以及
    \item 一个等价族 $e:A\to(\eqv{F_1}{F_2})$，在 $F_1$ 和 $F_2$ 之间，对于 $A$ 的每个元素。
  \end{itemize}
%
  我们取 $A$ 作为 $F_1$ 和 $F_2$，并为每个 $a:A$ 取等价 $\mu(a,\blank)$ 为 $e(a)$。
\end{defn}

根据 \cref{lem:fibration-over-pushout}，我们有以下的图表：
%
\[\xymatrix{A \ar@{->>}[d] & A \times A \ar[l]_-{\proj2} \ar@{->>}_{\proj1}[d]
  \ar[r]^-{\mu} & A \ar@{->>}[d] \\
  1 & A \ar[r] \ar[l] & 1}\]
%
我们刚刚构建的纤维丛是一个在 $\susp A$ 上的纤维丛，其总空间是顶线上推送的结果。

此外，使用 $f(x,y)\defeq(\mu(x,y),y)$，我们有以下的图表：
%
\[\xymatrix{A \ar_\idfunc[d] & A \times A \ar[l]_-{\proj2} \ar^f[d]
  \ar[r]^-{\mu} & A \ar^\idfunc[d] \\
  A & A\times A \ar^-{\proj2}[l] \ar_-{\proj1}[r] & A}\]
%
该图表是可交换的，三个垂直映射都是等价的，$f$ 的逆映射是由
\[g(u,v)\defeq(\opp{\mu(\blank,v)}(u),v)\]
定义的。
%
这表明两个线条是等价（因此是相等）的跨图，因此我们构造的纤维丛的总空间等价于底线推送的结果。
根据定义，后者的推送是 $A$ 与自身的\emph{连接 (join)}（参见 \cref{sec:colimits}）。
%
我们已经证明了：

\begin{lem}\label{lem:hopf-construction}
给定一个连通的 H-空间 $A$，存在一个纤维丛，称为\define{霍普夫构造 (Hopf construction)}，
\indexdef{霍普夫!构造 (Hopf!construction)}%
在 $\susp A$ 上，其纤维是 $A$，总空间是 $A*A$。
\end{lem}

\subsection{霍普夫纤维丛 (The Hopf fibration)}

\index{霍普夫纤维丛|(Hopf fibration|(}
\indexsee{纤维丛!霍普夫 (fibration!Hopf)}{霍普夫纤维丛 (Hopf fibration)}
我们首先将在 $\Sn^1$ 圆周上构造一个 H-空间的结构，因此根据 \cref{lem:hopf-construction}，我们将获得一个在 $\Sn^2$ 上的纤维丛，其纤维是 $\Sn^1$，总空间是 $\Sn^1*\Sn^1$。然后我们将证明这个连接等价于 $\Sn^3$。

\begin{lem}\label{lem:hspace-S1}
在 $\Sn^1$ 圆周上存在一个 H-空间结构。
\end{lem}
\begin{proof}
  对于 H-空间结构的基点，我们选择 $\base$。
%
  现在我们需要定义乘法操作 $\mu:\Sn^1\times\Sn^1\to\Sn^1$。
  我们将通过 $\Sn^1$ 的递归定义乘法的柯里化形式 $\widetilde\mu:\Sn^1\to(\Sn^1\to\Sn^1)$：
  \begin{equation*}
    \widetilde\mu(\base) \defeq\idfunc[\Sn^1]，
    \qquad\text{和}\qquad
    \ap{\widetilde\mu}{\lloop} \defid\funext(h)。
  \end{equation*}
  其中 $h:\prd{x:\Sn^1}(x=x)$ 是在 \cref{thm:S1-autohtpy} 中定义的函数，
  其性质是 $h(\base) \defeq\lloop$。

  现在我们只需要证明 $\mu(x,\base)=\mu(\base,x)=x$ 对于每个 $x:\Sn^1$。
%
  根据定义，如果 $x:\Sn^1$，我们有 $\mu(\base,x)=\widetilde\mu(\base)(x)=\idfunc[\Sn^1](x)=x$。对于等式 $\mu(x,\base)=x$，我们通过在 $x:\Sn^1$ 上的归纳法来进行：
  \begin{itemize}
    \item 如果 $x$ 是 $\base$，那么根据定义，$\mu(\base,\base)=\base$，所以我们有 $\refl\base:\mu(\base,\base)=\base$。
    \item 当 $x$ 随着 $\lloop$ 变化时，我们需要证明
    \[\refl\base\ct\apfunc{\lam{x}x}({\lloop})=
    \apfunc{\lam{x}\mu(x,\base)}({\lloop})\ct\refl\base。\]
    左边等于 $\lloop$，对于右边，我们有：
    \begin{align*}
      \apfunc{\lam{x}\mu(x,\base)}({\lloop})\ct\refl\base &=
      \apfunc{\lam{x}(\widetilde\mu(x))(\base)}({\lloop})\\
      &=\happly(\apfunc{\lam{x}(\widetilde\mu(x))}({\lloop}),\base)\\
      &=\happly(\funext(h),\base)\\
      &=h(\base)\\
      &=\lloop。 \qedhere
    \end{align*}
  \end{itemize}
\end{proof}

现在回想 \cref{sec:colimits}，类型 $A$ 和 $B$ 的\emph{连接 (join)} $A*B$ 是以下图表的推送：
\index{连接!类型 (join!of types)}%
\[A \xleftarrow{\proj1}A\times B \xrightarrow{\proj2} B.\]

\begin{lem}
  \index{连接的结合律 (associativity!of join)}%
  连接操作是结合的：如果 $A$、$B$ 和 $C$ 是三个类型，那么我们有一个等价 $\eqv{(A*B)*C}{A*(B*C)}$。
\end{lem}

\begin{proof}
  我们通过归纳定义一个映射 $f:(A*B)*C\to A*(B*C)$。首先需要通过归纳法定义 $f\circ\inl:A*B\to A*(B*C)$，然后定义 $f\circ\inr:C\to A*(B*C)$，最后定义 $\apfunc{f}\circ\glue:\prd{t:(A*B)\times C}f(\inl(\fst(t)))=f(\inr(\snd(t)))$，这将通过对 $t$ 的第一个分量进行归纳来完成：
  \begin{align*}
  (f\circ\inl)(\inl(a)) &\defeq \inl(a)， \\
  (f\circ\inl)(\inr(b)) &\defeq \inr(\inl(b))， \\
  \apfunc{f\circ\inl}(\glue(a,b)) &\defid \glue(a,\inl(b))， \\
  f(\inr(c)) &\defeq \inr(\inr(c))，\\
  \apfunc{f}(\glue(\inl(a),c)) &\defid \glue(a,\inr(c))，\\
  \apfunc{f}(\glue(\inr(b),c)) &\defid \apfunc{\inr}(\glue(b,c))，\\
  \apdfunc{\lam{x}\apfunc{f}(\glue(x,c))}(\glue(a,b)) &\defid
  ``\apdfunc{\lam{x}\glue(a,x)}(\glue(b,c))''。
  \end{align*}
%
  对于最后一个等式，注意右边的类型是
  \[\transfib{\lam{x}\inl(a)=\inr(x)}{\glue(b,c)}{\glue(a,\inl(b))}=
  \glue(a,\inr(c))，\]
  而它应该是
%
  \begin{narrowmultline*}
    \transfib{\lam{x}f(\inl(x))=f(\inr(c))}{\glue(a,b)}{\apfunc{f}(\glue(\inl(a),c))}
    = \narrowbreak
    \apfunc{f}(\glue(\inr(b),c)) 的类型。
  \end{narrowmultline*}
%
  但是根据定义中的前述条款，这两种类型都等价于以下类型：
  \[\glue(a,\inr(c))=\glue(a,\inl(b))\ct\apfunc\inr(\glue(b,c))，\]
  所以我们可以通过等价来进行强制转换以获得必要的元素。
%
  类似地，我们可以定义一个映射 $g:A*(B*C)\to (A*B)*C$，并检查 $f$ 和 $g$ 是相互逆的，这是一个漫长而乏味但本质上直截了当的计算。
\end{proof}

一种更概念化的证明大纲如下。

\begin{proof}
  让我们考虑以下图表，其中映射是显然的投影：
  \[\xymatrix{
    A & A\times C \ar[l] \ar[r] & A\times C\\
    A\times B \ar[u] \ar[d] & A\times B\times C \ar[l]\ar[u]\ar[r]\ar[d] &
    A\times C \ar[u] \ar[d] \\
    B & B\times C \ar[l] \ar[r] & C}\]
%
  取列的极限（colimit）得到以下图表，其极限是 $(A*B)*C$：
  \[\xymatrix{A*B & (A*B)\times C \ar[l]\ar[r] & C}\]
%
  另一方面，取行的极限得到一个图表，其极限是 $A*(B*C)$。

  因此，使用我们尚未证明的极限的 Fubini 类似定理（Fubini-like theorem for colimits），我们有 $\eqv{(A*B)*C}{A*(B*C)}$ 的等价性。尽管如此，这个 Fubini 定理的证明仍然需要漫长而乏味的计算。
\end{proof}

\begin{lem}
  对于任意类型 $A$，存在一个等价 $\eqv{\susp A}{\bool*A}$。
\end{lem}

\begin{proof}
  定义两个映射来回并证明它们是相互逆的很容易。具体细节留作读者练习。
\end{proof}

我们现在可以构造霍普夫纤维丛：

\begin{thm}
  存在一个在 $\Sn^2$ 上的纤维丛，其纤维为 $\Sn^1$，总空间为 $\Sn^3$。
  \index{总空间 (total!space)}%
\end{thm}
\begin{proof}
  我们证明了 $\Sn^1$ 具有 H-空间的结构（参见 \cref{lem:hspace-S1}），因此根据 \cref{lem:hopf-construction}，存在一个在 $\Sn^2$ 上的纤维丛，其纤维是 $\Sn^1$，总空间是 $\Sn^1*\Sn^1$。但根据前两个结果和 \cref{thm:suspbool}，我们有：
  \begin{equation*}
    \Sn^1*\Sn^1 = (\susp\bool)*\Sn^1
    =(\bool*\bool)*\Sn^1
    =\bool*(\bool*\Sn^1)
    =\susp(\susp\Sn^1)
    =\Sn^3。 \qedhere
  \end{equation*}
\end{proof}
\index{霍普夫纤维丛 (Hopf fibration)|)}

\section{Freudenthal 悬吊定理 (The Freudenthal Suspension Theorem)}
\label{sec:freudenthal}

\index{Freudenthal 悬吊定理 (Freudenthal suspension theorem)|(}%
\index{定理!Freudenthal 悬吊 (theorem!Freudenthal suspension)|(}%

在证明 Freudenthal 悬吊定理之前，我们需要一些关于连通性 (connectedness) 的辅助引理。在 \cref{cha:hlevels} 中，我们证明了一些关于固定 $n$ 的 $n$-连通映射 ($n$-connected maps) 和 $n$-类型 ($n$-types) 的事实；现在我们感兴趣的是，当我们改变 $n$ 时会发生什么。例如，在 \cref{prop:nconnected_tested_by_lv_n_dependent types} 中，我们展示了 $n$-连通映射可以通过相对于 $n$-类型的族 (families of $n$-types) 的“归纳原理” (induction principle) 来表征。如果我们想要沿着一个 $n$-连通映射对 $k$-类型的族进行“归纳” (induct)，其中 $k > n$，我们不能立即知道是否有一个由这种归纳原理产生的函数，但以下引理表明至少可以量化我们的无知。

\begin{lem}\label{thm:conn-trunc-variable-ind}
如果 $f:A\to B$ 是 $n$-连通映射，并且 $P:B\to \ntype{k}$ 是一个 $k$-类型的族，其中 $k\ge n$，那么诱导的函数
\[ (\blank\circ f) : \Parens{\prd{b:B} P(b)} \to \Parens{\prd{a:A} P(f(a)) } \]
是 $(k-n-2)$-截断 (truncated) 的。
\end{lem}

\begin{proof}
  我们对自然数 $k-n$ 进行归纳。当 $k=n$ 时，这就是 \cref{prop:nconnected_tested_by_lv_n_dependent types}。
  %
  对于归纳步骤，假设 $f$ 是 $n$-连通的，并且 $P$ 是一个 $(k+1)$-类型的族。为了证明 $(\blank\circ f)$ 是 $(k-n-1)$-截断的，设 $\ell:\prd{a:A} P(f(a))$；那么我们有
  \[ \hfib{(\blank\circ f)}{\ell} \eqvsym \sm{g:\prd{b:B} P(b)} \prd{a:A} g(f(a)) = \ell(a)。\]
  令 $(g,p)$ 和 $(h,q)$ 位于此类型中，因此 $p:g\circ f \htpy \ell$ 并且 $q:h\circ f \htpy \ell$；然后我们也有
  \[ \big((g,p) = (h,q)\big) \eqvsym
  \Parens{\sm{r:g\htpy h} r\circ f = p \ct \opp{q}}。
  \]
  然而，这里的右侧是映射的一个纤维
  \[ (\blank\circ f) : \Parens{\prd{b:B} Q(b)} \to \Parens{\prd{a:A} Q(f(a)) } \]
  其中 $Q(b) \defeq (g(b)=h(b))$。
  由于 $P$ 是一个 $(k+1)$-类型的族，$Q$ 是一个 $k$-类型的族，因此归纳假设表明这个纤维是一个 $(k-n-2)$-类型。因此，$\hfib{(\blank\circ f)}{\ell}$ 的所有路径空间都是 $(k-n-2)$-类型，因此它是 $(k-n-1)$-类型的。
\end{proof}

回想一下，如果 $\pairr{A,a_0}$ 和 $\pairr{B,b_0}$ 是有基点的类型 (pointed types)，那么它们的\define{楔和 (wedge)}
\index{wedge}%
$A\vee B$ 被定义为 $A\xleftarrow{a_0} \unit\xrightarrow{b_0} B$ 的推挤 (pushout)。有一个规范映射 $i:A\vee B \to A\times B$，由两个映射 $\lam{a} (a,b_0)$ 和 $\lam{b} (a_0,b)$ 定义；以下引理本质上说明，如果 $A$ 和 $B$ 是高度连通的，则这个映射也是如此。然而，如果我们使用 \cref{prop:nconnected_tested_by_lv_n_dependent types} 中的连通性表征，并在推挤的通用性质中进行替换，那么证明和使用起来会更方便。

\begin{lem}[楔和连通性引理 (Wedge connectivity lemma)]\label{thm:wedge-connectivity}
假设 $\pairr{A,a_0}$ 和 $\pairr{B,b_0}$ 分别是 $n$-和 $m$-连通的有基点类型，且 $n,m\geq0$，并令
%
\narrowequation{P:A\to B\to \ntype{(n+m)}.}
%
那么对于任何 ${f:\prd{a:A} P(a,b_0)}$ 和 ${g:\prd{b:B} P(a_0,b)}$，其中 $p:f(a_0) = g(b_0)$，存在 $h:\prd{a:A}{b:B} P(a,b)$，并且存在同伦 (homotopies)
%
\begin{equation*}
  q:\prd{a:A} h(a,b_0)=f(a)
  \qquad\text{和}\qquad
  r:\prd{b:B} h(a_0,b)=g(b)
\end{equation*}
%
使得 $p = \opp{q(a_0)} \ct r(b_0)$。
\end{lem}

\begin{proof}
  定义 $Q:A\to\type$ 为
  \[ Q(a) \defeq \sm{k:\prd{b:B} P(a,b)} (f(a) = k(b_0))。\]
  然后我们有 $(g,p):Q(a_0)$。
  由于 $a_0:\unit\to A$ 是 $(n-1)$-连通的，如果 $Q$ 是一个 $(n-1)$-类型的族，那么我们将有 $\ell:\prd{a:A} Q(a)$，使得 $\ell(a_0) = (g,p)$，在这种情况下，我们可以定义 $h(a,b) \defeq \proj1(\ell(a))(b)$。
  然而，对于固定的 $a$，类型 $Q(a)$ 是 $f(a)$ 的纤维，映射为
  \[ \Parens{\prd{b:B} P(a,b) } \to P(a,b_0) \]
  由 $b_0:\unit\to B$ 的预组合给出。
  由于 $b_0:\unit\to B$ 是 $(m-1)$-连通的，要使这个纤维成为 $(n-1)$-截断的，根据 \cref{thm:conn-trunc-variable-ind}，只要每个类型 $P(a,b)$ 是 $(n+m)$-类型，这个条件就足够了。
\end{proof}

令 $(X,x_0)$ 为有基点类型，并回忆 \cref{sec:suspension} 中悬吊 (suspension) $\susp X$ 的定义，具有构造子 $\north,\south:\susp X$ 和 $\merid:X \to (\north=\south)$。
我们将 $\susp X$ 视为有基点空间，基点为 $\north$，因此我们有 $\Omega\susp X \defeq (\id[\susp X]\north\north)$。
然后有一个规范映射
\begin{align*}
  \sigma &: X \to \Omega\susp X\\
  \sigma(x) &\defeq \merid(x) \ct \opp{\merid(x_0)}。
\end{align*}

\begin{rmk}
  在经典的代数拓扑中，考虑的是\emph{约化悬吊 (reduced suspension)}，其中路径 $\merid(x_0)$ 被折叠为一个点，将 $\north$ 和 $\south$ 识别为一个点。约化和未约化的悬吊是同伦等价的，因此这个区别对我们纯粹的同伦论 (homotopy-theoretic) 眼光来说是不可见的——而高阶归纳类型只允许我们“识别”点到更高的路径上，无论如何，在同伦类型论中考虑约化悬吊没有意义。然而，我们的悬吊的“未约化性”是 $\sigma$ 的定义中出现 $\opp{\merid(x_0)}$（可能出乎意料）的原因。
\end{rmk}

我们的目标现在是证明以下定理。

\begin{thm}[Freudenthal 悬吊定理 (The Freudenthal Suspension Theorem)]\label{thm:freudenthal}
假设 $X$ 是 $n$-连通且有基点的，并且 $n\geq 0$。那么映射 $\sigma:X\to \Omega\susp(X)$ 是 $2n$-连通的。
\end{thm}

\index{编码-解码方法 (encode-decode method)|(}%

我们将使用编码-解码方法 (encode-decode method)，但会以稍微不同的方式应用它。到目前为止，在大多数情况下，我们使用它来将某些类型 $A$ 的回路空间 (loop space) $\Omega (A,a_0)$ 表征为某个其他类型 $B$，通过构造一个族 $\code:A\to \type$，其中 $\code(a_0)\defeq B$ 并且构造一个等价族 $\decode:\prd{x:A}\code(x) \eqvsym (a_0=x)$。
% 我们还通过一个等价族 $\prd{x:A}\code(x) \eqvsym \trunc n{a_0=x}$ 将其推广以表征回路空间的截断。

然而，在这种情况下，我们想要证明 $\sigma:X\to \Omega \susp X$ 是 $2n$-连通的。我们可以使用前述方法的截断版本，例如我们将在 \cref{sec:van-kampen} 中看到，来证明 $\trunc{2n}X\to \trunc{2n}{\Omega \susp X}$ 是一个等价——但这是一个稍微弱一点的声明，不能说明映射是 $2n$-连通的 (见 \cref{thm:conn-pik,thm:pik-conn})。然而，注意在一般情况下，为了证明 $\decode(x)$ 是一个等价，可以等效地证明它的纤维是收缩的 (contractible)，我们仍然可以对基类型进行归纳。这一点我们可以推广到证明进入回路空间的映射的连通性，即它的纤维的\emph{截断}是收缩的。此外，我们可以直接构造\emph{纤维的截断的编码 (codes for the truncations of the fibers)}的族，而不是分别构造 $\code$ 和 $\decode$。

\begin{defn}\label{thm:freudcode}
如果 $X$ 是 $n$-连通且有基点的，且 $n\geq 0$，那么存在一个族
\begin{equation}
  \code:\prd{y:\susp X} (\north=y) \to \type\label{eq:freudcode}
\end{equation}
使得
\begin{align}
  \code(\north,p) &\defeq \trunc{2n}{\hfib{\sigma}{p}}
  \jdeq \trunc{2n}{\tsm{x:X} (\merid(x) \ct \opp{\merid(x_0)} = p)}\label{eq:freudcodeN}\\
  \code(\south,q) &\defeq \trunc{2n}{\hfib{\merid}{q}}
  \jdeq \trunc{2n}{\tsm{x:X} (\merid(x) = q)}。\label{eq:freudcodeS}
\end{align}
\end{defn}

我们的最终目标是证明对于所有 $y:\susp X$ 和 $p:\north=y$，$\code(y,p)$ 是收缩的。将此应用于 $y\defeq \north$，将表明 $\sigma$ 的所有纤维都是 $2n$-连通的，从而 $\sigma$ 是 $2n$-连通的。

\begin{proof}[证明 \cref{thm:freudcode}]
  我们通过对 $y:\susp X$ 进行归纳来定义 $\code(y,p)$，其中前两个情况是~\eqref{eq:freudcodeN} 和~\eqref{eq:freudcodeS}。还需要构造，对于每个 $x_1:X$，一个依赖路径 (dependent path)
  \[ \dpath{\lam{y}(\north=y)\to\type}{\merid(x_1)}{\code(\north)}{\code(\south)}。 \]
  根据 \cref{thm:dpath-arrow}，这等价于给出一个路径族
  \[ \prd{q:\north=\south} \code(\north)(\transfib{\lam{y}(\north=y)}{\opp{\merid(x_1)}}{q}) = \code(\south)(q)。 \]
  并且根据可泛性和路径类型中的传输 (transport in path types)，这等价于一个等价族
  \[ \prd{q:\north=\south} \code(\north,q \ct \opp{\merid(x_1)}) \eqvsym \code(\south,q)。 \]
  我们将定义一个映射族
  \begin{equation}\label{eq:freudmap}
  \prd{q:\north=\south} \code(\north,q \ct \opp{\merid(x_1)}) \to \code(\south,q)。
  \end{equation}
  然后证明它们都是等价的。
  因此，令 $q:\north=\south$；根据截断的通用性质以及 $\code(\north,\blank)$ 和 $\code(\south,\blank)$ 的定义，对于每个 $x_2:X$，定义一个映射
  \begin{equation*}
    \big(\merid(x_2)\ct \opp{\merid(x_0)} = q \ct \opp{\merid(x_1)}\big)
    \to \trunc{2n}{\tsm{x:X} (\merid(x) = q)}。
  \end{equation*}
  现在对于每个 $x_1,x_2:X$，这个类型是 $2n$-截断的，而 $X$ 是 $n$-连通的。因此，根据 \cref{thm:wedge-connectivity}，只需要在 $x_1$ 为 $x_0$，$x_2$ 为 $x_0$ 时定义这个映射，并检查它们在 $x_0$ 时是否一致。

  当 $x_1$ 为 $x_0$ 时，假设 $r:\merid(x_2)\ct \opp{\merid(x_0)} = q \ct \opp{\merid(x_0)}$。因此，通过从 $r$ 中消去 $\opp{\merid(x_0)}$ 得到 $r':\merid(x_2)=q$，所以我们可以将图像定义为 $\tproj{2n}{(x_2,r')}。

  当 $x_2$ 为 $x_0$ 时，假设 $r:\merid(x_0)\ct \opp{\merid(x_0)} = q \ct \opp{\merid(x_1)}$。重新排列此路径，我们得到 $r'':\merid(x_1)=q$，我们可以将图像定义为 $\tproj{2n}{(x_1,r'')}。

  最后，当 $x_1$ 和 $x_2$ 都是 $x_0$ 时，足以证明得到的 $r'$ 和 $r''$ 一致；这可以通过一个关于路径组合的简单引理来证明。这完成了~\eqref{eq:freudmap} 的定义。要证明它是一个等价族，由于等价是一个纯粹命题，并且 $x_0:\unit\to X$ 是（至少）$(-1)$-连通的，所以我们可以假设 $x_1$ 是 $x_0$。在这种情况下，通过检查上面的构造，我们可以看到它本质上是消去 $\opp{\merid(x_0)}$ 的函数的 $2n$-截断，这是一个等价。
\end{proof}

除了~\eqref{eq:freudcodeN} 和~\eqref{eq:freudcodeS}，我们还需要从 $\code$ 的构造中提取出一些关于它如何作用于路径的信息。为此，我们使用以下引理。

\begin{lem}\label{thm:freudlemma}
令 $A:\UU$, $B:A\to \UU$, $C:\prd{a:A} B(a)\to\UU$，并且 $a_1,a_2:A$，假设 $m:a_1=a_2$ 并且 $b:B(a_2)$。那么函数
\[\transfib{\widehat{C}}{\pairpath(m,t)}{\blank} : C(a_1,\transfib{B}{\opp m}{b}) \to C(a_2,b),\]
其中 $t:\transfib{B}{m}{\transfib{B}{\opp m}{b}} = b$ 是显然的一致性路径，并且 $\widehat{C}:(\sm{a:A} B(a)) \to\type$ 是 $C$ 的非柯里化 (uncurried) 形式，它等价于从复合中通过可泛性获得的等价：
\begin{align}
  C(a_1,\transfib{B}{\opp m}{b})
  &= \transfib{\lam{a} B(a)\to \UU}{m}{C(a_1)}(b)
  \tag{by~\eqref{eq:transport-arrow}}\\
  &= C(a_2,b)。 \tag{by $\happly(\apd{C}{m},b)$}
\end{align}
\end{lem}

\begin{proof}
  通过路径归纳，我们可以假设 $a_2$ 是 $a_1$ 并且 $m$ 是 $\refl{a_1}$，在这种情况下两个函数都是恒等函数。
\end{proof}

我们应用这个引理，其中 $A\defeq\susp X$，$B\defeq \lam{y}(\north=y)$，$C\defeq\code$，$a_1\defeq\north$，$a_2\defeq\south$，$m\defeq \merid(x_1)$，其中 $x_1:X$，最后 $b\defeq q$ 是路径 $\north=\south$。
悬吊 $X$ 的归纳计算规则将 $\apd{C}{m}$ 识别为通过可泛性和函数外延性 (function extensionality) 的应用构造出的路径。由 \cref{thm:freudlemma} 所述的第二个函数本质上包括撤销这些可泛性和函数外延性的应用，减少回我们用 \cref{thm:wedge-connectivity} 定义的特定函数~\eqref{eq:freudmap}。因此，\cref{thm:freudlemma} 说明沿着 $\pairpath(q,t)$ 进行传输 (transport) 本质上恢复了这些函数。

最后，通过构造，当 $x_1$ 或 $x_2$ 与 $x_0$ 重合并且输入位于 $\tproj{2n}{\blank}$ 的图像中时，我们可以更明确地知道这些函数是什么。因此，对于任意 $x_2:X$，我们有
\begin{equation}
  \transfib{\hat{\code}}{\pairpath(\merid(x_0),t)}{\tproj{2n}{(x_2,r)}}
  =\tproj{2n}{(x_1,r')}。\label{eq:freudcompute1}
\end{equation}
其中 $r:\merid(x_2) \ct \opp{\merid(x_0)} = \transfib{B}{\opp{\merid(x_0)}}{q}$ 是任意的，$r':\merid(x_2)=q$ 通过将它的终点与 $q \ct \opp{\merid(x_0)}$ 识别并消去 $\opp{\merid(x_0)}$ 得到。同样，对于任意 $x_1:X$，我们有
\begin{equation}
  \transfib{\hat{\code}}{\pairpath(\merid(x_1),t)}{\tproj{2n}{(x_0,r)}}
  = \tproj{2n}{(x_1,r'')}。\label{eq:freudcompute2}
\end{equation}
其中 $r:\merid(x_0) \ct \opp{\merid(x_0)} = \transfib{B}{\opp{\merid(x_1)}}{q}$，并且 $r'':\merid(x_1)=q$ 是通过识别它的终点和重排路径得到的。

\begin{proof}[证明 \cref{thm:freudenthal}]
  现在我们需要证明对于每个 $y:\susp X$ 和 $p:\north=y$，$\code(y,p)$ 是收缩的。首先我们必须选择一个收缩中心，设 $c(y,p):\code(y,p)$。这对应于在我们之前的证明中定义 $\encode$ 函数，因此我们通过传输来定义它。注意在特殊情况下，当 $y$ 是 $\north$ 且 $p$ 是 $\refl{\north}$ 时，我们有
  \[\code(\north,\refl{\north}) \jdeq \trunc{2n}{\tsm{x:X} (\merid(x) \ct \opp{\merid(x_0)} = \refl{\north})}。\]
  因此，我们可以选择 $c(\north,\refl{\north})\defeq \tproj{2n}{(x_0,\mathsf{rinv}_{\merid(x_0)})}$，其中 $\mathrm{rinv}_q$ 是一个显然的路径 $q\ct\opp q = \refl{}$ 对于任何 $q$。我们现在可以通过对 $p$ 进行路径归纳得到 $c:\prd{y:\susp X}{p:\north=y} \code(y,p)$，但下面很重要的是我们还可以通过传输给出一个具体的定义：
  \[ c(y,p) \defeq \transfib{\hat{\code}}{\pairpath(p,\mathsf{tid}_p)}{c(\north,\refl{\north})}
  \]
  其中 $\hat{\code}: \big(\sm{y:\susp X} (\north=y)\big) \to \type$ 是 $\code$ 的非柯里化形式，并且 $\mathsf{tid}_p:\trans{p}{\refl{}} = p$ 是一个标准引理。

  接下来，我们必须证明 $\code(y,p)$ 的每个元素都等于 $c(y,p)$。同样，通过路径归纳，我们可以假设 $y$ 是 $\north$ 并且 $p$ 是 $\refl{\north}$。事实上，我们将更普遍地证明当 $y$ 是 $\north$ 并且 $p$ 是任意时。也就是说，我们将证明对于任何 $p:\north=\north$ 和 $d:\code(\north,p)$，我们有 $d = c(\north,p)$。由于这个等式是一个 $(2n-1)$-类型，我们可以假设 $d$ 的形式为 $\tproj{2n}{(x_1,r)}$，其中 $x_1:X$ 并且 $r:\merid(x_1) \ct \opp{\merid(x_0)} = p$。

  现在通过进一步的路径归纳，我们可以假设 $r$ 是反身性，并且 $p$ 是 $\merid(x_1) \ct \opp{\merid(x_0)}$。这就是为什么我们将其推广到任意 $p$ 的原因。因此，我们必须证明
  \begin{equation}
    \tproj{2n}{(x_1, \refl{\merid(x_1) \ct \opp{\merid(x_0)}})}
    \;=\;
    c\left(\north,\refl{\merid(x_1) \ct \opp{\merid(x_0)}}\right)。\label{eq:freudgoal}
  \end{equation}
  根据定义，这个等式的右侧是
  \begin{multline*}
    \Transfib{\hat{\code}}{\pairpath(\merid(x_1) \ct \opp{\merid(x_0)}, \nameless)}{\tproj{2n}{(x_0,\nameless)}} \\
    = \transfibf{\hat{\code}}
    \begin{aligned}[t]
      \Big(
      &{\pairpath(\opp{\merid(x_0)}, \nameless)},\\
      &{\Transfib{\hat{\code}}{\pairpath(\merid(x_1), \nameless)}{\tproj{2n}{(x_0,\nameless)}}}
      \Big)
    \end{aligned}
    \\
    = \Transfib{\hat{\code}}{\pairpath(\opp{\merid(x_0)}, \nameless)}{\tproj{2n}{(x_1,\nameless)}}
    = \tproj{2n}{(x_1,\nameless)}
  \end{multline*}
  其中下划线 $\nameless$ 应该用合适的一致性路径填充。这里的第一步是传输的函子性，第二步调用了~\eqref{eq:freudcompute2}，第三步调用了~\eqref{eq:freudcompute1}（并将传输移至另一侧）。因此我们具有~\eqref{eq:freudgoal} 左侧相同的第一分量。我们留给读者验证所有的一致性路径都会消去，给出第二分量中的反身性。
\end{proof}

% 作为推论，我们有以下等价。

\begin{cor}[Freudenthal 等价 (Freudenthal Equivalence)] \label{cor:freudenthal-equiv}
假设 $X$ 是 $n$-连通且有基点的，并且 $n\geq 0$。那么 $\eqv{\trunc{2n}{X}}{\trunc{2n}{\Omega\susp(X)}}$。
\end{cor}

\begin{proof}
  根据 \cref{thm:freudenthal}，$\sigma$ 是 $2n$-连通的。根据 \cref{lem:connected-map-equiv-truncation}，因此它在 $2n$-截断上是一个等价。
\end{proof}

\index{编码-解码方法|)}%

\index{Freudenthal 悬吊定理|)}%
\index{定理!Freudenthal 悬吊|)}%

\index{同伦!球面 (homotopy!group!of sphere)}%
\index{稳定性!球面同伦群的稳定性 (stability!of homotopy groups of spheres)}%
\index{类型!n-球面 (type!n-sphere@$n$-sphere)}%
Freudenthal 悬吊定理的一个重要推论是球面 (sphere) 的同伦群 (homotopy group) 在某个范围内是稳定的（这些是 \cref{tab:homotopy-groups-of-spheres} 中从东北到西南的对角线）：

\begin{cor}[球面稳定性 (Stability for Spheres)] \label{cor:stability-spheres}
如果 $k \le 2n-2$，则 $\pi_{k+1}(S^{n+1}) = \pi_{k}(S^{n})$。
\end{cor}

\begin{proof}
  假设 $k \le 2n-2$。
%
  根据 \cref{cor:sn-connected}，$\Sn ^{n}$ 是 $\nminusone$-连通的。因此，根据 \cref{cor:freudenthal-equiv}，
  \[
    \trunc{2(n-1)}{\Omega(\susp(\Sn^{n}))} = \trunc{2(n-1)}{\Sn^{n}}。
  \]
  根据 \cref{lem:truncation-le}，由于 $k \le 2(n-1)$，对两边应用 $\trunc{k}{\blank}$ 显示这个等式对 $k$ 成立：
  \begin{equation}\label{eq:freudenthal-for-spheres}
  \trunc{k}{\Omega(\susp(\Sn^{n}))} = \trunc{k}{\Sn^{n}}。
  \end{equation}
%
  那么，证明的主要思路如下；我们省略了这些等价对这些空间的基点的作用检查，并且对于 $k > 0$，等价尊重乘法：
%
  \begin{align*}
    \pi_{k+1}(\Sn^{n+1}) &\jdeq \trunc{0}{\Omega^{k+1}(\Sn^{n+1})} \\
    &\jdeq \trunc{0}{\Omega^k(\Omega(\Sn^{n+1}))} \\
    &\jdeq \trunc{0}{\Omega^k(\Omega(\susp(\Sn^{n})))} \\
    &= \Omega^k(\trunc{k}{(\Omega(\susp(\Sn^{n})))})
    \tag{by \cref{thm:path-truncation}}\\
    &= \Omega^k(\trunc{k}{\Sn^{n}})
    \tag{by \eqref{eq:freudenthal-for-spheres}}\\
    &= \trunc{0}{\Omega^k(\Sn^{n})}
    \tag{by \cref{thm:path-truncation}}\\
    &\jdeq \pi_k(\Sn^{n})。 \qedhere
  \end{align*}
%
\end{proof}

这意味着一旦我们计算出这些稳定对角线中的一个条目，我们就知道它们的全部。例如：

\begin{thm}\label{thm:pinsn}
对于每个 $n\geq 1$，$\pi_n(\Sn^n)=\Z$。
\end{thm}

\begin{proof}
  证明是对 $n$ 的归纳。我们已经有 $\pi_1(\Sn ^1) = \Z$ (\cref{cor:pi1s1}) 和 $\pi_2(\Sn ^2) = \Z$ (\cref{cor:pis2-hopf})。
  当 $n \ge 2$ 时，$n \le (2n - 2)$。因此，根据 \cref{cor:stability-spheres}，$\pi_{n+1}(S^{n+1}) = \pi_{n}(S^{n})$，并且这个等价结合归纳假设，给出了结果。
\end{proof}

\begin{cor}
  对于任何 $n\ge -1$，$\Sn^{n+1}$ 不是 $n$-类型。
\end{cor}

\begin{cor}\label{thm:pi3s2}
$\pi_3(\Sn^2)=\Z$。
\end{cor}
\begin{proof}
  根据 \cref{cor:pis2-hopf}，$\pi_3(\Sn^2) = \pi_3(\Sn^3)$。
  但根据 \cref{thm:pinsn}，$\pi_3(\Sn^3) = \Z$。
\end{proof}

\section{The van Kampen theorem}
\label{sec:van-kampen}

\index{van Kampen theorem|(}%
\index{theorem!van Kampen|(}%

\index{fundamental!group}%
The van Kampen theorem calculates the fundamental group $\pi_1$ of a (homotopy) pushout of spaces.
It is traditionally stated for a topological space $X$ which is the union of two open subspaces $U$ and $V$, but in homotopy-theoretic terms this is just a convenient way of ensuring that $X$ is the pushout of $U$ and $V$ over their intersection.
Thus, we will prove a version of the van Kampen theorem for arbitrary pushouts.

In this section we will describe a proof of the van Kampen theorem which uses the same encode-decode method that we used for $\pi_1(\Sn^1)$ in \cref{sec:pi1-s1-intro}.
There is also a more homotopy-theoretic approach; see \cref{ex:rezk-vankampen}.

We need a more refined version of the encode-decode method.
In \cref{sec:pi1-s1-intro} (as well as in \cref{sec:compute-coprod,sec:compute-nat}) we used it to characterize the path space of a (higher) inductive type $W$ --- deriving as a consequence a characterization of the loop space $\Omega(W)$, and thereby also of its 0-truncation $\pi_1(W)$.
In the van Kampen theorem, our goal is only to characterize the fundamental group $\pi_1(W)$, and we do not have any explicit description of the loop spaces or the path spaces to use.

It turns out that we can use the same technique directly for a truncated version of the path fibration, thereby characterizing not only the fundamental \emph{group} $\pi_1(W)$, but also the whole fundamental \emph{groupoid}.
\index{fundamental!pregroupoid}%
Spe\-cif\-ical\-ly, for a type $X$, write $\Pi_1 X: X\to X\to \type$ for the $0$-truncation of its identity type, i.e.\ $\Pi_1 X(x,y) \defeq \trunc0{x=y}$.
Note that we have induced groupoid operations
\begin{align*}
  (\blank\ct\blank) &\;:\; \Pi_1X(x,y) \to \Pi_1X(y,z) \to \Pi_1X(x,z)\\
  \opp{(\blank)} &\;:\; \Pi_1X(x,y) \to \Pi_1X(y,x)\\
  \refl{x} &\;:\; \Pi_1X(x,x)\\
  \apfunc{f} &\;:\; \Pi_1X(x,y) \to \Pi_1Y(fx,fy)
\end{align*}
for which we use the same notation as the corresponding operations on paths.

\subsection{Naive van Kampen}
\label{sec:naive-vankampen}

We begin with a ``naive'' version of the van Kampen theorem, which is useful but not quite as useful as the classical version.
In \cref{sec:better-vankampen} we will improve it to a more useful version.

\index{encode-decode method|(}%

Given types $A,B,C$ and functions $f:A\to B$ and $g:A\to C$, let $P$ be their pushout $B\sqcup^A C$.
As we saw in \cref{sec:colimits}, $P$ is the higher inductive type generated by
\begin{itemize}
\item $i:B\to P$,
\item $j:C\to P$, and
\item for all $x:A$, a path $k x:ifx = jgx$.
\end{itemize}
Define $\code:P\to P\to \type$ by double induction on $P$ as follows.
\begin{itemize}
\item $\code(ib,ib')$ is a set-quotient (see \cref{sec:set-quotients}) of the type of sequences %pairs $(\vec a, \vec a', \vec p, \vec q)$
  \[ (b, p_0, x_1, q_1, y_1, p_1, x_2, q_2, y_2, p_2, \dots, y_n, p_n, b') \]
  where
  \begin{itemize}
  \item $n:\mathbb{N}$
  \item $x_k:A$ and $y_k:A$ for $0<k \le n$
  \item $p_0:\Pi_1B(b,f x_1)$ and $p_n:\Pi_1B(f y_n, b')$ for $n>0$, and $p_0:\Pi_1B(b,b')$ for $n=0$
  \item $p_k:\Pi_1B(f y_k, fx_{k+1})$ for $1\le k < n$
  \item $q_k:\Pi_1C(gx_k, gy_k)$ for $1\le k\le n$
  \end{itemize}
  The quotient is generated by the following equalities:
  \begin{align*}
    (\dots, q_k, y_k, \refl{fy_k}, y_k, q_{k+1},\dots)
    &= (\dots, q_k\ct q_{k+1},\dots)\\
    (\dots, p_k, x_k, \refl{gx_k}, x_k, p_{k+1},\dots)
    &= (\dots, p_k\ct p_{k+1},\dots)
  \end{align*}
  (see \cref{rmk:naive} below).
  We leave it to the reader to define this type of sequences precisely as an inductive type.
\item $\code(jc,jc')$ is identical, with the roles of $B$ and $C$ reversed.
  We likewise notationally reverse the roles of $x$ and $y$, and of $p$ and $q$.
\item $\code(ib,jc)$ and $\code(jc,ib)$ are similar, with the parity changed so that they start in one type and end in the other.
\item For $a:A$ and $b:B$, we require an equivalence
  \begin{equation}
    \code(ib, ifa) \eqvsym \code(ib,jga).\label{eq:bfa-bga}
  \end{equation}
  We define this to consist of the two functions defined on sequences by
  \begin{align*}
    (\dots, y_n, p_n,fa) &\mapsto (\dots,y_n,p_n,a,\refl{ga},ga),\\
    (\dots, x_n, p_n, a, \refl{fa}, fa) &\mapsfrom (\dots, x_n, p_n, ga).
  \end{align*}
  Both of these functions are easily seen to respect the equivalence relations, and hence to define functions on the types of codes.
  The left-to-right-to-left composite is
  \[ (\dots, y_n, p_n,fa) \mapsto
  (\dots,y_n,p_n,a,\refl{ga},a,\refl{fa},fa)
  \]
  which is equal to the identity by a generating equality of the quotient.
  The other composite is analogous.
  Thus we have defined an equivalence~\eqref{eq:bfa-bga}.
\item Similarly, we require equivalences
  \begin{align*}
    \code(jc,ifa) &\eqvsym \code(jc,jga)\\
    \code(ifa,ib)&\eqvsym (jga,ib)\\
    \code(ifa,jc)&\eqvsym (jga,jc)
  \end{align*}
  all of which are defined in exactly the same way (the second two by adding reflexivity terms on the beginning rather than the end).
\item Finally, we need to know that for $a,a':A$, the following diagram commutes:
  \begin{equation}\label{eq:bfa-bga-comm}
  \vcenter{\xymatrix{
      \code(ifa,ifa') \ar[r]\ar[d] &
      \code(ifa,jga')\ar[d]\\
      \code(jga,ifa')\ar[r] &
      \code(jga,jga')
      }}
  \end{equation}
  This amounts to saying that if we add something to the beginning and then something to the end of a sequence, we might as well have done it in the other order.
\end{itemize}

\begin{rmk}\label{rmk:naive}
  One might expect to see in the definition of \code some additional generating equations for the set-quotient, such as
  \begin{align*}
    (\dots, p_{k-1} \ct fw, x_{k}', q_{k}, \dots) &=
    (\dots, p_{k-1}, x_{k}, gw \ct q_{k}, \dots)
    \tag{for $w:\Pi_1A(x_{k},x_{k}')$}\\
    (\dots, q_k \ct gw, y_k', p_k, \dots) &=
    (\dots, q_k, y_k, fw \ct p_k, \dots).
    \tag{for $w:\Pi_1A(y_k, y_k')$}
  \end{align*}
  However, these are not necessary!
  In fact, they follow automatically by path induction on $w$.
  This is the main difference between the ``naive'' van Kampen theorem and the more refined one we will consider in the next subsection.
\end{rmk}

Continuing on, we can characterize transporting in the fibration $\code$:
\begin{itemize}
\item For $p:b=_B b'$ and $u:P$, we have
  \[ \mathsf{transport}^{b\mapsto \code(u,ib)}(p, (\dots, y_n,p_n,b))
  = (\dots,y_n,p_n\ct p,b').
  \]
\item For $q:c=_C c'$ and $u:P$, we have
  \[ \mathsf{transport}^{c\mapsto \code(u,jc)}(q, (\dots, x_n,q_n,c))
  = (\dots,x_n,q_n\ct q,c').
  \]
\end{itemize}
Here we are abusing notation by using the same name for a path in $X$ and its image in $\Pi_1X$.
Note that transport in $\Pi_1X$ is also given by concatenation with (the image of) a path.
From this we can prove the above statements by induction on $u$.
We also have:
\begin{itemize}
\item For $a:A$ and $u:P$,
  \[ \mathsf{transport}^{v\mapsto \code(u,v)}(ha, (\dots, y_n,p_n,fa))
  = (\dots,y_n,p_n,a,\refl{ga},ga).
  \]
\end{itemize}
This follows essentially from the definition of $\code$.

We also construct a function
\[ r : \prd{u:P} \code(u,u) \]
by induction on $u$ as follows:
\begin{align*}
  rib &\defeq (b,\refl{b},b)\\
  rjc &\defeq (c,\refl{c},c)
\end{align*}
and for $rka$ we take the composite equality
\begin{align*}
  (ka,ka)_* (fa,\refl{fa},fa)
  &= (ga,\refl{ga},a,\refl{fa},a,\refl{ga},ga) \\
  &= (ga,\refl{ga},ga)
\end{align*}
where the first equality is by the observation above about transporting in $\code$, and the second is an instance of the set quotient relation used to define $\code$.

We will now prove:
\begin{thm}[Naive van Kampen theorem]\label{thm:naive-van-kampen}
  For all $u,v:P$ there is an equivalence
  \[ \Pi_1P(u,v) \eqvsym \code(u,v). \]
\end{thm}
\begin{proof}

To define a function
\[ \encode : \Pi_1P(u,v) \to \code(u,v) \]
it suffices to define a function $(u=_P v) \to \code(u,v)$,
since $\code(u,v)$ is a set.
We do this by transport:
\[\encode(p) \defeq \mathsf{transport}^{v\mapsto \code(u,v)}(p,r(u)).\]
Now to define
\[ \decode: \code(u,v) \to \Pi_1P(u,v) \]
we proceed as usual by induction on $u,v:P$.
In each case for $u$ and $v$, we apply $i$ or $j$ to all the equalities $p_k$ and $q_k$ as appropriate and concatenate the results in $P$, using $h$ to identify the endpoints.
For instance, when $u\jdeq ib$ and $v\jdeq ib'$, we define
\begin{narrowmultline}\label{eq:decode}
 \decode(b, p_0, x_1, q_1, y_1, p_1, \dots, y_n, p_n, b') \defeq\narrowbreak
 (p_0)\ct h(x_1) \ct j(q_1) \ct \opp{h(y_1)} \ct i(p_1) \ct \cdots \ct \opp{h(y_n)}\ct i(p_n).
\end{narrowmultline}
This respects the set-quotient equivalence relation and the equivalences such as~\eqref{eq:bfa-bga}, since $h: fi \htpy gj$ is natural and $f$ and $g$ are functorial.

As usual, to show that the composite
\[ \Pi_1P(u,v) \xrightarrow{\encode} \code(u,v) \xrightarrow{\decode} \Pi_1P(u,v) \]
is the identity, we first peel off the 0-truncation (since the codomain is a set) and then apply path induction.
The input $\refl{u}$ goes to $ru$, which then goes back to $\refl u$ (applying a further induction on $u$ to decompose $\decode(ru)$).

Finally, consider the composite
\[  \code(u,v) \xrightarrow{\decode} \Pi_1P(u,v) \xrightarrow{\encode} \code(u,v). \]
We proceed by induction on $u,v:P$.
When $u\jdeq ib$ and $v\jdeq ib'$, this composite is
%
\begin{narrowmultline*}
(b, p_0, x_1, q_1, y_1, p_1, \dots, y_n, p_n, b')
\narrowbreak
\begin{aligned}[t]
  &\mapsto \Big(ip_0\ct hx_1 \ct jq_1 \ct \opp{hy_1} \ct ip_1 \ct \cdots \ct \opp{hy_n}\ct ip_n\Big)_*(rib)\\
  &= (ip_n)_* \cdots(jq_1)_* (hx_1)_*(ip_0)_*(b,\refl{b},b)\\
  &= (ip_n)_* \cdots(jq_1)_* (hx_1)_*(b,p_0,ifx_1)\\
  &= (ip_n)_* \cdots(jq_1)_* (b,p_0,x_1,\refl{gx_1},jgx_1)\\
  &= (ip_n)_* \cdots (b,p_0,x_1,q_1,jgy_1)\\
  &= \quad\vdots\\
  &= (b, p_0, x_1, q_1, y_1, p_1, \dots, y_n, p_n, b').
\end{aligned}
\end{narrowmultline*}
%
i.e., the identity function.
(To be precise, there is an implicit inductive argument needed here.)
The other three point cases are analogous, and the path cases are trivial since all the types are sets.
\end{proof}

\index{encode-decode method|)}%

\cref{thm:naive-van-kampen} allows us to calculate the fundamental groups of many types, provided $A$ is a set,
for in that case, each $\code(u,v)$ is, by definition, a set-quotient of a \emph{set} by a relation.

\begin{eg}\label{eg:circle}
  Let $A\defeq \bool$, $B\defeq\unit$, and $C\defeq \unit$.
  Then $P \eqvsym S^1$.
  Inspecting the definition of, say, $\code(i(\ttt),i(\ttt))$, we see that the paths all may as well be trivial, so the only information is in the sequence of elements $x_1,y_1,\dots,x_n,y_n: \bool$.
  Moreover, if we have $x_k=y_k$ or $y_k=x_{k+1}$ for any $k$, then the set-quotient relations allow us to excise both of those elements.
  Thus, every such sequence is equal to a canonical \emph{reduced} one in which no two adjacent elements are equal.
  Clearly such a reduced sequence is uniquely determined by its length (a natural number $n$) together with, if $n>1$, the information of whether $x_1$ is $\bfalse$ or $\btrue$, since that determines the rest of the sequence uniquely.
  And these data can, of course, be identified with an integer, where $n$ is the absolute value and $x_1$ encodes the sign.
  Thus we recover $\pi_1(S^1)\cong \Z$.
\end{eg}

Since \cref{thm:naive-van-kampen} asserts only a bijection of families of sets, this isomorphism $\pi_1(S^1)\cong \Z$ is likewise only a bijection of sets.
We could, however, define a concatenation operation on $\code$ (by concatenating sequences) and show that $\encode$ and $\decode$ form an isomorphism respecting this structure.
(In the language of \cref{cha:category-theory}, these would be ``pregroupoids''.)
We leave the details to the reader.

\index{fundamental!group|(}%

\begin{eg}\label{eg:suspension}
  More generally, let $B\defeq\unit$ and $C\defeq \unit$ but $A$ be arbitrary, so that $P$ is the suspension of $A$.
  Then once again the paths $p_k$ and $q_k$ are trivial, so that the only information in a path code is a sequence of elements $x_1,y_1,\dots,x_n,y_n: A$.
  The first two generating equalities say that adjacent equal elements can be canceled, so it makes sense to think of this sequence as a word of the form
  \[ x_1 y_1^{-1} x_2 y_2^{-1} \cdots x_n y_n^{-1} \]
  in a group.
  Indeed, it looks similar to the free group on $A$ (or equivalently on $\trunc0A$; see \cref{thm:freegroup-nonset}), but we are considering only words that start with a non-inverted element, alternate between inverted and non-inverted elements, and end with an inverted one.
  This effectively reduces the size of the generating set by one.
  For instance, if $A$ has a point $a:A$, then we can identify $\pi_1(\susp A)$ with the group presented by $\trunc0A$ as generators with the relation $\tproj0a = e$; see \cref{ex:vksusppt,ex:vksuspnopt} for details.
\end{eg}

\begin{eg}\label{eg:wedge}
  Let $A\defeq\unit$ and $B$ and $C$ be arbitrary, so that $f$ and $g$ simply equip $B$ and $C$ with basepoints $b$ and $c$, say.
  Then $P$ is the \emph{wedge} $B\vee C$ of $B$ and $C$ (the coproduct in the category of based spaces).
  In this case, it is the elements $x_k$ and $y_k$ which are trivial, so that the only information is a sequence of loops $(p_0,q_1,p_1,\dots,p_n)$ with $p_k:\pi_1(B,b)$ and $q_k:\pi_1(C,c)$.
  Such sequences, modulo the equivalence relation we have imposed, are easily identified with the explicit description of the \emph{free product} of the groups $\pi_1(B,b)$ and $\pi_1(C,c)$, as constructed in \cref{sec:free-algebras}.
  Thus, we have $\pi_1(B\vee C) \cong \pi_1(B) * \pi_1(C)$.
\end{eg}

\index{fundamental!group|)}%

However, \cref{thm:naive-van-kampen} stops just short of being the full classical van Kampen theorem, which handles
the case where $A$ is not necessarily a set,
and states that $\pi_1(B\sqcup^A C) \cong \pi_1(B) *_{\pi_1(A)} \pi_1(C)$ (with base point coming from $A$).
Indeed, the conclusion of \cref{thm:naive-van-kampen} says nothing at all about $\pi_1(A)$; the paths in $A$ are ``built into the quotienting'' in a type-theoretic way that makes it hard to extract explicit information, in that $\code(u,v)$ is a set-quotient of a non-set by a relation.
For this reason, in the next subsection we consider a better version of the van Kampen theorem.


\subsection{The van Kampen theorem with a set of basepoints}
\label{sec:better-vankampen}

\index{basepoint!set of}%
The improvement of van Kampen we present now is closely analogous to a similar improvement in classical algebraic topology, where $A$ is equip\-ped with a \emph{set $S$ of base points}.
In fact, it turns out to be unnecessary for our proof to assume that the ``set of basepoints'' is a \emph{set} --- it might just as well be an arbitrary type; the utility of assuming $S$ is a set arises later, when applying the theorem to obtain computations.
What is important is that $S$ contains at least one point in each connected component of $A$.
We state this in type theory by saying that we have a type $S$ and a function $k:S \to A$ which is surjective, i.e.\ $(-1)$-connected.
If $S\jdeq A$ and $k$ is the identity function, then we will recover the naive van Kampen theorem.
Another example to keep in mind is when $A$ is pointed and (0-)connected, with $k:\unit\to A$ the point: by \cref{thm:minusoneconn-surjective,thm:connected-pointed} this map is surjective just when $A$ is 0-connected.

Let $A,B,C,f,g,P,i,j,h$ be as in the previous section.
We now define, given our surjective map $k:S\to A$, an auxiliary type which improves the connectedness of $k$.
Let $T$ be the higher inductive type generated by
\begin{itemize}
\item A function $\ell:S\to T$, and
\item For each $s,s':S$, a function $m:(\id[A]{ks}{ks'}) \to (\id[T]{\ell s}{\ell s'})$.
\end{itemize}
There is an obvious induced function $\kbar:T\to A$ such that $\kbar \ell = k$, and any $p:ks=ks'$ is equal to the composite $ks = \kbar \ell s \overset{\kbar m p}{=} \kbar \ell s' = k s'$.

\begin{lem}\label{thm:kbar}
  $\kbar$ is 0-connected.
\end{lem}
\begin{proof}
  We must show that for all $a:A$, the 0-truncation of the type $\sm{t:T}(\kbar t = a)$ is contractible.
  Since contractibility is a mere proposition and $k$ is $(-1)$-connected, we may assume that $a=ks$ for some $s:S$.
  Now we can take the center of contraction to be $\tproj0{(\ell s,q)}$ where $q$ is the equality $\kbar\ell s = k s$.

  It remains to show that for any $\phi:\trunc0{\sm{t:T} (\kbar t = ks)}$ we have $\phi = \tproj0{(\ell s,q)}$.
  Since the latter is a mere proposition, and in particular a set, we may assume that $\phi=\tproj0{(t,p)}$ for $t:T$ and $p:\kbar t = ks$.

  Now we can do induction on $t:T$.
  If $t\jdeq\ell s'$, then $ks' = \kbar \ell s' \overset{p}{=} ks$ yields via $m$ an equality $\ell s = \ell s'$.
  Hence by definition of $\kbar$ and of equality in homotopy fibers, we obtain an equality $(ks',p) = (ks,q)$, and thus $\tproj0{(ks',p)} = \tproj0{(ks,q)}$.
  Next we must show that as $t$ varies along $m$ these equalities agree.
  But they are equalities in a set (namely $\trunc0{\sm{t:T} (\kbar t = ks)}$), and hence this is automatic.
\end{proof}

\begin{rmk}
  \index{kernel!pair}%
  $T$ can be regarded as the (homotopy) coequalizer of the ``kernel pair'' of $k$.
  If $S$ and $A$ were sets, then the $(-1)$-connectivity of $k$ would imply that $A$ is the $0$-truncation of this coequalizer (see \cref{cha:set-math}).
  For general types, higher topos theory suggests that $(-1)$-con\-nec\-tiv\-i\-ty of $k$ will imply instead that $A$ is the colimit (a.k.a.\ ``geometric realization'') of the ``simplicial kernel'' of $k$.
  \index{.infinity1-topos@$(\infty,1)$-topos}%
  \index{geometric realization}%
  \index{simplicial!kernel}%
  \index{kernel!simplicial}%
  The type $T$ is the colimit of the ``1-skeleton'' of this simplicial kernel, so it makes sense that it improves the connectivity of $k$ by $1$.
  More generally, we might expect the colimit of the $n$-skeleton\index{skeleton!of a CW-complex} to improve connectivity by $n$.
\end{rmk}

\index{encode-decode method|(}%

Now we define $\code:P\to P\to \type$ by double induction as follows
\begin{itemize}
\item $\code(ib,ib')$ is now a set-quotient of the type of sequences
  \[ (b, p_0, x_1, q_1, y_1, p_1, x_2, q_2, y_2, p_2, \dots, y_n, p_n, b') \]
  where
  \begin{itemize}
  \item $n:\mathbb{N}$,
  \item $x_k:S$ and $y_k:S$ for $0<k \le n$,
  \item $p_0:\Pi_1B(b,f k x_1)$ and $p_n:\Pi_1B(f k y_n, b')$ for $n>0$, and $p_0:\Pi_1B(b,b')$ for $n=0$,
  \item $p_k:\Pi_1B(fk y_k, fkx_{k+1})$ for $1\le k < n$,
  \item $q_k:\Pi_1C(gkx_k, gky_k)$ for $1\le k\le n$.
  \end{itemize}
  The quotient is generated by the following equalities (see \cref{rmk:naive}):
  \begin{align*}
    (\dots, q_k, y_k, \refl{fy_k}, y_k, q_{k+1},\dots)
    &= (\dots, q_k\ct q_{k+1},\dots)\\
    (\dots, p_k, x_k, \refl{gx_k}, x_k, p_{k+1},\dots)
    &= (\dots, p_k\ct p_{k+1},\dots)\\
    (\dots, p_{k-1} \ct fw, x_{k}', q_{k}, \dots) &=
    (\dots, p_{k-1}, x_{k}, gw \ct q_{k}, \dots)
    \tag{for $w:\Pi_1A(kx_{k},kx_{k}')$}\\
    (\dots, q_k \ct gw, y_k', p_k, \dots) &=
    (\dots, q_k, y_k, fw \ct p_k, \dots).
    \tag{for $w:\Pi_1A(ky_k, ky_k')$}
  \end{align*}
  We will need below the definition of the case of $\decode$ on such a sequence, which as before concatenates all the paths $p_k$ and $q_k$ together with instances of $h$ to give an element of $\Pi_1P(ifb,ifb')$, cf.~\eqref{eq:decode}.
  As before, the other three point cases are nearly identical.
\item For $a:A$ and $b:B$, we require an equivalence
  \begin{equation}
    \code(ib, ifa) \eqvsym \code(ib,jga).\label{eq:bfa-bga2}
  \end{equation}
  Since $\code$ is set-valued, by \cref{thm:kbar} we may assume that $a=\kbar t$ for some $t:T$.
  Next, we can do induction on $t$.
  If $t\jdeq \ell s$ for $s:S$, then we define~\eqref{eq:bfa-bga2} as in \cref{sec:naive-vankampen}:
  \begin{align*}
    (\dots, y_n, p_n,fks) &\mapsto (\dots,y_n,p_n,s,\refl{gks},gks),\\
    (\dots, x_n, p_n, s, \refl{fks}, fks) &\mapsfrom (\dots, x_n, p_n, gks).
  \end{align*}
  These respect the equivalence relations, and define quasi-inverses just as before.
  Now suppose $t$ varies along $m_{s,s'}(w)$ for some $w:ks=ks'$; we must show that~\eqref{eq:bfa-bga2} respects transporting along $\kbar mw$.
  By definition of $\kbar$, this essentially boils down to transporting along $w$ itself.
  By the characterization of transport in path types, what we need to show is that
  \[ w_*(\dots, y_n, p_n,fks) = (\dots,y_n, p_n \ct fw, fks') \]
  is mapped by~\eqref{eq:bfa-bga2} to
  \[ w_*(\dots,y_n,p_n,s,\refl{gks},gks) = (\dots, y_n, p_n, s, \refl{gks} \ct gw, gks') \]
  But this follows directly from the new generators we have imposed on the set-quotient relation defining \code.
\item The other three requisite equivalences are defined similarly.
\item Finally, since the commutativity~\eqref{eq:bfa-bga-comm} is a mere proposition, by $(-1)$-connectedness of $k$ we may assume that $a=ks$ and $a'=ks'$, in which case it follows exactly as before.
\end{itemize}

\begin{thm}[van Kampen with a set of basepoints]\label{thm:van-Kampen}
  For all $u,v:P$ there is an equivalence
  \[ \Pi_1P(u,v) \eqvsym \code(u,v). \]
  with \code defined as in this section.
\end{thm}

\begin{proof}
  Basically just like before.
  To show that $\decode$ respects the new generators of the quotient relation, we use the naturality of $h$.
  And to show that $\decode$ respects the equivalences such as~\eqref{eq:bfa-bga2}, we need to induct on $\kbar$ and on $T$ in order to decompose those equivalences into their definitions, but then it becomes again simply functoriality of $f$ and $g$.
  The rest is easy.
  In particular, no additional argument is required for $\encode\circ\decode$, since the goal is to prove an equality in a set, and so the case of $h$ is trivial.
\end{proof}

\index{encode-decode method|)}%

\index{fundamental!group|(}%
\cref{thm:van-Kampen} allows us to calculate the fundamental group of a space~$A$,
even when $A$ is not a set, provided $S$ is a set, for in that case,
each $\code(u,v)$ is, by definition, a set-quotient of a \emph{set} by a
relation.  In that respect, it is an improvement over
\cref{thm:naive-van-kampen}.

\begin{eg}\label{eg:clvk}
  Suppose $S\defeq \unit$, so that $A$ has a basepoint $a \defeq k(\ttt)$ and is connected.
  Then code for loops in the pushout can be identified with alternating sequences of loops in $\pi_1(B,f(a))$ and $\pi_1(C,g(a))$, modulo an equivalence relation which allows us to slide elements of $\pi_1(A,a)$ between them (after applying $f$ and $g$ respectively).
  Thus, $\pi_1(P)$ can be identified with the \emph{amalgamated free product}
  \index{amalgamated free product}%
  \index{free!product!amalgamated}%
  $\pi_1(B) *_{\pi_1(A)} \pi_1(C)$ (the pushout in the category of groups), as constructed in \cref{sec:free-algebras}.
  This (in the case when $B$ and $C$ are open subspaces of $P$ and $A$ their intersection) is probably the most classical version of the van Kampen theorem.
\end{eg}

\begin{eg}\label{eg:cofiber}
  \index{cofiber}
  As a special case of \cref{eg:clvk}, suppose additionally that $C\defeq\unit$, so that $P$ is the cofiber $B/A$.
  Then every loop in $C$ is equal to reflexivity, so the relations on path codes allow us to collapse all sequences to a single loop in $B$.
  The additional relations require that multiplying on the left, right, or in the middle by an element in the image of $\pi_1(A)$ is the identity.
  We can thus identify $\pi_1(B/A)$ with the quotient of the group $\pi_1(B)$ by the normal subgroup generated by the image of $\pi_1(A)$.
\end{eg}

\begin{eg}\label{eg:torus}
  \index{torus}
  As a further special case of \cref{eg:cofiber}, let $B\defeq S^1 \vee S^1$, let $A\defeq S^1$, and let $f:A\to B$ pick out the composite loop $p \ct q \ct \opp p \ct \opp q$, where $p$ and $q$ are the generating loops in the two copies of $S^1$ comprising $B$.
  Then $P$ is a presentation of the torus $T^2$.
  Indeed, it is not hard to identify $P$ with the presentation of $T^2$ as described in \cref{sec:hubs-spokes}, using the cone on a particular loop.
  Thus, $\pi_1(T^2)$ is the quotient of the free group on two generators\index{generator!of a group} (i.e., $\pi_1(B)$) by the relation $p \ct q \ct \opp p \ct \opp q = 1$.
  This clearly yields the free \emph{abelian}\index{group!abelian} group on two generators, which is $\Z\times\Z$.
\end{eg}


\begin{eg}
  \index{CW complex}
  \index{hub and spoke}
  More generally, any CW complex can be obtained by repeatedly ``coning off'' spheres, as described in \cref{sec:hubs-spokes}.
  That is, we start with a set $X_0$ of points (``0-cells''), which is the ``0-skeleton'' of the CW complex.
  We take the pushout
  \begin{equation*}
    \vcenter{\xymatrix{
        S_1 \times \Sn^0\ar[r]^-{f_1}\ar[d] &
        X_0\ar[d]\\
        \unit \ar[r] &
        X_1
      }}
  \end{equation*}
  for some set $S_1$ of 1-cells and some family $f_1$ of ``attaching maps'', obtaining the ``1-skeleton''\index{skeleton!of a CW-complex} $X_1$.
  \index{attaching map}%
  Then we take the pushout
  \begin{equation*}
    \vcenter{\xymatrix{
        S_2 \times \Sn^1\ar[r]^{f_2}\ar[d] &
        X_1\ar[d]\\
        \unit \ar[r] &
        X_2
      }}
  \end{equation*}
  for some set $S_2$ of 2-cells and some family $f_2$ of attaching maps, obtaining the 2-skeleton $X_2$, and so on.
  The fundamental group of each pushout can be calculated from the van Kampen theorem: we obtain the group presented by generators derived from the 1-skeleton, and relations derived from $S_2$ and $f_2$.
  The pushouts after this stage do not alter the fundamental group, since $\pi_1(\Sn^n)$ is trivial for $n>1$ (see \cref{sec:pik-le-n}).
\end{eg}


\begin{eg}\label{eg:kg1}
  In particular, suppose given any presentation\index{presentation!of a group} of a (set-)group $G = \langle X \mid R \rangle$, with $X$ a set of generators and $R$ a set of words in these generators\index{generator!of a group}.
  Let $B\defeq \bigvee_X S^1$ and $A\defeq \bigvee_R S^1$, with $f:A\to B$ sending each copy of $S^1$ to the corresponding word in the generating loops of $B$.
  It follows that $\pi_1(P) \cong G$; thus we have constructed a connected type whose fundamental group is $G$.
  Since any group has a presentation, any group is the fundamental group of some type.
  If we 1-truncate such a type, we obtain a type whose only nontrivial homotopy group is $G$; this is called an \define{Eilenberg--Mac Lane space} $K(G,1)$.%
  \indexdef{Eilenberg--Mac Lane space}%
\end{eg}

\index{fundamental!group|)}%

\index{van Kampen theorem|)}%
\index{theorem!van Kampen|)}%

\section{Whitehead's theorem and Whitehead's principle}
\label{sec:whitehead}

In classical homotopy theory, a map $f:A\to B$ which induces an isomorphism $\pi_n(A,a) \cong \pi_n(B,f(a))$ for all points $a$ in $A$ (and also an isomorphism $\pi_0(A)\cong\pi_0(B)$) is necessarily a homotopy equivalence, as long as the spaces $A$ and $B$ are well-behaved (e.g.\ have the homotopy types of CW-complexes).
\index{theorem!Whitehead's}%
\index{Whitehead's!theorem}%
This is known as \emph{Whitehead's theorem}.
In fact, the ``ill-behaved'' spaces for which Whitehead's theorem fails are invisible to type theory.
Roughly, the well-behaved topological spaces suffice to present $\infty$-groupoids,%
\index{.infinity-groupoid@$\infty$-groupoid}
and homotopy type theory deals with $\infty$-groupoids directly rather than actual topological spaces.
Thus, one might expect that Whitehead's theorem would be true in univalent foundations.

However, this is \emph{not} the case: Whitehead's theorem is not provable.
In fact, there are known models of type theory in which it fails to be true, although for entirely different reasons than its failure for ill-behaved topological spaces.
These models are ``non-hypercomplete $\infty$-toposes''
\index{.infinity1-topos@$(\infty,1)$-topos}%
\index{.infinity1-topos@$(\infty,1)$-topos!non-hypercomplete}%
(see~\cite{lurie:higher-topoi}); roughly speaking, they consist of sheaves of $\infty$-groupoids over $\infty$-dimensional base spaces.

\index{axiom!Whitehead's principle|(}%
\index{Whitehead's!principle|(}%

From a foundational point of view, therefore, we may speak of \emph{Whitehead's principle} as a ``classicality axiom'', akin to \LEM{} and \choice{}.
It may consistently be assumed, but it is not part of the computationally motivated type theory, nor does it hold in all natural models.
But when working from set-theoretic foundations, this principle is invisible: it cannot fail to be true in a world where $\infty$-groupoids are built up out of sets (using topological spaces, simplicial sets, or any other such model).

This may seem odd, but actually it should not be surprising.
Homotopy type theory is the \emph{abstract} theory of homotopy types, whereas the homotopy theory of topological spaces or simplicial sets in set theory is a \emph{concrete} model of this theory, in the same way that the integers are a concrete model of the abstract theory of rings.
It is to be expected that any concrete model will have special properties which are not intrinsic to the corresponding abstract theory, but which we might sometimes want to assume as additional axioms (e.g.\ the integers are a Principal Ideal Domain, but not all rings are).

It is beyond the scope of this book to describe any models of type theory, so we will not explain how Whitehead's principle might fail in some of them.
However, we can prove that it holds whenever the types involved are $n$-truncated for some finite $n$, by ``downward'' induction on $n$.
In addition to being of interest in its own right (for instance, it implies the essential uniqueness of Eilenberg--Mac Lane spaces), the proof of this result will hopefully provide some intuitive explanation for why we cannot hope to prove an analogous theorem without truncation hypotheses.

We begin with the following modification of \cref{thm:mono-surj-equiv}, which will eventually supply the induction step in the proof of the truncated Whitehead's principle.
It may be regarded as a type-theoretic, $\infty$-group\-oid\-al version of the classical statement that a fully faithful and essentially surjective functor is an equivalence of categories.

\begin{thm}\label{thm:whitehead0}
  Suppose $f:A\to B$ is a function such that
  \begin{enumerate}
  \item $\trunc0 f : \trunc0 A \to \trunc0 B$ is surjective, and\label{item:whitehead01}
  \item for any $x,y:A$, the function $\apfunc f : (\id[A]xy) \to (\id[B]{f(x)}{f(y)})$ is an equivalence.\label{item:whitehead02}
  \end{enumerate}
  Then $f$ is an equivalence.
\end{thm}
\begin{proof}
  Note that~\ref{item:whitehead02} is precisely the statement that $f$ is an embedding, c.f.~\cref{sec:mono-surj}.
  Thus, by \cref{thm:mono-surj-equiv}, it suffices to show that $f$ is surjective, i.e.\ that for any $b:B$ we have $\trunc{-1}{\hfib f b}$.
  Suppose given $b$; then since $\trunc0 f$ is surjective, there merely exists an $a:A$ such that $\trunc 0 f(\tproj0a) = \tproj0b$.
  And since our goal is a mere proposition, we may assume given such an $a$.
  Then we have $\tproj0{f(a)} = \trunc 0 f(\tproj0a) =\tproj0b$, hence $\trunc{-1}{f(a)=b}$.
  Again, since our goal is still a mere proposition, we may assume $f(a)=b$.
  Hence $\hfib f b$ is inhabited, and thus merely inhabited.
\end{proof}

Since homotopy groups are truncations of loop spaces\index{loop space}, rather than path spaces, we need to modify this theorem to speak about these instead. Recall the map $\Omega f$ from \cref{def:loopfunctor}.

\begin{cor}\label{thm:whitehead1}
  Suppose $f:A\to B$ is a function such that
  \begin{enumerate}
  \item $\trunc0 f : \trunc0 A \to \trunc0 B$ is a bijection, and
  \item for any $x:A$, the function $\Omega f : \Omega(A,x) \to \Omega(B,f(x))$ is an equivalence.
  \end{enumerate}
  Then $f$ is an equivalence.
\end{cor}
\begin{proof}
  By \cref{thm:whitehead0}, it suffices to show that $\apfunc f : (\id[A]xy) \to (\id[B]{f(x)}{f(y)})$ is an equivalence for any $x,y:A$.
  And by \cref{thm:equiv-inhabcod}, we may assume $\id[B]{f(x)}{f(y)}$.
  In particular, $\tproj0{f(x)} = \tproj0{f(y)}$, so since $\trunc0 f$ is an equivalence, we have $\tproj0 x = \tproj0y$, hence $\tproj{-1}{x=y}$.
  Since we are trying to prove a mere proposition ($\apfunc f$ being an equivalence), we may assume given $p:x=y$.
  But now the following square commutes up to homotopy:
  \begin{equation*}
  \vcenter{\xymatrix@C=3pc{
      \Omega(A,x)\ar[r]^-{\blank\ct p}\ar[d]_{\Omega f} &
      (\id[A]xy) \ar[d]^{\apfunc f}\\
      \Omega(B,f(x))\ar[r]_-{\blank\ct f(p)} &
      (\id[B]{f(x)}{f(y)}).
      }}
  \end{equation*}
  The top and bottom maps are equivalences, and the left-hand map is so by assumption.
  Hence, by the 2-out-of-3 property, so is the right-hand map.
\end{proof}

Now we can prove the truncated Whitehead's principle.

\begin{thm}\label{thm:whiteheadn}
  Suppose $A$ and $B$ are $n$-types and $f:A\to B$ is such that
  \begin{enumerate}
  \item $\trunc0f:\trunc0A \to \trunc0B$ is a bijection, and\label{item:wh0}
  \item $\pi_k(f):\pi_k(A,x) \to \pi_k(B,f(x))$ is a bijection for all $k\ge 1$ and all $x:A$.\label{item:whk}
  \end{enumerate}
  Then $f$ is an equivalence.
\end{thm}

\noindent
Condition~\ref{item:wh0} is almost the case of~\ref{item:whk} when $k=0$, except that it makes no reference to any basepoint $x:A$.

\begin{proof}
  We proceed by induction on $n$.
  When $n=-2$, the statement is trivial.
  Thus, suppose it to be true for all functions between $n$-types, and let $A$ and $B$ be $(n+1)$-types and $f:A\to B$ as above.
  The first condition in \cref{thm:whitehead1} holds by assumption, so it will suffice to show that for any $x:A$, the function $\Omega f: \Omega(A,x) \to \Omega(B,f(x))$ is an equivalence.

  Since $\Omega(A,x)$ and $\Omega(B,f(x))$ are $n$-types we can apply the induction hypothesis.
  We need to check that $\trunc 0{\Omega f}$ is a bijection, and that for all $k\geq1$ and $p : x = x$ the map $\pi_k(\Omega f):\pi_k(x = x,p) \to \pi_k(f(x) = f(x),\Omega f(p))$ is a bijection.
  The first statement holds by assumption, since $\trunc 0{\Omega f} \jdeq \pi_1(f)$.
  To prove the second statement, we generalize it first: we show that for all $y : A$ and $q : x = y$ we have $\pi_k(\apfunc f):\pi_k(x = y,q) \to \pi_k(f(x) = f(y),\apfunc f(q))$.
  This implies the desired statement, since when $y\defeq x$, we have $\pi_k(\Omega f)=\pi_k(\apfunc f)$ modulo identifying their base points $\Omega f(p)=\apfunc f(p)$.
  To prove the generalization, it suffices by path induction to prove it when $q$ is $\refl{a}$.
  In this case, we have $\pi_k(\apfunc f) = \pi_k(\Omega f) = \pi_{k+1}(f)$, and $\pi_{k+1}(f)$ is an bijection by the original assumptions.
\end{proof}

Note that if $A$ and $B$ are not $n$-types for any finite $n$, then there is no way for the induction to get started.

\begin{cor}\label{thm:whitehead-contr}
  If $A$ is a $0$-connected $n$-type and $\pi_k(A,a)=0$ for all $k$ and $a:A$, then $A$ is contractible.
\end{cor}
\begin{proof}
  Apply \cref{thm:whiteheadn} to the map $A\to\unit$.
\end{proof}

As an application, we can deduce the converse of \cref{thm:conn-pik}.

\begin{cor}\label{thm:pik-conn}
  For $n\ge 0$, a map $f:A\to B$ is $n$-connected if and only if the following all hold:
  \begin{enumerate}
  \item $\trunc0f:\trunc0A \to \trunc0B$ is an isomorphism.
  \item For any $a:A$ and $k\le n$, the map $\pi_k(f):\pi_k(A,a) \to \pi_k(B,f(a))$ is an isomorphism.
  \item For any $a:A$, the map $\pi_{n+1}(f):\pi_{n+1}(A,a) \to \pi_{n+1}(B,f(a))$ is surjective.
  \end{enumerate}
\end{cor}
\begin{proof}
  The ``only if'' direction is \cref{thm:conn-pik}.
  Conversely, by the long exact sequence of a fibration (\cref{thm:les}),
  \index{sequence!exact}%
  the hypotheses imply that $\pi_k(\hfib f {f(a)})=0$ for all $k\le n$ and $a:A$, and that $\trunc 0{\hfib f{f(a)}}$ is contractible.
  Since $\pi_k(\hfib f {f(a)}) = \pi_k(\trunc n{\hfib f{f(a)}})$ for $k\le n$, and $\trunc n{\hfib f{f(a)}}$ is $n$-connected, by \cref{thm:whitehead-contr} it is contractible for any $a$.

  It remains to show that $\trunc n{\hfib f{b}}$ is contractible for $b:B$ not necessarily of the form $f(a)$.
  However, by assumption, there is $x:\trunc0A$ with $\tproj 0b = \trunc0f(x)$.
  Since contractibility is a mere proposition, we may assume $x$ is of the form $\tproj0a$ for $a:A$, in which case $\tproj 0 b = \trunc0f(\tproj0a) = \tproj0{f(a)}$, and therefore $\trunc{-1}{b=f(a)}$.
  Again since contractibility is a mere proposition, we may assume $b=f(a)$, and the result follows.
\end{proof}

A map $f$ such that $\trunc0f$ is a bijection and $\pi_k(f)$ is a bijection for all $k$ is called \define{$\infty$-connected}%
\indexdef{function!.infinity-connected@$\infty$-connected}%
\indexdef{.infinity-connected function@$\infty$-connected function}
or a \define{weak equivalence}.%
\indexdef{equivalence!weak}%
\indexdef{weak equivalence!of types}
This is equivalent to asking that $f$ be $n$-connected for all $n$.
A type $Z$ is called \define{$\infty$-truncated}%
\indexdef{type!.infinity-truncated@$\infty$-truncated}%
\indexdef{.infinity-truncated type@$\infty$-truncated type}
or \define{hypercomplete}%
\indexdef{type!hypercomplete}%
\indexdef{hypercomplete type}
if the induced map
\[(\blank\circ f):(B\to Z) \to (A\to Z)\]
is an equivalence whenever $f$ is $\infty$-connected --- that is, if $Z$ thinks every $\infty$-connected map is an equivalence.
\indexdef{axiom!Whitehead's principle}%
Then if we want to assume Whitehead's principle as an axiom, we may use either of the following equivalent forms.
\begin{itemize}
\item Every $\infty$-connected function is an equivalence.
\item Every type is $\infty$-truncated.
\end{itemize}
In higher topos models,
\index{.infinity1-topos@$(\infty,1)$-topos}%
the $\infty$-truncated types form a reflective subuniverse in the sense of
\cref{sec:modalities} (the ``hypercompletion'' of an $(\infty,1)$-topos), but we do not know whether this is
true in general.

\index{axiom!Whitehead's principle|)}%
\index{Whitehead's!principle|)}%

It may not be obvious that there \emph{are} any types which are not $n$-types for any $n$, but in fact there are.
Indeed, in classical homotopy theory, $\Sn^n$ has this property for any $n\ge 2$.
We have not proven this fact in homotopy type theory yet, but there are other types which we can prove to have ``infinite truncation level''.

\begin{eg}
  Suppose we have $B:\nat\to\type$ such that for each $n$, the type $B(n)$ contains an $n$-loop\index{loop!n-@$n$-} which is not equal to $n$-fold reflexivity, say $p_n:\Omega^n(B(n),b_n)$ with $p_n \neq \refl{b_n}^n$.
  (For instance, we could define $B(n)\defeq \Sn^n$, with $p_n$ the image of $1:\Z$ under the isomorphism $\pi_n(\Sn^n)\cong \Z$.)
  Consider $C\defeq \prd{n:\nat} B(n)$, with the point $c:C$ defined by $c(n)\defeq b_n$.
  Since loop spaces commute with products, for any $m$ we have
  \[\eqvspaced{\Omega^m (C,c)}{\prd{n:\nat}\Omega^m(B(n),b_n)}.\]
  Under this equivalence, $\refl{c}^m$ corresponds to the function $(n\mapsto \refl{b_n}^m)$.
  Now define $q_m$ in the right-hand type by
  \[ q_m(n) \defeq
  \begin{cases}
    p_n &\quad m=n\\
    \refl{b_n}^m &\quad m\neq n.
  \end{cases}
  \]
  If we had $q_m = (n\mapsto \refl{b_n}^m)$, then we would have $p_n = \refl{b_n}^n$, which is not the case.
  Thus, $q_m \neq (n\mapsto \refl{b_n}^m)$, and so there is a point of $\Omega^m(C,c)$ which is unequal to $\refl{c}^m$.
  Hence $C$ is not an $m$-type, for any $m:\nat$.
\end{eg}

We expect it should also be possible to show that a universe $\UU$ itself is not an $n$-type for any $n$, using the fact that it contains higher inductive types such as $\Sn^n$ for all $n$.
However, this has not yet been done.

\section{A general statement of the encode-decode method}
\label{sec:general-encode-decode}

\indexdef{encode-decode method}

We have used the encode-decode method to characterize the path spaces
of various types, including coproducts (\cref{thm:path-coprod}), natural
numbers (\cref{thm:path-nat}), truncations (\cref{thm:path-truncation}),
the circle (\cref{{cor:omega-s1}}), suspensions (\cref{thm:freudenthal}), and pushouts
(\cref{thm:van-Kampen}).  Variants of this technique are used in the
proofs of many of the other theorems mentioned in the introduction to
this chapter, such as a direct proof of $\pi_n(\Sn^n)$, the Blakers--Massey theorem, and the construction of Eilenberg--Mac Lane spaces.
While it is tempting to try to
abstract the method into a lemma, this is difficult because
slightly different variants are needed for different problems.  For
example, different variations on the same method  can be used to
characterize a loop space (as in \cref{thm:path-coprod,cor:omega-s1}) or
a whole path space (as in \cref{thm:path-nat}), to give a complete
characterization of a loop space (e.g.\ $\Omega^1(\Sn ^1)$) or only to
characterize some truncation of it (e.g.\ van Kampen), and to calculate
homotopy groups or to prove that a map is $n$-connected (e.g.\ Freudenthal and
Blakers--Massey).

However, we can state lemmas for specific variants of the method.
The proofs of these lemmas are almost trivial; the main point is to
clarify the method by stating them in generality.  The simplest
case is using an encode-decode method to characterize the loop space of a
type, as in \cref{thm:path-coprod} and \cref{{cor:omega-s1}}.

\begin{lem}[Encode-decode for Loop Spaces]\label{lem:encode-decode-loop}
  \index{loop space}%
Given a pointed type $(A,a_0)$ and a fibration
$\code : A \to \type$, if
\begin{enumerate}
\item $c_0 : \code(a_0)$,\label{item:ed1}
\item $\decode : \prd{x:A} \code(x) \to (\id{a_0}{x})$,\label{item:ed2}
\item for all $c : \code(a_0)$, \id{\transfib{\code}{\decode(c)}{c_0}}{c}, and\label{item:ed3}
\item $\id{\decode(c_0)}{\refl{}}$,\label{item:ed4}
\end{enumerate}
then $(\id{a_0}{a_0})$ is equivalent to $\code(a_0)$.
\end{lem}

\begin{proof}
Define
$\encode : \prd{x:A} (\id{a_0}{x}) \to \code(x)$ by
\[
\encode_x(\alpha) = \transfib{\code}{\alpha}{c_0}.
\]
We show that $\encode_{a_0}$ and $\decode_{a_0}$ are quasi-inverses.
The composition $\encode_{a_0} \circ \decode_{a_0}$ is immediate by
assumption~\ref{item:ed3}.  For the other composition, we show
\[
\prd{x:A}{p : \id{a_0}{x}} \id{\decode_{x} (\encode_{x} p)}{p}.
\]
By path induction, it suffices to show
$\id{{\decode_{{a_0}} (\encode_{{a_o}} \refl{})}}{\refl{}}$.
After reducing the $\mathsf{transport}$, it suffices to show
$\id{{\decode_{{a_0}} (c_0)}}{\refl{}}$, which is assumption~\ref{item:ed4}.
\end{proof}

If a fiberwise equivalence between $(\id{a_0}{\blank})$ and $\code$ is desired,
it suffices to strengthen condition (iii) to
\[
\prd{x:A}{c : \code(x)} \id{\encode_{x}(\decode_{x}(c))}{c}.
\]
However, to calculate a loop space (e.g. $\Omega(\Sn ^1)$), this
stronger assumption is not necessary.

Another variation, which comes up often when calculating homotopy
groups, characterizes the truncation of a loop space:

\begin{lem}[Encode-decode for Truncations of Loop Spaces]
Assume a pointed type $(A,a_0)$ and a fibration
$\code : A \to \type$, where for every $x$, $\code(x)$ is a $k$-type.
Define
\[
\encode : \prd{x:A} \trunc{k}{\id{a_0}{x}} \to \code(x)
\]
by truncation recursion (using the fact
that $\code(x)$ is a $k$-type), mapping $\alpha : \id{a_0}{x}$ to
\transfib{\code}{\alpha}{c_0}. Suppose:
\begin{enumerate}
\item $c_0 : \code(a_0)$,
\item $\decode : \prd{x:A} \code(x) \to \trunc{k}{\id{a_0}{x}}$,
\item \label{item:decode-encode-loop-iii}
  $\id{\encode_{a_0}(\decode_{a_0}(c))}{c}$ for all $c : \code(a_0)$, and
\item \label{item:decode-encode-loop-iv}
  $\id{\decode(c_0)}{\tproj{}{\refl{}}}$.
\end{enumerate}
Then $\trunc{k}{\id{a_0}{a_0}}$ is equivalent to $\code(a_0)$.
\end{lem}

\begin{proof}
That $\decode \circ \encode$ is identity is immediate by \ref{item:decode-encode-loop-iii}.
%
To prove $\encode \circ \decode$, we first do a truncation induction, by
which it suffices to show
\[
\prd{x:A}{p : \id{a_0}{x}} \id{\decode_{x}(\encode_{x}(\tproj{k}{p}))}{\tproj{k}{p}}.
\]
The truncation induction is allowed because paths in a $k$-type are a
$k$-type.  To show this type, we do a path induction, and after reducing
the \encode, use assumption~\ref{item:decode-encode-loop-iv}.
\end{proof}

\section{Additional Results}
\label{sec:moreresults}

Though we do not present the proofs in this chapter, following results have also been established in homotopy type theory.

\begin{thm}
\index{homotopy!group!of sphere}
There exists a $k$ such that for all $n \ge 3$, $\pi_{n+1}(\Sn ^n) =
\Z_k$.
\end{thm}

\begin{proof}[Notes on the proof.]
The proof consists of a calculation of $\pi_4(\Sn ^3)$, together with an
appeal to stability (\cref{cor:stability-spheres}).  In the classical
statement of this result, $k$ is $2$.  While we have not yet checked that
$k$ is in fact $2$, our calculation of $\pi_4(\Sn ^3)$ is constructive,\index{mathematics!constructive}
like all the rest of the proofs in this chapter.
(More precisely, it doesn't use any additional axioms such as \LEM{} or \choice{}, making it as constructive as
univalence and higher inductive types are.)  Thus, given a
computational interpretation of homotopy type theory, we could run the
proof on a computer to verify that $k$ is $2$.  This example is quite
intriguing, because it is the first calculation of a homotopy group
for which we have not needed to know the answer in advance.
\end{proof}

% Recall from \cref{sec:colimits} that $X \sqcup^C Y$ denotes the
% (homotopy) pushout of $X$ and $Y$ along $C$.
\index{pushout}%

\begin{thm}[Blakers--Massey theorem]\label{Blakers-Massey}
  \indexdef{theorem!Blakers--Massey}%
  \indexsee{Blakers--Massey theorem}{theorem, Blakers--Massey}%
  Suppose we are given maps $f : C  \rightarrow X$, and $g : C \rightarrow Y$. Taking first the pushout $X \sqcup^C Y $ of $f$ and $g$ and then the pullback of its inclusions $\inl : X \rightarrow X \sqcup^C Y \leftarrow Y : \inr$, we have an induced map $C \to X \times_{(X \sqcup^C Y)} Y$.

  If $f$ is $i$-connected and $g$ is $j$-connected, then this induced map is $(i+j)$-connected. In other words, for any points $x:X$, $y:Y$, the corresponding fiber $C_{x,y}$ of $(f,g) : C \to X \times Y $ gives an approximation to the path space $\id[X \sqcup^C Y]{\inl(x)}{\inr(y)}$ in the pushout.
\end{thm}

It should be noted that in classical algebraic topology, the Blakers--Massey theorem is often stated in a somewhat different form, where the maps $f$ and $g$ are replaced by inclusions of subcomplexes of CW complexes, and the homotopy pushout and homotopy pullback by a union and intersection, respectively.
In order to express the theorem in homotopy type theory, we have to replace notions of this sort with ones that are homotopy-invariant.
We have seen another example of this in the van Kampen theorem (\cref{sec:van-kampen}), where we had to replace a union of open subsets by a homotopy pushout.

\begin{thm}[Eilenberg--Mac Lane Spaces]\label{Eilenberg-Mac-Lane-Spaces}
\index{Eilenberg--Mac Lane space}
For any abelian\index{group!abelian} group $G$ and positive integer $n$, there is an $n$-type
$K(G,n)$ such that $\pi_n(K(G,n)) = G$, and  $\pi_k(K(G,n)) = 0$
for $k\neq n$.
\end{thm}

\begin{thm}[Covering spaces]\label{thm:covering-spaces}
  \index{covering space}%
  For a connected space $A$, there is an equivalence between covering spaces over $A$ and sets with an action of $\pi_1(A)$.
\end{thm}


\sectionNotes

%% For the spheres,  two
%% different definitions of the $n$-sphere $\Sn ^n$ have been used: the first as the
%% suspension of $\Sn ^ {n-1}$ (\cref{sec:suspension}), and the second
%% as a higher inductive type with one base point and one loop in
%% $\Omega^n$ (\cref{sec:circle}); we list the status for both
%% definitions.  The equivalence of the two can be deduced from the remarks
%% at the end of \cref{sec:suspension}.

{
\newcommand{\humancheck}{\ding{52}}
\newcommand{\computercheck}{\ding{52}\kern-0.5em\ding{52}}
\begin{table}[htb]
  \centering
\begin{tabular}{lcc}
\toprule
Theorem         & Status \\
\midrule
$\pi_1(\Sn ^1)$                     & \computercheck \\
$\pi_{k<n}(\Sn ^n)$                  & \computercheck \\
%% $\pi_{k<n}(\Sn ^n)$ --- suspension  & \computercheck \\
%% $\pi_2(\Sn ^2)$ --- suspension      & \computercheck \\
long-exact-sequence of homotopy groups & \computercheck    \\
total space of Hopf fibration is $\Sn ^3$ & \humancheck    \\
$\pi_2(\Sn ^2)$                     & \computercheck \\
$\pi_3(\Sn ^2)$                     & \humancheck    \\
$\pi_n(\Sn ^n)$                     & \computercheck \\
%% $\pi_n(\Sn ^n)$ --- suspension      & \computercheck \\
$\pi_4(\Sn ^3)$                     & \humancheck    \\
Freudenthal suspension theorem      & \computercheck \\
Blakers--Massey theorem              & \computercheck \\
Eilenberg--Mac Lane spaces $K(G,n)$ & \computercheck \\
van Kampen theorem                & \computercheck \\
covering spaces                     & \computercheck \\
Whitehead's principle for $n$-types & \computercheck \\
\bottomrule
\end{tabular}
\caption{Theorems from homotopy theory proved by
  hand (\humancheck) and by computer (\computercheck).}
  \label{tab:theorems}
\end{table}
}

The theorems described in this chapter are standard results in classical
homotopy theory; many are described by \cite{hatcher02topology}.  In these
notes, we review the development of the new synthetic proofs of them in homotopy
type theory.  \cref{tab:theorems} lists the homotopy-theoretic
theorems that have been proven in homotopy type theory, and whether they
have been computer-checked.
Almost all of these results were developed during the spring term at IAS
in 2013, as part of a significant collaborative effort.  Many people
contributed to these results, for example by being the principal author
of a proof, by suggesting problems to work on, by participating in many
discussions and seminars about these problems, or by giving feedback on
results.  The following people were the principal authors of the first
homotopy type theory proofs of the above theorems. Unless indicated otherwise, for the
theorems that have been computer-checked, the principal authors were
also the first ones to formalize\index{mathematics!formalized} the proof using a computer proof
assistant.
\begin{itemize}
\item
Shulman gave the homotopy-theoretic calculation of $\pi_1(\Sn^1)$.  Licata later discovered the
encode-decode proof and the encode-decode method.

\item
Brunerie calculated $\pi_{k<n}(\Sn ^ n)$.
Licata later gave an encode-decode version.

\item Voevodsky constructed the long exact sequence of homotopy groups.

\item Lumsdaine constructed the Hopf fibration.
  Brunerie proved that its total space is $\Sn ^3$, thereby calculating $\pi_2(\Sn ^2)$ and
  $\pi_3(\Sn ^3)$.

\item Licata and Brunerie gave a direct calculation of
$\pi_n(\Sn ^n)$.

\item
  Lumsdaine proved the Freudenthal suspension theorem; Licata and
  Lumsdaine formalized this proof.
\item Lumsdaine, Finster, and Licata proved the Blakers--Massey theorem;
  Lumsdaine, Brunerie, Licata, and Hou formalized it.

\item
Licata gave an encode-decode calculation of $\pi_2(\Sn ^2)$, and a
calculation of $\pi_n(\Sn ^n)$ using the Freudenthal suspension theorem; using similar
techniques, he constructed $K(G,n)$.

\item
Shulman proved the van Kampen theorem; Hou formalized this proof.

\item
Licata proved Whitehead's theorem for $n$-types.

\item Brunerie calculated $\pi_4(\Sn ^3)$.

\item
Hou established the theory of covering spaces and formalized it.
\end{itemize}

The interplay between homotopy theory and type theory was crucial to the
development of these results.  For example, the first proof that
$\pi_1(\Sn ^1)=\mathbb{Z}$ was the one given in \cref{subsec:pi1s1-homotopy-theory}, which follows a classical homotopy theoretic one.  A
type-theoretic analysis of this proof resulted in the development of the
encode-decode method.  The first calculation of $\pi_2(\Sn ^2)$ also followed
classical methods, but this led quickly to an encode-decode proof of the
result.  The encode-decode calculation generalized to $\pi_n(\Sn ^n)$, which
in turn led to the proof of the Freudenthal suspension theorem, by
combining an encode-decode argument with classical homotopy-theoretic
reasoning about connectedness, which in turn led to the Blakers--Massey
theorem and Eilenberg--Mac Lane spaces.  The rapid development of this
series of results illustrates the promise of our new understanding of
the connections between these two subjects.

\sectionExercises

\begin{ex}\label{ex:homotopy-groups-resp-prod}
  Prove that homotopy groups respect products: $\eqv{\pi_n(A\times B)}{\pi_n(A)\times \pi_n(B)}$.
\end{ex}

\begin{ex}\label{ex:decidable-equality-susp}
  \index{decidable!equality}%
  Prove that if $A$ is a set with decidable equality (see \cref{defn:decidable-equality}), then its suspension $\susp A$ is a 1-type.
  (It is an open question\index{open!problem} whether this is provable without the assumption of decidable equality.)
\end{ex}

\begin{ex}\label{ex:contr-infinity-sphere-colim}
  Define $\Sn^\infty$ to be the colimit of the sequence $\Sn^0 \to \Sn^1 \to \Sn^2 \to\cdots$.
  Prove that $\Sn^\infty$ is contractible.
\end{ex}

\begin{ex}\label{ex:contr-infinity-sphere-susp}
  Define $\Sn^\infty$ to be the higher inductive type generated by
  \begin{itemize}
  \item Two points $\north:\Sn^\infty$ and $\south:\Sn^\infty$, and
  \item For each $x:\Sn^\infty$, a path $\merid(x):\north=\south$.
  \end{itemize}
  In other words, $\Sn^\infty$ is its own suspension.
  Prove that $\Sn^\infty$ is contractible.
\end{ex}

\begin{ex}\label{ex:unique-fiber}
  Suppose $f:X\to Y$ is a function and $Y$ is connected.
  Show that for any $y_1,y_2:Y$ we have $\brck{\eqv{\hfib f {y_1}}{\hfib f {y_2}}}$.
\end{ex}

\begin{ex}\label{ex:ap-path-inversion}
  For any pointed type $A$, let $i_A : \Omega A \to \Omega A$ denote inversion of loops, $i_A \defeq \lam{p} \rev{p}$.
  Show that $i_{\Omega A} : \Omega^2 A \to \Omega^2 A$ is equal to $\Omega(i_A)$.
\end{ex}

\begin{ex}\label{ex:pointed-equivalences}
  Define a \textbf{pointed equivalence} to be a pointed map whose underlying function is an equivalence.
  \begin{enumerate}
  \item Show that the type of pointed equivalences between pointed types $(X,x_0)$ and $(Y,y_0)$ is equivalent to $\id[\pointed\type]{(X,x_0)}{(Y,y_0)}$.
  \item Reformulate the notion of pointed equivalence in terms of a pointed quasi-inverse and pointed homotopies, in one of the coherent styles from \cref{cha:equivalences}.
  \end{enumerate}
\end{ex}

\begin{ex}\label{ex:HopfJr}
  Following the example of the Hopf fibration in \cref{sec:hopf}, define the \define{junior Hopf fibration}
  \indexdef{Hopf!fibration!junior}%
as a fibration (that is, a type family) over $\Sn ^1$ whose fiber over the basepoint is $\Sn ^0$ and whose total space is $\Sn ^1$.  This is also called the ``twisted double cover'' of the circle $\Sn ^1$.
\end{ex}

\begin{ex}\label{ex:SuperHopf}
Again following the example of the Hopf fibration in \cref{sec:hopf}, define an analogous fibration over $\Sn ^4$ whose fiber over the basepoint is $\Sn ^3$ and whose total space is $\Sn ^7$.  This is an open problem\index{open!problem} in homotopy type theory (such a fibration is known to exist in classical homotopy theory).
\end{ex}

\begin{ex}\label{ex:vksusppt}
  Continuing from \cref{eg:suspension}, prove that if $A$ has a point $a:A$, then we can identify $\pi_1(\susp A)$ with the group presented by $\trunc0A$ as generators with the relation $\tproj0a = e$.
  Then show that if we assume excluded middle, this is also the free group on $\trunc0 A \setminus \{\tproj0 a \}$.
\end{ex}

\begin{ex}\label{ex:vksuspnopt}
  Again continuing from \cref{eg:suspension}, but this time without assuming $A$ to be pointed, show that we can identify $\pi_1(\susp A)$ with the group presented by generators $\trunc0A \times \trunc0A$ and relations
  \begin{equation*}
    (a,b) = \opp{(b,a)},
    \qquad
    (a,c) = (a,b)\cdot (b,c),
    \qquad\text{and}\qquad
    (a,a) = e.
  \end{equation*}
\end{ex}

\index{acceptance|)}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "hott-online"
%%% End:
