\chapter{归纳 (Induction)}
\label{cha:induction}

在 \cref{cha:typetheory} 中，我们介绍了许多从旧类型生成新类型的方法。
除了（依赖）函数类型和宇宙 (universe) 类型外，所有这些规则都是一般性概念“归纳定义 (inductive definition)”的特例。\index{definition!inductive}\index{inductive!definition}
在本章中，我们将更广泛地研究归纳定义。

\section{归纳类型简介 (Introduction to inductive types)}
\label{sec:bool-nat}

\index{type!inductive|(}%
\index{generation!of a type, inductive|(}
一种 \emph{归纳类型 (inductive type)} $X$ 可以直观地理解为由某个有限集合的 \emph{构造器 (constructors)} 自由生成的类型，这些构造器中的每一个都是一个以 $X$ 为目标域的函数（具有一定数量的参数）。
这包括零参数的函数，它们只是 $X$ 的元素。

在描述特定的归纳类型时，我们用项目符号列出构造器。
例如，来自 \cref{sec:type-booleans} 的类型 \bool 是由以下构造器归纳生成的：
\begin{itemize}
    \item $\bfalse:\bool$
    \item $\btrue:\bool$
\end{itemize}
类似地，$\unit$ 是由以下构造器归纳生成的：
\begin{itemize}
    \item $\ttt:\unit$
\end{itemize}
而 $\emptyt$ 则没有任何构造器。
一个构造器函数接受参数的示例是余积 (coproduct) $A+B$，它由以下两个构造器生成：
\begin{itemize}
    \item $\inl:A\to A+B$
    \item $\inr:B\to A+B$。
\end{itemize}
另一个接受多个参数的示例是笛卡尔积 (cartesian product) $A\times B$，它由以下构造器生成：
\begin{itemize}
    \item $\pairr{\blank, \blank} : A\to B \to A\times B$。
\end{itemize}
重要的是，我们还允许定义的归纳类型的构造器接受来自被定义的归纳类型的参数。
例如，自然数类型 (natural numbers) $\nat$ 的构造器为：
\begin{itemize}
    \item $0:\nat$
    \item $\suc:\nat\to\nat$。
\end{itemize}
\symlabel{lst}
\index{type!of lists}%
\indexsee{list}{type of lists}%
另一个有用的例子是类型 $\lst A$，它表示某个类型 $A$ 的有限列表，其构造器为：
\begin{itemize}\label{list_constructors}
\item $\nil:\lst A$
\item $\cons:A\to \lst A \to \lst A$。
\end{itemize}

\index{free!generation of an inductive type}%
直观上，我们应该将归纳类型理解为由其构造器 \emph{自由生成的} 类型。
即，归纳类型的元素正是通过从无到有并反复应用构造器获得的。
（我们将在 \cref{sec:identity-systems,cha:hits} 中看到，这种概念在处理更一般的归纳定义时需要略微修改，但现在我们这样理解是足够的。）
例如，对于 \bool，我们应该期望唯一的元素是 $\bfalse$ 和 $\btrue$。
类似地，对于 $\nat$，我们应该期望每个元素要么是 $0$，要么是通过对某个“先前构造的”自然数应用 $\suc$ 获得的。

\index{induction principle}%
然而，我们不是直接断言这样的性质，而是通过 \emph{归纳原理 (induction principle)}，也称为 \emph{（依赖）消去规则 (dependent elimination rule)} 来表达这些性质。
我们已经在 \cref{cha:typetheory} 中见过这些原理。
例如，\bool 的归纳原理是：
%
\begin{itemize}
    \item 在证明关于 \bool 的 \emph{所有} 居民的陈述 $E : \bool \to \type$ 时，只需要证明其对于 $\bfalse$ 和 $\btrue$ 成立，即给出证明 $e_0 : E(\bfalse)$ 和 $e_1 : E(\btrue)$。
\end{itemize}

此外，当应用于构造器 $\bfalse$ 和 $\btrue$ 时，所得证明 $\ind\bool(E,e_0,e_1): \prd{b : \bool}E(b)$ 的行为符合预期；这一原理通过 \emph{计算规则 (computation rules)} 表达：\index{computation rule!for type of booleans}：
\begin{itemize}
    \item 我们有 $\ind\bool(E,e_0,e_1,\bfalse) \jdeq e_0$。
    \item 我们有 $\ind\bool(E,e_0,e_1,\btrue) \jdeq e_1$。
\end{itemize}

\index{case analysis}%
因此，布尔类型 (type \bool) 的归纳原理允许我们通过 \emph{情况分析 (case analysis)} 进行推理。
由于这两个构造器都不接受任何参数，因此这是布尔类型所需的全部内容。

\index{natural numbers}%
然而，对于自然数，情况分析通常是不够的：在对应于归纳步骤 $\suc(n)$ 的情况下，我们还希望假定要证明的命题已经对 $n$ 成立。
这给出了以下归纳原理：
\begin{itemize}
    \item 在证明关于 \emph{所有} 自然数的命题 $E : \nat \to \type$ 时，只需证明其对 $0$ 和 $\suc(n)$ 成立，并假设其对 $n$ 成立，即构造 $e_z : E(0)$ 和 $e_s : \prd{n : \nat} E(n) \to E(\suc(n))$。
\end{itemize}
与布尔类型的情况类似，我们也有与函数 $\ind\nat(E,e_z,e_s) : \prd{x:\nat} E(x)$ 相关的计算规则：
\index{computation rule!for natural numbers}%
\begin{itemize}
    \item $\ind\nat(E,e_z,e_s,0) \jdeq e_z$。
    \item $\ind\nat(E,e_z,e_s,\suc(n)) \jdeq e_s(n,\ind\nat(E,e_z,e_s,n))$ 对于任意 $n : \nat$。
\end{itemize}
因此，依赖函数 $\ind\nat(E,e_z,e_s)$ 可以理解为在参数 $x : \nat$ 上递归定义，通过我们称为 \define{递归 (recurrences)}\indexdef{recurrence} 的函数 $e_z$ 和 $e_s$。
当 $x$ 为零时，函数仅返回 $e_z$。
当 $x$ 是另一个自然数 $n$ 的后继时，结果是通过取递归 $e_s$ 并替换特定的前任 $n$ 以及递归调用值 $\ind\nat(E,e_z,e_s,n)$ 来获得的。

上述所有示例的归纳原理都具有这种家族相似性。
在 \cref{sec:strictly-positive} 中，我们将讨论“归纳定义”的一般概念以及如何为其推导出适当的 \emph{归纳原理 (induction principle)}，但首先我们将探讨归纳定义之间的各种共性。

\index{recursion principle}%
例如，我们在 \cref{cha:typetheory} 的每个示例中都提到，通过归纳原理我们可以推导出 \emph{递归原理 (recursion principle)}，其中目标域是简单类型（而非族）。
虽然归纳和递归原理可能看起来很奇怪，因为它们仅仅产生了一个函数的 \emph{存在性}，而似乎没有唯一地描述它。
然而，事实上，归纳原理足够强大，可以证明其自身的 \emph{唯一性原理 (uniqueness principle)}\index{uniqueness!principle, propositional!for functions on N@for functions on $\nat$}，如下定理所示。

\begin{thm}\label{thm:nat-uniq}
设 $f,g : \prd{x:\nat} E(x)$ 为两个函数，它们满足以下递归关系
%
\begin{equation*}
    e_z : E(0)
    \qquad\text{和}\qquad
    e_s : \prd{n : \nat} E(n) \to E(\suc(n))
\end{equation*}
%
并且满足命题等价，即
\begin{equation*}
    \id{f(0)}{e_z}
    \qquad\text{和}\qquad
    \id{g(0)}{e_z}
\end{equation*}
以及
\begin{gather*}
    \prd{n : \nat} \id{f(\suc(n))}{e_s(n, f(n))},\\
    \prd{n : \nat} \id{g(\suc(n))}{e_s(n, g(n))}。
\end{gather*}
那么 $f$ 和 $g$ 是相等的。
\end{thm}

\begin{proof}
    我们对类型族 $D(x) \defeq \id{f(x)}{g(x)}$ 使用归纳法。对于基础情况，我们有
    \[ f(0) = e_z = g(0) \]。
    对于归纳情况，假设 $n : \nat$，使得 $f(n) = g(n)$。然后
    \[ f(\suc(n)) = e_s(n, f(n)) = e_s(n, g(n)) = g(\suc(n)) \]。
    第一个和最后一个等式来自于对 $f$ 和 $g$ 的假设。中间等式来自于归纳假设以及应用保持等式的事实。这给出了 $f$ 和 $g$ 之间的逐点等价；调用函数扩展性 (function extensionality) 完成证明。
\end{proof}

请注意，唯一性原理甚至适用于仅在命题等价下满足递归关系的函数，即路径。
当然，从归纳原理得到的特定函数在判断上 (judgmentally)\index{judgmental equality} 满足这些递归关系；我们将在 \cref{sec:htpy-inductive} 中回到这一点。
另一方面，该定理本身仅断言函数之间的命题等价（另见 \cref{ex:same-recurrence-not-defeq}）。
从同伦 (homotopical) 视角来看，询问这个路径是否 \emph{一致}，即 $f=g$ 的等价是否唯一存在是自然的；我们将在 \cref{sec:initial-alg} 中看到这确实是事实。

当然，类似的函数唯一性定理通常也可以为其他归纳类型表述和证明。
在下一节中，我们将展示这一唯一性性质与同一性 (univalence) 结合如何表明，像自然数这样的归纳类型完全由其引入、消去和计算规则表征。

\index{type!inductive|)}%
\index{generation!of a type, inductive|)}%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{归纳类型的唯一性 (Uniqueness of inductive types)}
\label{sec:appetizer-univalence}

\index{uniqueness!of identity types}%
我们已经定义了“自然数 (natural numbers)”作为一个特定类型 \nat，它具有特定的归纳生成器 $0$ 和 $\suc$。
然而，根据上一节中描述的类型论中归纳定义的一般原则，并没有什么阻止我们以相同的方式定义 \emph{另一个} 类型。
\index{natural numbers!isomorphic definition of}
也就是说，假设我们定义 $\natp$ 为由以下构造器生成的归纳类型：
\begin{itemize}
    \item $\zerop:\natp$
    \item $\sucp:\natp\to\natp$。
\end{itemize}
那么 $\natp$ 将具有与 \nat 相同的归纳和递归原理。
在证明关于所有这些“新”自然数的命题 $E : \natp \to \type$ 时，只需给出证明 $e_z : E(\zerop)$ 和 \narrowequation{e_s : \prd{n : \natp} E(n) \to E(\sucp(n))}。
函数 $\rec\natp(E,e_z,e_s) : \prd{n:\natp} E(n)$ 的计算规则如下：
\begin{itemize}
    \item $\rec\natp(E,e_z,e_s,\zerop) \jdeq e_z$，
    \item $\rec\natp(E,e_z,e_s,\sucp(n)) \jdeq e_s(n,\rec\natp(E,e_z,e_s,n))$ 对于任意 $n : \natp$。
\end{itemize}
但是 \nat 和 \natp 之间的关系是什么？

这不仅仅是一个学术问题，因为类似于自然数的结构可以在许多其他地方找到。
\index{type!of lists}%
例如，我们可以将自然数与具有一个元素的类型上的列表相对应（这是可以说的最早出现的形式，发现于洞穴墙壁上\index{caves, walls of}），与非负整数 (non-negative integers)、有理数 (rationals) 和实数 (reals) 的子集相对应，等等。
从编程\index{programming} 的角度来看，我们的自然数的“一元 (unary)”表示是非常低效的，因此有时我们可能更喜欢使用二进制表示。
我们希望能够将所有这些版本的“自然数”彼此识别，以便在它们之间传递构造和结果。

当然，如果两个版本的自然数满足相同的归纳原理，那么它们将具有相同的诱导结构。
例如，回想在 \cref{sec:inductive-types} 中定义的函数 $\dbl$ 的例子。对于我们的新自然数，可以通过复制并添加引号来轻松定义类似的函数：
\[ \dblp \defeq \rec\natp(\natp, \; \zerop, \;  \lamu{n:\natp}{m:\natp} \sucp(\sucp(m)))。 \]
看似简单，但它带来了显而易见的缺点，即导致大量重复。不仅函数必须被重复，所有引理和它们的证明也必须被“加引号”。

在传统数学中，人们只是宣布 \nat 和 \natp 显然是“相同的”，并且可以根据需要将它们互换。
这通常没有问题，但它掩盖了相当多的细节，扩大了非正式数学与其精确描述之间的差距。
在同伦类型论 (homotopy type theory) 中，我们可以做得更好。

首先观察我们可以定义以下映射：
\begin{itemize}
    \item $f \defeq \rec\nat(\natp, \; \zerop, \;  \lamu{n:\nat} \sucp) : \nat \to\natp$，
    \item $g \defeq \rec\natp(\nat, \; 0, \;  \lamu{n:\natp} \suc) : \natp \to\nat$。
\end{itemize}
由于 $g$ 和 $f$ 的复合满足与 $\nat$ 上的恒等函数相同的递归关系，\cref{thm:nat-uniq} 得出 $\prd{n : \nat} \id{g(f(n))}{n}$，而同一定理的“加引号”版本得出 $\prd{n : \natp} \id{f(g(n))}{n}$。
因此，$f$ 和 $g$ 是准逆 (quasi-inverses)，因此 $\eqv{\nat}{\natp}$。
我们现在可以沿着这个等价将 \nat 上的函数直接转移到 \natp 上（反之亦然），例如
\[ \dblp \defeq \lamu{n:\natp} f(\dbl(g(n)))。 \]
不难证明这个版本的 $\dblp$ 与前一个版本相等。

当然，这并不令人惊讶；这种同构正是数学家在设想“识别” $\nat$ 与 $\natp$ 时的方式。
然而，“通过同构转移 (transfer across an isomorphism)”的机制取决于被转移的对象；它并不总是像将单个函数与 $f$ 和 $g$ 预先和后续组合那样简单。
考虑例如一个简单的引理：
\[\prd{n : \natp} \dblp(\sucp(n))=\sucp(\sucp(\dblp(n)))。\]
插入正确的 $f$s 和 $g$s 仅仅比直接在 $n:\natp$ 上重新证明它稍微容易一点。
\index{isomorphism!transfer across}%

\index{univalence axiom}%
在此处，同一性公理 (univalence axiom) 发挥作用：由于 $\eqv{\nat}{\natp}$，我们还具有 $\id[\type]{\nat}{\natp}$，即 \nat 和 \natp 作为类型是 \emph{相等的}。
现在，身份 (identity) 的归纳原理保证了与 \nat 相关的任何构造或证明都可以自动转移到 \natp 上。
我们只需将函数或定理的类型视为一个以类型为索引的类型族 $P:\type\to\type$，给定的对象是 $P(\nat)$ 的一个元素，并沿着路径 $\id \nat\natp$ 传输即可。
这涉及的开销要少得多。

为了简单起见，我们在两个具有 \emph{相同} 定义的类型 \nat 和 \natp 的情况下描述了这种方法。
然而，在实践中更常见的情况是定义并不完全相同，但无论如何，一个归纳原理蕴涵了另一个。
\index{type!unit}%
\index{natural numbers!encoded as list(unit)@encoded as $\lst\unit$}%
例如，考虑从一个单元素类型构造的列表类型 $\lst\unit$，它由以下内容生成：
\begin{itemize}
    \item 一个元素 $\nil:\lst\unit$，以及
    \item 一个函数 $\cons:\unit \times \lst\unit \to\lst\unit$。
\end{itemize}
这与 \nat 的定义不同，它并没有产生相同的归纳原理。
$\lst\unit$ 的归纳原理表明，对于任意 $E:\lst\unit\to\type$ 及其递归数据 $e_\nil:E(\nil)$ 和 $e_\cons : \prd{u:\unit}{\ell:\lst\unit} E(\ell) \to E(\cons(u,\ell))$，存在 $f:\prd{\ell:\lst\unit} E(\ell)$，使得 $f(\nil)\jdeq e_\nil$ 且 $f(\cons(u,\ell))\jdeq e_\cons(u,\ell,f(\ell))$。
（我们将在 \cref{sec:strictly-positive} 中看到如何推导归纳定义的归纳原理。）

现在假设我们定义 $0'' \defeq \nil: \lst\unit$，并通过 $\suc''(\ell) \defeq \cons(\ttt,\ell)$ 定义 $\suc'':\lst\unit\to\lst\unit$。
那么，对于任意 $E:\lst\unit\to\type$ 及其 $e_0:E(0'')$ 和 $e_s:\prd{\ell:\lst\unit} E(\ell) \to E(\suc''(\ell))$，我们可以定义
\begin{align*}
    e_\nil &\defeq e_0\\
    e_\cons(\ttt,\ell,x) &\defeq e_s(\ell,x)。
\end{align*}
（在 $e_\cons$ 的定义中，我们使用 $\unit$ 的归纳原理假设 $u$ 是 $\ttt$。）
现在我们可以应用 $\lst\unit$ 的归纳原理，得到 $f:\prd{\ell:\lst\unit} E(\ell)$，使得
\begin{gather*}
    f(0'') \jdeq f(\nil) \jdeq e_\nil \jdeq e_0\\
    f(\suc''(\ell)) \jdeq f(\cons(\ttt,\ell)) \jdeq e_\cons(\ttt,\ell,f(\ell)) \jdeq e_s(\ell,f(\ell))。
\end{gather*}
因此，$\lst\unit$ 满足与 \nat 相同的归纳原理，因此（根据上述相同的论证）与其相等。

最后，这些结论并不局限于自然数：它们适用于任何归纳类型。
如果我们有一个归纳定义的类型 $W$，以及另一个类型 $W'$，它满足与 $W$ 相同的归纳原理，那么可以推断出 $\eqv{W}{W'}$，因此 $W=W'$。
我们使用为 $W$ 和 $W'$ 推导出的递归原理构造映射 $W\to W'$ 和 $W'\to W$，然后使用每个的归纳原理证明两个复合等于恒等映射。
例如，在 \cref{cha:typetheory} 中，我们看到可以将 $A+B$ 的并 (coproduct) 也定义为 $\sm{x:\bool} \rec{\bool}(\UU,A,B,x)$。
后者的类型满足与前者相同的归纳原理；因此它们是规范等价的。

这当然与范畴论 (category theory) 中的熟悉事实非常相似，即如果两个对象具有相同的 \emph{泛性质 (universal property)}，那么它们是等价的。
在 \cref{sec:initial-alg} 中我们将看到归纳类型实际上具有一个泛性质，因此这是该一般原则的表现形式。
\index{universal property}


\section{\texorpdfstring{$\w$}{W}-类型 ($\w$-types)}
\label{sec:w-types}

归纳类型非常广泛，这对于它们的实用性和适用性来说是极好的，但使它们整体上难以研究。
幸运的是，它们都可以形式化地简化为几个特殊情况。
本书的范围之外不会讨论这种简化——这对在实践中使用类型论的数学家来说也无关紧要——但我们将花一些时间讨论我们尚未遇到的基本特殊情况之一。
这些是 Martin-Löf 的 \emph{$\w$-类型}，也称为 \emph{良基树 (well-founded trees)} 类型。
\index{tree, well-founded}%
$\w$-类型是自然数、列表和二叉树等类型的推广，它们足够通用，能够封装 \emph{任何} 归纳类型的“递归”方面。

一个特定的 $\w$-类型由给定的两个参数 $A : \type$ 和 $B : A \to \type$ 指定，在这种情况下，得到的 $\w$-类型写作 $\wtype{a:A} B(a)$。
类型 $A$ 表示 $\wtype{a :A} B(a)$ 的 \emph{标签 (labels)} 类型，它们作为构造器 (constructors)（然而，我们保留这个词用于归纳定义中出现的实际函数）。例如，在将自然数定义为 $\w$-类型时，%
\index{natural numbers!encoded as a W-type@encoded as a $\w$-type}
类型 $A$ 是由两个元素 $\bfalse$ 和 $\btrue$ 组成的类型 $\bool$，因为获得自然数的方式恰好有两种——它将是 $0$ 或者是另一个自然数的继承者。

类型族 $B : A \to \type$ 用于记录标签的元数 (arity)：一个标签 $a : A$ 将采用一个以 $B(a)$ 为索引的归纳参数族。我们可以因此将其理解为“$B(a)$-多个”标签的参数。这些参数由一个函数 $f : B(a) \to \wtype{a :A} B(a)$ 表示，理解为对于任意 $b : B(a)$，$f(b)$ 是标签 $a$ 的第“$b$”个参数。因此，$\w$-类型 $\wtype{a :A} B(a)$ 可以被视为良基树的类型，其中节点由 $A$ 的元素标记，每个由 $a : A$ 标记的节点具有 $B(a)$-多个分支。

在自然数的情况下，标签 $\bfalse$ 具有 0 元数，因为它构造了常量 0\index{zero}；标签 $\btrue$ 具有 1 元数，因为它构造了其参数的继承者\index{successor}。我们可以通过对 $\bool$ 的简单消去定义一个函数 $\rec\bool(\bbU,\emptyt,\unit)$ 到类型宇宙；这个函数对于 $\bfalse$ 返回空类型 $\emptyt$，对于 $\btrue$ 返回单位类型 $\unit$。因此我们可以定义
\symlabel{natw}
\index{type!unit}%
\index{type!empty}%
\[ \natw \defeq \wtype{b:\bool} \rec\bool(\bbU,\emptyt,\unit,b) \]
其中上标 $\mathbf{w}$ 用于将这种自然数版本与之前使用的版本区分开来。
类似地，我们可以将类型 $A$ 上的列表\index{type!of lists} 定义为具有 $\unit + A$ 个标签的 $\w$-类型：一个用于空列表的零元标签，再加上每个 $a : A$ 的一个一元标签，对应于将 $a$ 添加到列表的头部：
\[ \lst A \defeq \wtype{x: \unit + A} \rec{\unit + A}(\bbU, \; \emptyt, \; \lamu{a:A} \unit,\; x) \]。
\index{W-type@$\w$-type}%
\indexsee{type!W-@$\w$-}{$\w$-type}%
一般来说，由 $A : \type$ 和 $B : A \to \type$ 指定的 $\w$-类型 $\wtype{x:A} B(x)$ 是由以下构造器生成的归纳类型：
\begin{itemize}
    \item \label{defn:supp}
    $\supp : \prd{a:A} \Big(B(a) \to \wtype{x:A} B(x)\Big) \to \wtype{x:A} B(x)$。
\end{itemize}
%
构造器 $\supp$（“上确界 (supremum)”的缩写\index{supremum!constructor of a W-type@constructor of a $\w$-type}）接受一个标签 $a : A$ 和一个函数 $f : B(a) \to \wtype{x:A} B(x)$，该函数表示标签 $a$ 的参数，并构造出 $\wtype{x:A} B(x)$ 的一个新元素。使用我们之前将自然数编码为 $\w$-类型的方法，我们可以例如定义
\begin{equation*}
    \zerow \defeq \supp(\bfalse, \; \lamu{x:\emptyt} \rec\emptyt(\natw,x))。
\end{equation*}
换句话说，我们使用标签 $\bfalse$ 来构造 $\zerow$。然后，$\rec\bool(\bbU,\emptyt,\unit, \bfalse)$ 计算为 $\emptyt$，正如它应该的那样，因为 $\bfalse$ 是一个零元标签。因此，我们需要构造一个函数 $f : \emptyt \to \natw$，该函数表示提供给 $\bfalse$ 的（零个）参数。这当然是微不足道的，使用对 $\emptyt$ 的简单消去就能实现。同样地，我们可以定义 $1^{\mathbf{w}}$ 和一个继承者函数 $\sucw$
\begin{align*}
    1^{\mathbf{w}} &\defeq \supp(\btrue, \; \lamu{x:\unit} 0^{\mathbf{w}}) \\
    \sucw&\defeq \lamu{n:\natw} \supp(\btrue, \; \lamu{x:\unit} n)。
\end{align*}

\index{induction principle!for W-types@for $\w$-types}%
我们有以下针对 $\w$-类型的归纳原理：
\begin{itemize}
    \item 在证明关于所有 $\w$-类型 $\wtype{x:A} B(x)$ 元素的命题 $E : \big(\wtype{x:A} B(x)\big) \to \type$ 时，只需证明对于 $\supp(a,f)$ 的情况即可，假设它对所有 $b : B(a)$ 的 $f(b)$ 都成立。
    换句话说，只需给出一个证明
    \begin{equation*}
        e : \prd{a:A}{f : B(a) \to \wtype{x:A} B(x)}{g : \prd{b : B(a)} E(f(b))} E(\supp(a,f))
    \end{equation*}
\end{itemize}

\index{variable}%
变量 $g$ 代表我们的归纳假设，即所有标签 $a$ 的参数都满足 $E$。为了陈述这一点，我们对所有类型 $B(a)$ 的元素进行量化，因为每个 $b : B(a)$ 对应于标签 $a$ 的一个参数 $f(b)$。

我们如何在编码为 $\w$-类型的自然数上定义函数 $\dbl$？我们希望使用 $\natw$ 的递归原理，其余元类型为 $\natw$ 本身。因此我们需要构造一个合适的函数
\[e : \prd{a : \bool}{f : B(a) \to \natw}{g : B(a) \to \natw} \natw\]
它将表示 $\dbl$ 函数的递归；为了简化，我们将类型族 $\rec\bool(\bbU,\emptyt,\unit)$ 表示为 $B$。

显然，$e$ 将是一个以 $a : \bool$ 为第一个参数的函数。下一步是对 $a$ 进行案例分析，并根据它是 $\bfalse$ 还是 $\btrue$ 进行处理。这表明以下形式的定义
\[ e \defeq \lamu{a:\bool} \ind\bool(C,e_0,e_1,a) \]
其中
\[C \defeq \lamu{a:\bool} \prd{f : B(a) \to \natw}{g : B(a) \to \natw} \natw。\]
如果 $a$ 是 $\bfalse$，则类型 $B(a)$ 变为 $\emptyt$。因此，给定 $f : \emptyt \to \natw$ 和 $g : \emptyt \to \natw$，我们想要构造 $\natw$ 的一个元素。由于标签 $\bfalse$ 表示 $\emptyt$，它需要零个归纳参数，变量 $f$ 和 $g$ 是无关紧要的。我们返回 $\zerow$\index{zero} 作为结果：
\[ e_0 \defeq \lamu{f:\emptyt \to \natw}{g:\emptyt \to \natw} \zerow。 \]
类似地，如果 $a$ 是 $\btrue$，则类型 $B(a)$ 变为 $\unit$。
由于标签 $\btrue$ 表示继承者\index{successor} 操作符，它需要一个归纳参数——前驱\index{predecessor}——由变量 $f : \unit \to \natw$ 表示。
对前驱的递归调用的值由变量 $g : \unit \to \natw$ 表示。
因此，取这个值（即 $g(\ttt)$）并将继承者函数应用两次即可得到所需的结果：
\begin{equation*}
    e_1 \defeq \; \lamu{f:\unit \to \natw}{g:\unit \to \natw} \sucw(\sucw(g(\ttt)))。
\end{equation*}
将这些结合在一起，我们有
\[ \dbl \defeq \rec\natw(\natw, e) \]
其中 $e$ 的定义如上。

\symlabel{defn:recursor-wtype}
函数 $\rec{\wtype{x:A} B(x)}(E,e) : \prd{w : \wtype{x:A} B(x)} E(w)$ 的关联计算规则如下。
\index{computation rule!for W-types@for $\w$-types}%
\begin{itemize}
    \item
    对于任意 $a : A$ 和 $f : B(a) \to \wtype{x:A} B(x)$，我们有
    \begin{equation*}
        \rec{\wtype{x:A} B(x)}(E,e,\supp(a,f)) \jdeq
        e(a,f,\big(\lamu{b:B(a)} \rec{\wtype{x:A} B(x)}(E,e,f(b))\big))。
    \end{equation*}
\end{itemize}
换句话说，函数 $\rec{\wtype{x:A} B(x)}(E,e)$ 满足递归 $e$。

根据上述计算规则，函数 $\dbl$ 表现如预期：
\begin{align*}
    \dbl(\zerow) & \jdeq \rec\natw(\natw, e, \supp(\bfalse, \; \lamu{x:\emptyt} \rec\emptyt(\natw,x))) \\
    & \jdeq e(\bfalse, \big(\lamu{x:\emptyt} \rec\emptyt(\natw,x)\big),
    \big(\lamu{x:\emptyt} \dbl(\rec\emptyt(\natw,x))\big)) \\
    & \jdeq e_0(\big(\lamu{x:\emptyt} \rec\emptyt(\natw,x)\big), \big(\lamu{x:\emptyt} \dbl(\rec\emptyt(\natw,x))\big))\\
    & \jdeq \zerow \\
    \intertext{并且}
    \dbl(1^{\mathbf{w}}) & \jdeq \rec\natw(\natw, e, \supp(\btrue, \; \lamu{x:\unit} \zerow)) \\
    & \jdeq e(\btrue, \big(\lamu{x:\unit} \zerow\big), \big(\lamu{x:\unit} \dbl(\zerow)\big)) \\
    & \jdeq e_1(\big(\lamu{x:\unit} \zerow\big), \big(\lamu{x:\unit} \dbl(\zerow)\big)) \\
    & \jdeq \sucw(\sucw\big((\lamu{x:\unit} \dbl(\zerow))(\ttt)\big))\\
    & \jdeq \sucw(\sucw(\zerow))
\end{align*}
等等。

就像自然数一样，我们可以证明 $\w$-类型的唯一性定理：
\begin{thm}\label{thm:w-uniq}
\index{uniqueness!principle, propositional!for functions on W-types@for functions on $\w$-types}%
设 $g,h : \prd{w:\wtype{x:A}B(x)} E(w)$ 是两个满足递归
%
\begin{equation*}
    e : \prd{a,f} \Parens{\prd{b : B(a)} E(f(b))} \to  E(\supp(a,f))，
\end{equation*}
%
命题的函数，即满足
%
\begin{gather*}
    \prd{a,f} \id{g(\supp(a,f))} {e(a,f,\lamu{b:B(a)} g(f(b)))}，\\
    \prd{a,f} \id{h(\supp(a,f))}{e(a,f,\lamu{b:B(a)} h(f(b)))}。
\end{gather*}
然后 $g$ 和 $h$ 是相等的。
\end{thm}


\section{归纳类型是初始代数 (Inductive types are initial algebras)}
\label{sec:initial-alg}

\indexsee{initial!algebra characterization of inductive types}{homotopy-initial}%

如前所述，归纳类型 (Inductive types) 也具有范畴论中的一种普遍性质。它们是\emph{同伦初始代数 (homotopy-initial algebras)}：在由特定构造子 (constructors) 决定的“代数 (algebras)”范畴中，同伦初始代数是初始对象（在一致同伦 (coherent homotopy) 范畴中）。举一个简单的例子，考虑自然数 (natural numbers)。这里适当的“代数”是一种类型，具有与 $\nat$ 的构造子所赋予的相同结构。

\index{natural numbers!as homotopy-initial algebra}
\begin{defn}\label{defn:nalg}
\define{$\nat$-代数 ($\nat$-algebra)}
\indexdef{N-algebra@$\nat$-algebra}%
\indexdef{algebra!N-@$\nat$-}%
是一种类型 $C$，具有两个元素 $c_0 : C$ 和 $c_s : C \to C$。这种代数的类型为：
\begin{equation*}
    \nalg \defeq \sm {C : \type} C \times (C \to C).
\end{equation*}
\end{defn}

\begin{defn}\label{defn:nhom}
\define{$\nat$-同态 ($\nat$-homomorphism)}
\indexdef{N-homomorphism@$\nat$-homomorphism}%
\indexdef{homomorphism!N-@$\nat$-}%
在 $\nat$-代数 $(C,c_0,c_s)$ 和 $(D,d_0,d_s)$ 之间的同态是一个函数 $h : C \to D$，使得对所有 $c : C$，都有 $h(c_0) = d_0$ 且 $h(c_s(c)) = d_s(h(c))$。这些同态的类型为：
\begin{narrowmultline*}
    \nhom((C,c_0,c_s),(D,d_0,d_s)) \defeq \narrowbreak
    \dsm {h : C \to D} (\id{h(c_0)}{d_0}) \times \tprd{c:C} (\id{h(c_s(c))}{d_s(h(c))}).
\end{narrowmultline*}
\end{defn}

因此，我们有一个 $\nat$-代数和 $\nat$-同态的范畴，$\nat$ 是这个范畴的初始对象。范畴论专家会立即认识到这就是范畴中自然数对象的定义。

当然，由于我们的类型表现得像 $\infty$-群体 ($\infty$-groupoids)\index{.infinity-groupoid@$\infty$-groupoid}，我们实际上有一个 $\nat$-代数的 $(\infty,1)$-范畴\index{.infinity1-category@$(\infty,1)$-category}，我们应当要求 $\nat$ 在合适的 $(\infty,1)$-范畴意义上是初始的。幸运的是，我们可以在不需要定义 $(\infty,1)$-范畴的情况下表述这一点。

\begin{defn}
    \index{universal!property!of natural numbers}%
    称 $\nat$-代数 $I$ 为\define{同伦初始 (homotopy-initial)}\indexdef{homotopy-initial!N-algebra@$\nat$-algebra}\indexdef{N-algebra@$\nat$-algebra!homotopy-initial (h-initial)}，简称 \define{h-initial}\indexsee{h-initial}{homotopy-initial}，如果对于任意其他的 $\nat$-代数 $C$，从 $I$ 到 $C$ 的 $\nat$-同态类型是可收缩的。即：
    \begin{equation*}
        \ishinitn(I) \defeq \prd{C : \nalg} \iscontr(\nhom(I,C)).
    \end{equation*}
\end{defn}

当它们存在时，同伦初始代数是唯一的——不仅仅是同构意义上的唯一，而是通过单值性公理 (univalence axiom) 来实现的等同。

\begin{thm}
    任何两个同伦初始的 $\nat$-代数是相等的。因此，同伦初始的 $\nat$-代数的类型是一个单命题 (mere proposition)。
\end{thm}
\begin{proof}
    假设 $I$ 和 $J$ 是同伦初始的 $\nat$-代数。那么 $\nhom(I,J)$ 是可收缩的，因此包含某个 $\nat$-同态 $f:I\to J$，同样我们有一个 $\nat$-同态 $g:J\to I$。现在，复合 $g\circ f$ 是从 $I$ 到 $I$ 的 $\nat$-同态，$\idfunc[I]$ 也是如此；但是 $\nhom(I,I)$ 是可收缩的，所以 $g\circ f = \idfunc[I]$。同样，$f\circ g = \idfunc[J]$。因此 $\eqv IJ$，也就是说 $I=J$。由于可收缩性是一个单命题，并且依赖乘积保留单命题，因此同伦初始也是一个单命题。因此，任何两个证明 $I$（或 $J$）是同伦初始的证明必然是相等的，从而完成了证明。
\end{proof}

现在我们有了以下定理。

\begin{thm}\label{thm:nat-hinitial}
$\nat$-代数 $(\nat, \emptyt, \suc)$ 是同伦初始的。
\end{thm}
\begin{proof}[证明概述]
    固定任意 $\nat$-代数 $(C,c_0,c_s)$。$\nat$ 的递归原理给出了一个函数 $f:\nat\to C$，定义如下：
    \begin{align*}
        f(0) &\defeq c_0\\
        f(\suc(n)) &\defeq c_s(f(n))。
    \end{align*}
    这两个等式使得 $f$ 成为一个 $\nat$-同态，我们可以将其作为 $\nhom(\nat,C)$ 的收缩中心。唯一性定理（见 \cref{thm:nat-uniq}）然后表明，任何其他的 $\nat$-同态都等于 $f$。
\end{proof}

为了将其置于更一般的背景下，考虑\emph{自函子 (endofunctor) 的代数}的概念。\index{algebra!for an endofunctor}注意，使一种类型 $C$ 成为 $\nat$-代数与给出一个函数 $c:C+\unit\to C$ 是等价的，并且一个函数 $f:C\to D$ 是 $\nat$-同态，当且仅当 $f \circ c \htpy d \circ (f+\unit)$。在范畴语言中，这意味着 $\nat$-代数是类型范畴中自函子 $F(X)\defeq X+1$ 的代数。

\indexsee{functor!polynomial}{endofunctor, polynomial}%
\indexsee{polynomial functor}{endofunctor, polynomial}%
\indexdef{endofunctor!polynomial}%
\index{W-type@$\w$-type!as homotopy-initial algebra}
对于更一般的情况，考虑与 $A : \type$ 和 $B : A \to \type$ 关联的 $\w$-类型 (W-types)。在这种情况下，我们有一个关联的\define{多项式函子 (polynomial functor)}：
\begin{equation}
    \label{eq:polyfunc}
    P(X) = \sm{x : A} (B(x) \rightarrow X)。
\end{equation}
实际上，这个赋值仅在同伦意义上是函子的，但这在接下来的讨论中没有影响。根据定义，\define{$P$-代数 ($P$-algebra)}\indexdef{algebra!for a polynomial functor}\indexdef{algebra!W-@$\w$-}是类型 $C$，配有一个函数 $s_C :  PC \rightarrow C$。根据 $\Sigma$-类型的通用性质，这相当于给出一个函数 $\prd{a:A} (B(a) \to C) \to C$。我们还将这种对象称为 \define{$\w$-代数 ($\w$-algebras)}\indexdef{W-algebra@$\w$-algebra}，我们记为
\symlabel{walg}
\begin{equation*}
    \walg(A,B) \defeq \sm {C : \type} \prd{a:A} (B(a) \to C) \to C。
\end{equation*}

类似地，对于 $P$-代数 $(C,s_C)$ 和 $(D,s_D)$，一个 \define{同态 (homomorphism)}\indexdef{homomorphism!of algebras for a functor}%
在它们之间的同态 $(f, s_f) : (C, s_C) \rightarrow (D, s_D)$ 由一个函数 $f : C \rightarrow D$ 和一个在 $PC \rightarrow D$ 之间的同伦构成
\[
    s_f :  f \circ s_C \, = s_{D} \circ Pf,
\]
其中 $Pf : PC\rightarrow PD$ 是 $P$ 在 $f: C \rightarrow D$ 上的可轻易定义的作用结果。这样的代数同态可以表示为：
\[
    \xymatrix{
        PC \ar[d]_{s_C} \ar[r]^{Pf}  \ar@{}[dr]|{s_f} &  PD \ar[d]^{s_D}\\
        C \ar[r]_{f}   & D }
\]
在元素的层面上，$f$ 是一个 $P$-同态 (或 \define{$\w$-同态 ($\w$-homomorphism)})\indexdef{W-homomorphism@$\w$-homomorphism}\indexdef{homomorphism!W-@$\w$-}%
若
\[f(s_C(a,h)) = s_D(a,f \circ h)。\]
我们有 $\w$-同态的类型：
\symlabel{whom}
\begin{equation*}
    \whom_{A,B}((C, s_C),(D,s_D)) \defeq \sm{f : C \to D} \prd{a:A}{h:B(a)\to C} \id{f(s_C(a,h))}{s_D(a, f\circ h)}
\end{equation*}

\index{universal!property!of $\w$-type}%
最后，一个 $P$-代数 $(C, s_C)$ 被称为\define{同伦初始 (homotopy-initial)}\indexdef{homotopy-initial!algebra for a functor}\indexdef{homotopy-initial!W-algebra@$\w$-algebra}%
如果对于每个 $P$-代数 $(D, s_D)$，从 $(C, s_C)$ 到 $(D, s_D)$ 的所有代数同态的类型是可收缩的。即：
\begin{equation*}
    \ishinitw(A,B,I) \defeq \prd{C : \walg(A,B)} \iscontr(\whom_{A,B}(I,C))。
\end{equation*}

现在与 \cref{thm:nat-hinitial} 类似的定理是：

\begin{thm}\label{thm:w-hinit}
对于任意类型 $A : \type$ 和类型族 $B : A \to \type$，$\w$-代数 $(\wtype{x:A}B(x), \supp)$ 是同伦初始的。
\end{thm}

\begin{proof}[证明概述]
    假设我们有 $A : \type$ 和 $B : A \to \type$，并考虑关联的多项式函子 $P(X)\defeq\sm{x:A}(B(x)\to X)$。令 $W \defeq \wtype{x:A}B(x)$。然后使用 \cref{sec:w-types} 中的 $\w$-引入规则，我们有一个结构映射 $s_W\defeq\supp: PW \rightarrow W$。我们要证明代数 $(W, s_W)$ 是同伦初始的。因此，让我们考虑另一个代数 $(C,s_C)$ 并证明 $\w$-同态从 $(W, s_W)$ 到 $(C, s_C)$ 的类型 $T\defeq \whom_{A,B}((W, s_W),(C,s_C)) $ 是可收缩的。为此，观察到 $\w$-消去规则和 $\w$-计算规则允许我们定义一个 $\w$-同态 $(f, s_f) : (W, s_W) \rightarrow (C, s_C)$，从而表明 $T$ 是可居住的。此外，有必要表明，对于每个 $\w$-同态 $(g, s_g) : (W, s_W) \rightarrow (C, s_C)$，存在一个等式证明
    \begin{equation}
        \label{equ:prequired}
        p :  (f,s_f) = (g,s_g)。
    \end{equation}
    这利用了一个事实，即一般来说，$(f,s_f) = (g,s_g) $ 形式的类型等价于我们所称的从 $f$ 到 $g$ 的 \define{代数 $2$-胞腔 (algebra $2$-cells)}\indexdef{algebra!2-cell}%
    的类型，其标准元素是 $(e, s_e)$ 形式的对，其中 $e : f=g$ 并且 $s_e$ 是在以下粘贴图所代表的等式证明之间的更高等式证明：
    \[
        \xymatrix{
            PW \ar@/^1pc/[r]^{Pg}   \ar[d]_{s_W}   \ar@/_1pc/[r]_{Pf} \ar@{}[r]|{Pe}
            & PC \ar[d]^{s_C}  \\
            W  \ar@/_1pc/[r]_f  \ar@{}[r]^{s_f} & C } \qquad
        \xymatrix{
            PW \ar@/^1pc/[r]^{Pg}   \ar[d]_{s_W} \ar@{}[r]_(.52){s_g}  & PC \ar[d]^{s_C}  \\
            W \ar@/^1pc/[r]^g  \ar@/_1pc/[r]_f  \ar@{}[r]|{e} & C }
    \]
    鉴于此事实，为证明存在 \eqref{equ:prequired} 中的元素，足以证明存在从 $f$ 到 $g$ 的代数 $2$-胞腔 $(e,s_e)$。等式证明 $e : f=g$ 现在通过函数扩展性和 $\w$-消去法则构造，以保证所需的等式证明 $s_e$ 的存在。
\end{proof}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{同伦归纳类型 (Homotopy-inductive types)}
\label{sec:htpy-inductive}

在 \cref{sec:w-types} 中，我们展示了如何将自然数 (natural numbers) 编码为 $\w$-类型 (W-types)，如下所示：
\begin{align*}
    \natw & \defeq \wtype{b:\bool} \rec\bool(\bbU,\emptyt,\unit,b), \\
    \zerow & \defeq \supp(\bfalse, (\lamu{x:\emptyt} \rec\emptyt(\natw,x))), \\
    \sucw & \defeq \lamu{n:\natw} \supp(\btrue, (\lamu{x:\unit} n))。
\end{align*}
我们还展示了如何使用递归原理 (recursion principle) 在 $\natw$ 上定义 $\dbl$ 函数。然而，当涉及到归纳原理 (induction principle) 时，这种编码不再令人满意：给定 $E : \natw \to \type$ 和递归 $e_z : E(\zerow)$ 以及 $e_s : \prd{n : \natw}  E(n) \to E(\sucw(n))$，我们只能构造出一个依赖函数 $r(E,e_z,e_s) : \prd{n : \natw} E(n)$，它仅在命题意义上（即通过路径）满足给定的递归。这意味着无法从 $\w$-类型的规则中显然推导出自然数的计算规则 (computation rules)，这些规则给出的是判断相等性 (judgmental equalities)。

\index{type!homotopy-inductive}%
\index{homotopy-inductive type}%
当我们考虑\emph{同伦归纳类型 (homotopy-inductive types)} 时，这个问题消失了。在同伦归纳类型中，所有的计算规则都是在路径意义上陈述的，即符号 $\jdeq$ 被替换为 $=$。例如，同伦版 $\w$-类型 $\mathsf{W^h}$ 的计算规则变为：
\index{computation rule!propositional}%
\begin{itemize}
    \item 对于任何 $a : A$ 和 $f : B(a) \to \wtypeh{x:A} B(x)$，我们有
    \begin{equation*}
        \rec{\wtypeh{x:A} B(x)}(E,e,\supp(a,f)) = e\Big(a,f,\big(\lamu{b:B(a)} \rec{\wtypeh{x:A} B(x)}(E,f(b))\big)\Big)
    \end{equation*}
\end{itemize}

同伦归纳类型在计算性质方面有一个显而易见的缺点——通过归纳原理构造的任何函数的行为现在只能通过命题性方式描述。但是，其他许多考虑因素也驱使我们考虑同伦归纳类型。例如，尽管我们在 \cref{sec:initial-alg} 中证明了归纳类型是同伦初始代数，但并非每个同伦初始代数都是归纳类型（即满足相应的归纳原理）——但每个同伦初始代数\emph{确实}是同伦归纳类型。类似地，当其中一个（或两个）涉及的类型仅是同伦归纳类型时，我们可能希望应用来自 \cref{sec:appetizer-univalence} 的唯一性论证——例如，证明 $\w$-类型编码的 $\nat$ 等价于通常的 $\nat$。

此外，同伦归纳类型的概念现在是类型论内部的。例如，这意味着我们可以形成所有自然数对象的类型并对其进行断言。在 $\w$-类型的情况下，我们可以将同伦 $\w$-类型 $\wtype{x:A} B(x)$ 表征为任何配有上确界 (supremum) 函数和满足适当（命题性）计算规则的归纳原理的类型：
\begin{multline*}
    \w_d(A,B) \defeq \sm{W : \type}
    \sm{\supp : \prd {a} (B(a) \to W) \to W}
    \prd{E : W \to \type} \\
    \prd{e : \prd{a,f} (\prd{b : B(a)} E(f(b))) \to E(\supp(a,f))}
    \sm{\ind{} : \prd{w : W} E(w)}
    \prd{a,f} \\
    \ind{}(\supp(a,f)) = e(a,\lamu{b:B(a)} \ind{}(f(b)))。
\end{multline*}
在 \cref{cha:hits} 中，我们将看到为什么命题性计算规则值得考虑的其他原因。

在本节中，我们将陈述一些关于同伦归纳类型的基本事实。我们省略了大部分证明，因为它们有些技术性。

\begin{thm}
    对于任何 $A : \type$ 和 $B : A \to \type$，类型 $\w_d(A,B)$ 是一个单命题。
\end{thm}

事实证明，存在 $\w$-类型的另一种等价表征，使用递归原理，加上某些\emph{唯一性 (uniqueness)}和\emph{一致性 (coherence)}法则。首先，我们给出递归原理：
%
\begin{itemize}
    \item 当从 $\w$-类型 $\wtypeh{x:A} B(x)$ 构造一个到类型 $C$ 的函数时，只需给出它在 $\supp(a,f)$ 处的值，假设我们已经给出所有 $f(b)$ 的值，其中 $b : B(a)$。换句话说，只需构造一个函数
    \begin{equation*}
        c : \prd{a:A} (B(a) \to C) \to C。
    \end{equation*}
\end{itemize}
\index{computation rule!propositional}%
与 $\rec{\wtypeh{x:A} B(x)}(C,c) : (\wtype{x:A} B(x)) \to C$ 关联的计算规则如下：
\begin{itemize}
    \item 对于任何 $a : A$ 和 $f : B(a) \to \wtypeh{x:A} B(x)$，我们有一个等式见证 $\beta(C,c,a,f)$：
    \begin{equation*}
        \rec{\wtypeh{x:A} B(x)}(C,c,\supp(a,f)) =
        c(a,\lamu{b:B(a)} \rec{\wtypeh{x:A} B(x)}(C,c,f(b)))。
    \end{equation*}
\end{itemize}

此外，我们断言以下唯一性原则，表明由相同递归定义的任何两个函数是相等的：
\index{uniqueness!principle, propositional!for homotopy W-types@for homotopy $\w$-types}%
\begin{itemize}
    \item 设 $C : \type$ 和 $c : \prd{a:A} (B(a) \to C) \to C$ 给定。设 $g,h : (\wtypeh{x:A} B(x)) \to C$ 是两个函数，它们在命题相等性上满足递归 $c$，即我们有
    \begin{align*}
        \beta_g &: \prd{a,f} \id{g(\supp(a,f))}{c(a,\lamu{b: B(a)} g(f(b)))}，\\
        \beta_h &: \prd{a,f} \id{h(\supp(a,f))}{c(a,\lamu{b: B(a)} h(f(b)))}。
    \end{align*}
    那么 $g$ 和 $h$ 是相等的，即存在 $\alpha(C,c,f,g,\beta_g,\beta_h)$ 类型 $g = h$ 的元素。
\end{itemize}

\index{coherence}%
回想一下，当我们有一个归纳原理而不仅仅是递归原理时，这种命题唯一性原则是可导出的（见 \cref{thm:w-uniq}）。但仅有递归时，唯一性原则不再是可导出的——事实上，该陈述甚至不是真的（练习题）。因此，我们将其作为一个公理来假设。我们还假设以下一致性法则，告诉我们唯一性证明在典型元素上的行为：
\begin{itemize}
    \item
    对于任何 $a : A$ 和 $f : B(a) \to C$，以下图命题性地交换：
    \[\xymatrix{
        g(\supp(a,f)) \ar_{\alpha(\supp(a,f))}[d] \ar^-{\beta_g}[r] & c(a,\lamu{b:B(a)} g(f(b)))
        \ar^{c(a,\blank)(\funext (\lam{b} \alpha(f(b))))}[d] \\
        h(\supp(a,f)) \ar_-{\beta_h}[r] & c(a,\lamu{b: B(a)} h(f(b))) \\
    }\]
    其中 $\alpha$ 是路径 $\alpha(C,c,f,g,\beta_g,\beta_h) : g = h$ 的缩写。
\end{itemize}

将所有这些数据结合起来得出 $\wtype{x:A} B(x)$ 的另一种表征，即配有上确界函数、满足简单消去、计算、唯一性和一致性规则的类型：
\begin{multline*}
    \w_s(A,B) \defeq \sm{W : \type}
    \sm{\supp : \prd {a} (B(a) \to W) \to W}
    \prd{C : \type}
    \prd{c : \prd{a} (B(a) \to C) \to C}\\
    \sm{\rec{} : W \to C}
    \sm{\beta : \prd{a,f} \rec{}(\supp(a,f)) = c(a,\lamu{b: B(a)} \rec{}(f(b)))} \narrowbreak
    \prd{g : W \to C}
    \prd{h : W \to C}
    \prd{\beta_g : \prd{a,f} g(\supp(a,f)) = c(a,\lamu{b: B(a)} g(f(b)))} \\
    \prd{\beta_h : \prd{a,f} h(\supp(a,f)) = c(a,\lamu{b: B(a)} h(f(b)))}
    \sm{\alpha : \prd {w : W} g(w) = h(w)}
    \prd{a,f} \\
    \alpha(\supp(a,f)) \ct \beta_h = \beta_g \ct c(a,-)(\funext \; \lam{b} \alpha(f(b)))
\end{multline*}

\begin{thm}
    对于任意 $A : \type$ 和 $B : A \to \type$，类型 $\w_s (A,B)$ 是一个单命题。
\end{thm}

最后，我们有一个第三个非常简洁的表征，将 $\wtype{x:A} B(x)$ 作为同伦初始的 $\w$-代数：
\begin{equation*}
    \w_h(A,B) \defeq \sm{I : \walg(A,B)} \ishinitw(A,B,I)。
\end{equation*}

\begin{thm}
    对于任意 $A : \type$ 和 $B : A \to \type$，类型 $\w_h (A,B)$ 是一个单命题。
\end{thm}

事实证明，所有三个 $\w$-类型的表征实际上是等价的：
\begin{lem}\label{lem:homotopy-induction-times-3}
对于任意 $A : \type$ 和 $B : A \to \type$，我们有
\[ \w_d(A,B) \eqvsym \w_s(A,B) \eqvsym \w_h(A,B) \]
\end{lem}

实际上，我们有以下定理，这比 \cref{thm:w-hinit} 更进一步：

\begin{thm}
    满足 $\w$-类型的构造、引入、消去和命题计算规则的类型正是同伦初始的 $\w$-代数。
\end{thm}

%%%%%
\begin{proof}[证明概述]
%%%%%
    检查 \cref{thm:w-hinit} 的证明，我们发现只需要\emph{命题性}计算规则即可证明 $\wtype{x:A}B(x)$ 的同伦初始性。对于相反的推论，我们假设关联到 $A : \type$ 和 $B : A \to \UU$ 的多项式函子具有一个同伦初始代数 $(W,s_W)$；我们证明 $W$ 满足 $\w$-类型的命题性规则。$\w$-引入规则是简单的；即，对于 $a : A$ 和 $t : B(a) \rightarrow W$，我们定义 $\supp(a,t) : W$ 为将结构映射 $s_W : PW \rightarrow W$ 应用于 $(a,t) : PW$ 的结果。对于 $\w$-消去规则，假设其前提，特别是 $C' : W \to \type$。使用其他前提，可以证明类型 $C \defeq \sm{ w : W} C'(w)$ 可以配备一个结构映射 $s_C : PC \rightarrow C$。通过 $W$ 的同伦初始性，我们获得了一个代数同态 $(f, s_f) : (W, s_W) \rightarrow (C, s_C)$。此外，第一投影 $\proj1 : C \rightarrow W$ 可以配备一个同态的结构，因此我们得到如下形式的图
    \[
        \xymatrix{
            PW \ar[r]^{Pf} \ar[d]_{s_W}  & PC \ar[d]^{s_C}  \ar[r]^{P \proj1}  & PW  \ar[d]^{s_W}  \\
            W \ar[r]_f  & C \ar[r]_{\proj1}  & W.}
    \]
    但是，恒等函数 $1_W : W \rightarrow W$ 有一个代数同态的标准结构，因此，通过 $(W,s_W)$ 到自身的同态类型的可收缩性，复合 $(f,s_f)$ 和 $(\proj1, s_{\proj1})$ 必然存在一个等式证明，并且 $(1_W, s_{1_W})$。这特别意味着存在一个等式证明 $p :  \proj1 \circ f = 1_W$。

    由于 $(\proj2 \circ f) w : C( (\proj1 \circ f) w)$，我们可以定义
    \[
        \rec{}(w,c) \defeq
        p_{\, * \,}( ( \proj2 \circ  f)   w )   : C(w)
    \]
    其中传输 $p_{\, * \,}$ 是相对于家庭
    \[
        \lamu{u}C\circ u : (W\to W)\to W\to \UU。
    \]
    验证命题 $\w$-计算规则是一个计算，涉及形式 $p_{\, * \,}$ 的操作的自然性。
\end{proof}
%%%%%

\index{natural numbers!encoded as a W-type@encoded as a $\w$-type}%
最后，正如所愿，我们可以将同伦自然数编码为同伦 $\w$-类型：

\begin{thm}
    可以从 $\w$-类型的命题计算规则中推导出带有命题计算规则的自然数规则。
\end{thm}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{归纳定义的一般语法 (The general syntax of inductive definitions)}
\label{sec:strictly-positive}

\index{type!inductive|(}%
\indexsee{inductive!type}{type, inductive}%

到目前为止，我们仅讨论了一些特定的归纳类型：$\emptyt$、$\unit$、$\bool$、$\nat$、并积 (coproducts)、积 (products)、$\Sigma$ 类型、$\w$ 类型等。然而，类型论的一个重要方面是能够定义\emph{新的}归纳类型，而不仅仅局限于某些特定的固定列表。然而，为了能够做到这一点，我们需要知道哪些“归纳定义”是有效或合理的。

为了说明不是所有“看起来像归纳定义”的东西都有意义，考虑以下类型 $C$ 的“构造函数”：
\begin{itemize}
    \item $g:(C\to \nat) \to C$。
\end{itemize}
这种类型 $C$ 的递归原则 (recursion principle) 应该说，给定一个类型 $P$，为了构造一个函数 $f:C\to P$，只需考虑当输入 $c:C$ 具有形式 $g(\alpha)$（对于某个 $\alpha:C\to\nat$）的情况。此外，我们希望能够以某种方式使用 $f$ 应用于 $\alpha$ 的“递归数据”。然而，目前尚不清楚如何将 $f$ 应用于 $\alpha$，因为它们都是以 $C$ 为定义域的函数。

我们可以通过假设（不合理地）存在某种方法将 $f$ 应用于 $\alpha$ 并得到一个 $P\to\nat$ 的函数，写下 $C$ 的“递归原则”。然后，递归规则的输入会要求一个类型 $P$，以及一个函数
\begin{equation}
    h:(C\to\nat) \to (P\to\nat) \to P \label{eq:fake-recursor}
\end{equation}
其中 $h$ 的两个参数是 $\alpha$ 和“应用 $f$ 于 $\alpha$ 的结果”。然而，所得函数 $f:C\to P$ 的计算规则会是什么？观察其他计算规则，我们可能期望类似“$f(g(\alpha)) \jdeq h(\alpha,f(\alpha))$”的结果，其中 $\alpha:C\to\nat$，但如我们所见，“$f(\alpha)$”是没有意义的。$C$ 的归纳原则（induction principle）甚至更成问题；如何写出假设都不清楚。

另一方面，我们可以通过忽略 $C$ 在 $\alpha$ 定义域中的“递归”存在，将其视为仅仅是一个自然数族的索引类型，写出 $C$ 的另一个“递归原则”。在这种情况下，输入将要求一个类型 $P$ 以及一个函数
\begin{equation*}
    h:(C\to \nat) \to P，
\end{equation*}
所以递归原则的类型将是 $\rec{C}:\prd{P:\UU} ((C\to \nat) \to P) \to C\to P$，类似地对于归纳原则。现在，可以写出计算规则，即 $\rec{C}(P,h,g(\alpha))\jdeq h(\alpha)$。然而，具有这种递归器和计算规则的类型 $C$ 的存在结果是不一致的。参见 \cref{ex:loop,ex:loop2,ex:inductive-lawvere,ex:ilunit} 的证明和其他变式。

这个例子表明了归纳定义的一个限制：所有构造函数的定义域必须是类型被定义的\emph{协变函子} (covariant functors)\index{functor!covariant}\index{covariant functor}，以便我们可以“将 $f$ 应用于它们”来得到“递归调用”的结果。换句话说，如果我们将正在定义的类型的所有出现替换为一个变量\index{variable!type} $X:\type$，那么每个构造函数的定义域\index{domain!of a constructor}必须是可以作为 $X$ 的协变函子的表达式。这对于我们迄今为止讨论的所有例子都是如此。例如，对于构造函数 $\inl:A\to A+B$，相关的函子恒等于 $A$（即 $X\mapsto A$），而对于构造函数 $\suc:\nat\to\nat$，函子是恒等函子 ($X\mapsto X$)。

然而，这个必要条件仍然不充分。协变性防止了归纳类型出现在其构造函数定义域中的单一函数类型的左边，如上面“构造函数”$g$ 中的参数 $C\to\nat$，因为这会产生一个逆变 (contravariant)\index{functor!contravariant}\index{contravariant functor} 函子，而不是协变的。然而，由于两个逆变函子的复合是协变的，诸如 $((X\to \nat)\to \nat)$ 的双重函数类型又变得协变。这使我们能够重现康托尔式的悖论\index{paradox}。

例如，考虑一个“归纳类型” $D$，其构造函数如下：
\begin{itemize}
    \item $k:((D\to\prop)\to\prop)\to D$。
\end{itemize}
假设存在这样的类型，我们定义函数
\begin{align*}
    r&:D\to (D\to\prop)\to\prop，\\
    f&:(D\to\prop) \to D，\\
    p&:(D\to \prop) \to (D\to\prop)\to \prop，\\
    \intertext{由}
    r(k(\theta)) &\defeq \theta，\\
    f(\delta) &\defeq k(\lam{x} (x=\delta))，\\
    p(\delta) &\defeq \lam{x} \delta(f(x))。
\end{align*}
这里 $r$ 是通过 $D$ 的递归原则定义的，而 $f$ 和 $p$ 是显式定义的。然后，对于任意 $\delta:D\to\prop$，我们有 $r(f(\delta)) = \lam{x}(x=\delta)$。

特别地，因此如果 $f(\delta)=f(\delta')$，那么我们有一个路径 $s:(\lam{x}(x=\delta)) = (\lam{x}(x=\delta'))$。于是，$\happly(s,\delta) : (\delta=\delta) = (\delta=\delta')$，因此特别地 $\delta=\delta'$ 成立。因此，$f$ 是“单射”的（尽管 \emph{a priori} $D$ 可能不是集合）。这听起来已经很可疑了——我们将“幂集”\index{power set}的“注入”到 $D$ 中——并且通过一些额外的工作我们可以将其转化为一个矛盾。

假设给定 $\theta:(D\to\prop)\to\prop$，并通过
\begin{equation}
    \delta(d) \defeq \exis{\gamma:D\to\prop} (f(\gamma) = d) \times \theta(\gamma)。\label{eq:Pinj}
\end{equation}
定义函数 $\delta:D\to\prop$。我们声称 $p(\delta)=\theta$。通过函数外延性 (function extensionality)，只需证明对于任意 $\gamma:D\to\prop$，$p(\delta)(\gamma) =_\prop \theta(\gamma)$。通过一致性，我们只需证明每个都能推出另一个。现在根据 $p$ 的定义，我们有
\begin{align*}
    p(\delta)(\gamma) &\jdeq \delta(f(\gamma))，\\
    &\jdeq \exis{\gamma':D\to\prop} (f(\gamma') = f(\gamma)) \times \theta(\gamma')。
\end{align*}
显然，如果 $\theta(\gamma)$ 成立，则这成立，因为我们可以取 $\gamma'\defeq \gamma$。另一方面，如果我们有 $\gamma'$ 使得 $f(\gamma') = f(\gamma)$ 并且 $\theta(\gamma')$ 成立，则 $\gamma'=\gamma$ 因为 $f$ 是单射的，因此也 $\theta(\gamma)$ 成立。

这完成了证明 $p(\delta)=\theta$。因此，每个元素 $\theta:(D\to\prop)\to\prop$ 都是某个元素 $\delta:D\to\prop$ 的 $p$ 的像。然而，如果我们通过经典的对角线化定义 $\theta$：
\[ \theta(\gamma) \defeq \neg p(\gamma)(\gamma) \quad\text{对于所有 $\gamma:D\to\prop$} \]
那么从 $\theta = p(\delta)$ 我们推导出 $p(\delta)(\delta) = \neg p(\delta)(\delta)$。这是一个矛盾：没有命题可以与其否定相等。（假设 $P\Leftrightarrow \neg P$，如果 $P$，那么 $\neg P$，因此 $\emptyt$；于是 $\neg P$，但然后 $P$，因此 $\emptyt$。）

\begin{rmk}
    这里需要解决一个宇宙大小的问题。一般来说，一个归纳类型必须存在于一个已经包含其定义中所有类型的宇宙中。因此，如果在 $D$ 的定义中，模糊的记号 \prop 表示 $\prop_{\UU}$，那么我们没有 $D:\UU$ 但只有 $D:\UU'$ 对于某个更大的宇宙 $\UU'$ 使得 $\UU:\UU'$。 \index{mathematics!predicative}%
    \indexsee{impredicativity}{mathematics, predicative}%
    \indexsee{predicative mathematics}{mathematics, predicative}%
    在一个前视的理论中，因此~\eqref{eq:Pinj} 的右侧存在于 $\prop_{\UU'}$ 中，而不是 $\prop_\UU$。因此，这一矛盾确实需要命题调整公理 (propositional resizing axiom) \index{propositional!resizing}%
    在 \cref{subsec:prop-subsets} 中提到。
\end{rmk}

\index{consistency}%
这个反例表明我们应该禁止一个归纳类型出现在其构造函数定义域的箭头左边，即使该出现嵌套在其他箭头中，以至于最终成为协变的。这种限制称为\define{严格正性} (strict positivity)\indexdef{strict!positivity}%
\indexsee{positivity, strict}{strict positivity}%
（普通的“正性”本质上是协变性），事实证明这是足够的。

\index{constructor}%
因此，总结而言，一个有效的归纳类型 $W$ 的定义由一个\emph{构造函数}列表组成。每个构造函数都被分配一个类型，该类型是一个函数类型，接受一定数量（可能为零）的输入（可能相互依赖）并返回 $W$ 的元素。最后，我们允许 $W$ 本身出现在其构造函数的输入类型中，但必须严格为正性。这本质上意味着构造函数的每个参数要么是一个不涉及 $W$ 的类型，要么是某种迭代函数类型，其结果类型为 $W$。例如，以下是一个有效的构造函数类型：
\begin{equation}
    c:(A\to W) \to (B\to C \to W) \to D \to W \to W。\label{eq:example-constructor}
\end{equation}
所有这些函数类型也可以是依赖函数 ($\Pi$-types)。%
\footnote{在 \cref{sec:initial-alg} 中的语言中，严格正性确保了相关的自函子是多项式函子。\indexfoot{endofunctor!polynomial}\indexfoot{algebra!initial}\indexsee{algebra!initial}{homotopy-initial} 众所周知，在范畴论中，并非\emph{所有}自函子都可以具有初始代数；限制为多项式函子确保了一致性。
我们可以考虑这种条件的各种放松，但在本书中我们将自己限制在这里定义的严格正性。}

请注意，我们要求归纳定义由一个\emph{有限}的构造函数列表给出。这仅仅是因为我们必须将其写在页面上。如果我们想要一个表现得像是具有无限构造函数的归纳类型，我们可以简单地通过某个无限类型来参数化一个构造函数。例如，类似 $\nat \to W \to W$ 的构造函数可以被视为形式上等价于可数多个形如 $W\to W$ 的构造函数。当然，无限性现在是\emph{内部}的，但这对于任何基础系统都是应有的。同样地，如果我们想要一个构造函数接受“无限多个参数”，我们可以允许它接受由某个无限类型参数化的参数族，例如 $(\nat\to W) \to W$ 接受 $W$ 元素的无限序列\index{sequence}。

\index{recursion principle!for an inductive type}%
现在，一旦我们有了这样的归纳定义，我们可以用它做什么呢？首先，有一个\define{递归原则}，它表明为了定义一个函数 $f:W\to P$，只需考虑当输入 $w:W$ 来源于构造函数之一的情况，并允许我们递归调用该构造函数的输入上的 $f$。对于示例构造函数~\eqref{eq:example-constructor}，我们需要 $P$ 具有类型的函数
\begin{narrowmultline}\label{eq:example-rechyp}
d : (A\to W) \to (A\to P) \to (B\to C\to W) \to
\narrowbreak
(B\to C \to P) \to D \to W \to P \to P。
\end{narrowmultline}
在这些假设下，递归原则产生 $f:W\to P$，而且“显然保留构造函数数据”——这就是计算规则，其中我们使用输入的协变性。
\index{computation rule!for inductive types}%
例如，在示例~\eqref{eq:example-constructor} 中，计算规则表示对于任意 $\alpha:A\to W$、$\beta:B\to C\to W$、$\delta:D$ 和 $\omega:W$，我们有
\begin{equation}
    f(c(\alpha,\beta,\delta,\omega)) \jdeq d(\alpha,f\circ \alpha,\beta, f\circ \beta, \delta, \omega,f(\omega))。\label{eq:example-comp}
\end{equation}
% 如我们之前在特定情况下所见，当定义一个特定函数 $f$ 时，我们可以使用 $\defeq$ 这些规则作为指定数据 $d$ 的方式，并说 $f$ 由它们定义。

\index{induction principle!for an inductive type}%
一般归纳类型 $W$ 的\define{归纳原则}仅稍微复杂一些。当然，我们从一个类型族 $P:W\to\type$ 开始，我们要求该类型族具备构造函数数据，“覆盖” $W$ 的构造函数数据。这意味着递归调用参数如 $A\to P$ 必须被替换为依赖函数，其类型如 $\prd{a:A} P(\alpha(a))$。在~\eqref{eq:example-constructor} 的完整示例中，归纳原则的对应假设要求
\begin{multline}\label{eq:example-indhyp}
d : \prd{\alpha:A\to W}\Parens{\prd{a:A} P(\alpha(a))} \to \narrowbreak
\prd{\beta:B\to C\to W} \Parens{\prd{b:B}{c:C} P(\beta(b,c))} \to\\
\prd{\delta:D}
\prd{\omega:W} P(\omega) \to
P(c(\alpha,\beta,\delta,\omega))。
\end{multline}
对应的计算规则看起来与~\eqref{eq:example-comp} 相同。当然，递归原则是归纳原则的特例，其中 $P$ 是常数族。
如我们之前提到的，归纳原则也被称为\define{消元器} (eliminator)，递归原则被称为\define{非依赖消元器} (non-dependent eliminator)。

如 \cref{sec:pattern-matching} 中所讨论的，我们还允许自己隐式调用归纳和递归原则，为归纳原则的每个假设表达式写一个带有 $\defeq$ 的定义方程。这称为通过（依赖）\define{模式匹配} (pattern matching) 给出定义。
\index{pattern matching}%
\index{definition!by pattern matching}%
在我们的示例中，这意味着我们可以定义 $f:\prd{w:W} P(w) $ 通过
\[ f(c(\alpha,\beta,\delta,\omega)) \defeq \cdots \]
其中 $\alpha:A\to W$ 和 $\beta:B\to C\to W$ 和 $\delta:D$ 和 $\omega:W$ 是变量\index{variable}%
绑定在右侧。此外，右侧可能涉及形式为 $f(\alpha(a))$、$f(\beta(b,c))$ 和 $f(\omega)$ 的递归调用。
当这个定义重新打包为归纳原则时，我们将这些递归调用替换为新变量 $\bar\alpha(a)$、$\bar\beta(b,c)$ 和 $\bar\omega$，其类型分别为
\begin{align*}
    \bar\alpha &: \prd{a:A} P(\alpha(a))，\\
    \bar\beta &: \prd{b:B}{c:C} P(\beta(b,c))，\\
    \bar\omega &: P(\omega)。
\end{align*}
\symlabel{defn:induction-wtype}%
然后我们可以写为
\[ f \defeq \ind{W}(P,\, \lam{\alpha}{\bar\alpha}{\beta}{\bar\beta}{\delta}{\omega}{\bar\omega} \cdots ) \]
其中 $\ind{W}$ 的第二个参数具有~\eqref{eq:example-indhyp} 的类型。

我们不会尝试给出一个有效归纳定义的语法及其结果归纳和递归原则及模式匹配规则的正式表述。尽管可以做到（实际上，如果实现一个计算机证明助理，这是必要的），但并没有提供额外的见解。通过练习，我们可以自动推导出任何归纳定义的归纳和递归原则，并在不加思考的情况下使用它们。

\section{归纳类型的推广 (Generalizations of inductive types)}
\label{sec:generalizations}

\index{type!inductive!generalizations}%
归纳类型的概念在类型论中已经研究多年，并且承认了许多，许多推广：归纳类型族、互递归归纳类型、归纳-归纳类型、归纳-递归类型等。在本节中，我们将概述其中的一些，书中稍后将使用的少数几种。（在 \cref{cha:hits} 中，我们将更深入地研究一种特定于\emph{同伦}类型论的归纳类型的不同推广。）

这些推广中的大多数涉及允许我们同时定义多个类型。我们已经看到的一个非常简单的例子是并积 $A+B$。如果我们每次想考虑两个类型的并积时都要分别写下 $\nat+\nat$、$\nat+\bool$、$\bool+\bool$ 等等的归纳定义，这将是非常乏味的。相反，我们进行一个定义，其中 $A$ 和 $B$ 是代表类型的变量；
\index{variable!type}%
在类型论中，它们被称为\define{参数}。%
\indexdef{parameter!of an inductive definition}
因此，从技术上讲，定义的结果不是单一类型，而是一个类型族 $+ : \type\to\type\to\type$，接受两个类型作为输入并产生它们的并积。类似地，列表类型 $\lst A$ 是一个类型族 $\lst{\blank}:\type\to\type$，其中类型 $A$ 是参数。

在数学中，这种事情显而易见，以至于不值得一提，但我们提到这一点是为了与下一个例子形成对比。请注意，每个类型 $A+B$ 是\emph{独立地}定义的归纳类型，如同每个类型 $\lst A$。%
\index{type!family of!inductive}%
\index{inductive!type family}%
相比之下，我们也可以考虑定义一个整个类型族 $B:A\to\type$，\emph{同时}进行归纳。不同之处在于，现在构造函数可以更改索引 $a:A$，因此我们不能说个别类型 $B(a)$ 是归纳定义的，而只能说整个类型族是归纳定义的。

\index{type!of vectors}%
\index{vector}%
标准的例子是\emph{指定长度的列表类型}，通常称为\define{向量} (vectors)。我们固定一个参数类型 $A$，并定义一个类型族 $\vect n A$，其中 $n:\nat$，其构造函数如下：
\begin{itemize}
    \item 一个长度为零的向量 $\nil:\vect 0 A$，
    \item 一个函数 $\cons:\prd{n:\nat} A\to \vect n A \to \vect{\suc (n)} A$。
\end{itemize}
与列表相比，向量（固定类型 $A$ 的元素）形成一个以其长度为索引的类型族。虽然 $A$ 是一个参数，但我们说 $n:\nat$ 是归纳族的\define{索引}。%
\indexdef{index of an inductive definition}%
一个单独的类型，如 $\vect3A$，不是归纳定义的：构造 $\vect3A$ 元素的构造函数来自于家族中的不同类型，如 $\cons:A \to \vect2A \to \vect3A$。

\index{induction principle!for type of vectors}%
\index{vector!induction principle for}%
特别是，归纳原则必须参考整个类型族；因此，假设和结论必须适当地对索引进行量化。在向量的情况下，归纳原则声明，给定一个类型族 $C:\prd{n:\nat} \vect n A \to \type$，以及
\begin{itemize}
    \item 一个元素 $c_\nil : C(0,\nil)$，和
    \item 一个函数 \narrowequation{c_\cons : \prd{n:\nat}{a:A}{\ell:\vect n A} C(n,\ell) \to C(\suc(n),\cons(a,\ell))}
\end{itemize}
存在一个函数 $f:\prd{n:\nat}{\ell:\vect n A} C(n,\ell)$，使得
\begin{align*}
    f(0,\nil) &\jdeq c_\nil\\
    f(\suc(n),\cons(a,\ell)) &\jdeq c_\cons(n,a,\ell,f(\ell))。
\end{align*}

\index{predicate!inductive}%
\index{inductive!predicate}%
归纳族的一个用途是\emph{归纳定义谓词}。例如，我们可以定义谓词 $\mathsf{iseven}:\nat\to\type$ 作为归纳族，索引为 $\nat$，其构造函数如下：
\begin{itemize}
    \item 一个元素 $\mathsf{even}_0 : \mathsf{iseven}(0)$，
    \item 一个函数 $\mathsf{even}_{ss} : \prd{n:\nat} \mathsf{iseven}(n) \to \mathsf{iseven}(\suc(\suc(n)))$。
\end{itemize}
换句话说，我们规定 $0$ 是偶数，并且如果 $n$ 是偶数，那么 $\suc(\suc(n))$ 也是偶数。这些构造函数显然不会构造出 $\mathsf{iseven}(1)$ 的元素，并且由于 $\mathsf{iseven}$ 应该由这些构造函数自由生成，因此不应有这样的元素。（然而，实际证明 $\neg \mathsf{iseven}(1)$ 并非完全平凡）。$\mathsf{iseven}$ 的归纳原则表明，为了证明关于所有偶数自然数的某些性质，只需证明它对 $0$ 成立并验证其在加二时保持不变。

\index{mathematics!formalized}%
归纳定义的谓词在计算机形式化数学和软件验证中得到广泛使用。但在本书中，我们不会有太多的使用，除了 \cref{sec:ordinals,sec:compactness-interval} 中的几个例外。

\index{type!mutual inductive}%
\index{mutual inductive type}%
另一个重要的特例是当归纳族的索引类型是有限的。在这种情况下，我们可以等价地将归纳定义表达为通过\emph{相互归纳} (mutual induction) 定义的一组有限类型。例如，我们可以通过相互归纳定义 $\mathsf{even}$ 和 $\mathsf{odd}$ 类型，其中 $\mathsf{even}$ 由构造函数生成：
\begin{itemize}
    \item $0:\mathsf{even}$，和
    \item $\mathsf{esucc} : \mathsf{odd}\to\mathsf{even}$，
\end{itemize}
而 $\mathsf{odd}$ 由一个构造函数生成
\begin{itemize}
    \item $\mathsf{osucc} : \mathsf{even}\to \mathsf{odd}$。
\end{itemize}
请注意，$\mathsf{even}$ 和 $\mathsf{odd}$ 是简单类型（不是类型族），但它们的构造函数可以相互引用。如果我们将此定义表示为一个归纳类型族 $\mathsf{paritynat} : \bool \to \type$，其中 $\mathsf{paritynat}(\bfalse)$ 和 $\mathsf{paritynat}(\btrue)$ 分别表示 $\mathsf{even}$ 和 $\mathsf{odd}$，那么它将具有以下构造函数：
\begin{itemize}
    \item $0 : \mathsf{paritynat}(\bfalse)$，
    \item $\mathsf{esucc} : \mathsf{paritynat}(\btrue) \to \mathsf{paritynat}(\bfalse)$，
    \item $\mathsf{osucc} : \mathsf{paritynat}(\bfalse) \to \mathsf{paritynat}(\btrue)$。
\end{itemize}
当明确表示为相互归纳定义时，$\mathsf{even}$ 和 $\mathsf{odd}$ 的归纳原则表明，给定 $C:\mathsf{even}\to\type$ 和 $D:\mathsf{odd}\to\type$，以及
\begin{itemize}
    \item $c_0 : C(0)$，
    \item $c_s : \prd{n:\mathsf{odd}} D(n) \to C(\mathsf{esucc}(n))$，
    \item $d_s : \prd{n:\mathsf{even}} C(n) \to D(\mathsf{osucc}(n))$，
\end{itemize}
存在 $f:\prd{n:\mathsf{even}} C(n)$ 和 $g:\prd{n:\mathsf{odd}}D(n)$，使得
\begin{align*}
    f(0) &\jdeq c_0\\
    f(\mathsf{esucc}(n)) &\jdeq c_s(g(n))\\
    g(\mathsf{osucc}(n)) &\jdeq d_s(f(n))。
\end{align*}
特别是，正如我们只能“同时”对归纳族进行归纳一样，我们必须同时对 $\mathsf{even}$ 和 $\mathsf{odd}$ 进行归纳。在本书中，我们也不会有太多对相互归纳定义的使用。

\index{type!inductive-inductive}%
\index{inductive-inductive type}%
进一步的、更激进的推广是允许定义一个类型族 $B:A\to \type$，其中不仅 $B(a)$ 的类型被定义，类型 $A$ 本身也是作为一个整体通过归纳定义的。换句话说，我们不仅为 $B(a)$ 指定了构造函数，也同时为 $A$ 本身指定了构造函数，后者可以引用 $B(a)$ 的元素。这可以看作是一个归纳族，其中索引与被索引的类型同时被归纳定义，或者作为一个类型依赖于另一个类型的相互归纳定义。更复杂的依赖结构也是可能的。一般来说，这些称为\define{归纳-归纳定义} (inductive-inductive definitions)。在本书中，我们不会使用它们，但其更高的变体（见 \cref{cha:hits}）将在 \cref{cha:real-numbers} 的几个实验性示例中出现。

\index{type!inductive-recursive}%
\index{inductive-recursive type}%
最后一个要提到的推广是\define{归纳-递归定义} (inductive-recursive definitions)，其中一个类型和一个\emph{递归}函数同时被定义。也就是说，我们固定一个已知类型 $P$，并给出一个归纳类型 $A$ 的构造函数，同时使用 $A$ 的递归原则定义一个函数 $f:A\to P$——其中的转折点是，$A$ 的构造函数也被允许引用 $f$ 的值。我们尚不知道如何从同伦的角度来证明这种定义的合理性，因此在本书中我们不会使用它们。

\index{type!inductive|)}%
\section{同一性类型与同一性系统 (Identity types and identity systems)}
\label{sec:identity-systems}

\index{type!identity!as inductive}%
我们现在希望指出，在同伦类型论中起着核心作用的\emph{同一性类型} (identity types) 也可以被认为是归纳地定义的。具体来说，它们是具有索引的“归纳族”，如 \cref{sec:generalizations} 中所述。事实上，有\emph{两种}方式将同一性类型描述为归纳族，导致了 \cref{cha:typetheory} 中描述的两种归纳原则，即路径归纳 (path induction) 和基于路径的归纳 (based path induction)。

在这两种定义中，类型 $A$ 是一个参数。在第一个定义中，我们通过以下构造函数归纳地定义了一个族 $=_A : A\to A\to \type$，其两个索引属于 $A$：
\begin{itemize}
    \item 对于任何 $a:A$，有一个元素 $\refl a : a=_A a$。
\end{itemize}
通过类比其他归纳族，我们可以从这个定义中提取出归纳原则。它声明给定任何 \narrowequation{C:\prd{a,b:A} (a=_A b) \to \type,} 以及 $d:\prd{a:A} C(a,a,\refl{a})$，存在 \narrowequation{f:\prd{a,b:A}{p:a=_A b} C(a,b,p)} 使得 $f(a,a,\refl a)\jdeq d(a)$。这正是同一性类型的路径归纳原则。

对于第二个定义，我们考虑一个元素 $a_0:A$ 作为参数，以及 $A:\type$，并通过以下构造函数归纳地定义了一个族 $(a_0 =_A \blank):A\to \type$，其\emph{一个}索引属于 $A$：
\begin{itemize}
    \item 一个元素 $\refl{a_0} : a_0 =_A a_0$。
\end{itemize}
注意，由于 $a_0:A$ 被固定为一个参数，构造函数 $\refl{a_0}$ 并没有作为一个函数出现在归纳定义中，而只是作为一个元素出现。这个定义的归纳原则表明，给定 $C:\prd{b:A} (a_0 =_A b) \to \type$ 以及一个元素 $d:C(a_0,\refl{a_0})$，存在 $f:\prd{b:A}{p:a_0 =_A b} C(b,p)$ 使得 $f(a_0,\refl{a_0})\jdeq d$。这正是同一性类型的基于路径的归纳原则。

将同一性类型视为归纳类型的观点历史上曾引起一些混淆，因为如 \cref{sec:bool-nat} 中提到的直觉认为，归纳类型的所有元素都应该通过反复应用其构造函数获得。对于普通的归纳类型，如 \bool 和 \nat，确实如此：我们在 \cref{thm:allbool-trueorfalse} 中看到，\bool 的每个元素要么是 $\bfalse$，要么是 $\btrue$，同样可以证明 \nat 的每个元素要么是 $0$，要么是继承者 (successor)。

然而，这对于同一性类型来说并不是真的：虽然只有一个构造函数 $\refl{}$，但并非每个路径都等同于常量路径。更确切地说，我们不能仅通过使用同一性类型的归纳原则（无论是哪一种）来证明 $a=_A a$ 的每个居住者都等于 $\refl a$。为了真正展示一个反例，我们需要一些额外的原则，比如同值性公理 (univalence axiom)——回想一下在 \cref{thm:type-is-not-a-set} 中，我们使用同值性展示了一个特定的路径 $\bool=_\type\bool$，它并不等于 $\refl{\bool}$。

\index{free!generation of an inductive type}%
\index{generation!of a type, inductive|(}%
关键是，正如同伦初始代数的研究所验证的那样，一个归纳定义应该被视为由其构造函数\emph{自由生成}的。当然，自由生成的结构可能包含其生成器之外的元素：例如，由两个符号 $x$ 和 $y$ 自由生成的自由群 (free group) 不仅包含 $x$ 和 $y$，还包含诸如 $xy$、$yx^{-1}y$ 和 $x^3y^2x^{-2}yx$ 之类的词语。一般来说，自由结构的元素是通过应用不仅是生成器，还有环境结构的操作（如果我们谈论自由群，则是群操作）获得的。

在归纳类型的情况下，我们谈论的是自由生成的\emph{类型}——那么，类型结构的“操作”是什么呢？如果类型被视为类似于\emph{集合}，正如传统上在类型论中所做的那样，那么就没有这样的操作，因此我们期望在归纳类型中没有其他元素，除了由其构造函数生成的那些元素。在同伦类型论中，我们将类型视为类似于\emph{空间}或$\infty$-群体 (spaces or $\infty$-groupoids) ，%
\index{.infinity-groupoid@$\infty$-groupoid}
在这种情况下，有许多关于\emph{路径}的操作（如连接、逆等）——这将在 \cref{cha:hits} 中变得重要——但在\emph{对象}（元素）上仍然没有操作。因此，对于我们来说，例如，\bool 的每个元素要么是 $\bfalse$，要么是 $\btrue$，而 $\nat$ 的每个元素要么是 $0$，要么是继承者，这仍然是正确的。

然而，正如我们在 \cref{cha:basics} 中看到的，将类型视为$\infty$-群体也意味着将函数视为函子，这包括类型族 $B:A\to\type$。因此，视为归纳类型族的同一性类型 $(a_0 =_A \blank)$ 实际上是一个\emph{自由生成的函子} $A\to\type$。具体来说，它是由一个元素 $\refl{a_0}: F(a_0)$ 自由生成的函子 $F:A\to\type$。一个函子确实对对象有操作，即 $A$ 的态射（路径）的作用。

在范畴论中，\emph{约内达引理} (Yoneda lemma) 告诉我们，对于任何范畴 $A$ 和对象 $a_0$，由 $F(a_0)$ 的一个元素自由生成的函子是可表函子 (representable functor) $\hom_A(a_0,\blank)$。因此，我们应该期望同一性类型 $(a_0 =_A \blank)$ 是这个可表函子，这实际上正是我们看待它的方式：$(a_0 =_A b)$ 是从 $a_0$ 到 $b$ 的 $A$ 中的态射（路径）的空间。

\index{generation!of a type, inductive|)}

\mentalpause

将同一性类型视为归纳族的一个原因是应用 \cref{sec:appetizer-univalence,sec:htpy-inductive} 中的唯一性原则。具体来说，我们可以通过给出另一个在 $A\times A$ 上满足相同归纳原则的类型族，来刻画同一性类型 $A$ 的家族（up to equivalence）。这表明了以下定义和定理。

\indexsee{system, identity}{identity system}%
\index{identity!system!at a point|(defstyle}%

\begin{defn}\label{defn:identity-systems}
设 $A$ 是一个类型，$a_0:A$ 是一个元素。
\begin{itemize}
    \item 一个 \define{带点谓词} (pointed predicate)
    \indexdef{predicate!pointed}%
    \indexdef{pointed!predicate}%
    在 $(A,a_0)$ 上是一个带有元素 $r_0:R(a_0)$ 的族 $R:A\to\type$。
    \item 对于带点谓词 $(R,r_0)$ 和 $(S,s_0)$，如果映射族 $g:\prd{b:A} R(b) \to S(b)$ 满足 $g(a_0, r_0)=s_0$，则称其为\define{带点的} (pointed)。我们有
    \[ \mathsf{ppmap}(R,S) \defeq \sm{g:\prd{b:A} R(b) \to S(b)} (g(a_0, r_0)=s_0)。\]
    \item 在 $a_0$ 处的\define{同一性系统} (identity system)
    是一个带点谓词 $(R,r_0)$，满足对于任何类型族 $D:\prd{b:A} R(b) \to \type$ 和 $d:D(a_0,r_0)$，存在函数 $f:\prd{b:A}{r:R(b)} D(b,r)$ 使得 $f(a_0,r_0)=d$。
\end{itemize}
\end{defn}

\begin{thm}\label{thm:identity-systems}
对于 $(A,a_0)$ 上的带点谓词 $(R,r_0)$，以下条件逻辑等价：
\begin{enumerate}
    \item $(R,r_0)$ 在 $a_0$ 处是一个同一性系统。\label{item:identity-systems1}
    \item 对于任何带点谓词 $(S,s_0)$，类型 $\mathsf{ppmap}(R,S)$ 是收缩的。\label{item:identity-systems2}
    \item 对于任何 $b:A$，映射 $\transfib{R}{\blank}{r_0} : (a_0 =_A b) \to R(b)$ 是等价的。\label{item:identity-systems3}
    \item 类型 $\sm{b:A} R(b)$ 是收缩的。\label{item:identity-systems4}
\end{enumerate}
\end{thm}

注意，等价~\ref{item:identity-systems1}$\Leftrightarrow$\ref{item:identity-systems2}$\Leftrightarrow$\ref{item:identity-systems3} 是同一性类型 $a_0 =_A \blank$ 作为一个在 $A$ 的一个元素上变化的归纳族的 \cref{lem:homotopy-induction-times-3} 的版本。当然，~\ref{item:identity-systems2}--\ref{item:identity-systems4} 是单纯命题，因此逻辑等价意味着实际等价。（条件~\ref{item:identity-systems1} 也是单纯命题，但我们不会证明这一点。）还要注意，与~\ref{item:identity-systems1}--\ref{item:identity-systems3} 不同，陈述~\ref{item:identity-systems4} 没有提到 $a_0$ 或 $r_0$。

\begin{proof}
    首先，假设~\ref{item:identity-systems1} 并设 $(S,s_0)$ 是一个带点谓词。定义 $D(b,r) \defeq S(b)$ 并设 $d\defeq s_0: S(a_0) \jdeq D(a_0,r_0)$。由于 $R$ 是一个同一性系统，我们有 $f:\prd{b:A} R(b) \to S(b)$ 使得 $f(a_0,r_0) = s_0$；因此 $\mathsf{ppmap}(R,S)$ 是居住的。现在假设 $(f,f_r),(g,g_r) : \mathsf{ppmap}(R,S)$，并定义 $D(b,r) \defeq (f(b,r) = g(b,r))$，并设 $d \defeq f_r \ct \opp{g_r} : f(a_0,r_0) = s_0 = g(a_0,r_0)$。然后，由于 $R$ 是一个同一性系统，我们有 $h:\prd{b:A}{r:R(b)} D(b,r)$ 使得 $h(a_0,r_0) = f_r \ct \opp{g_r}$。通过函数外延性和在 $\Sigma$-类型和路径类型中的路径的特性，这些数据产生了一个等式 $(f,f_r) = (g,g_r)$。因此 $\mathsf{ppmap}(R,S)$ 是一个居住的单纯命题，因此是收缩的；所以~\ref{item:identity-systems2} 成立。

    现在假设~\ref{item:identity-systems2}，并定义 $S(b) \defeq (a_0=b)$，$s_0 \defeq \refl{a_0}:S(a_0)$。然后 $(S,s_0)$ 是一个带点谓词，$\lamu{b:B}{p:a_0=b} \transfib{R}{p}{r} : \prd{b:A} S(b) \to R(b)$ 是一个从 $S$ 到 $R$ 的带点映射族。根据假设，$\mathsf{ppmap}(R,S)$ 是收缩的，因此是居住的，因此也存在从 $R$ 到 $S$ 的带点映射族。并且在任何一个方向上的复合都是从 $R$ 到 $R$ 和从 $S$ 到 $S$ 的带点映射族，因此等同于身份，因为 $\mathsf{ppmap}(R,R)$ 和 $\mathsf{ppmap}(S,S)$ 是收缩的。因此~\ref{item:identity-systems3} 成立。

    现在假设~\ref{item:identity-systems3}，条件~\ref{item:identity-systems4} 可由 \cref{thm:contr-paths} 得出，使用的是 $\Sigma$-类型尊重等价的事实（\cref{thm:total-fiber-equiv} 的“如果”方向）。

    最后，假设~\ref{item:identity-systems4}，并设 $D:\prd{b:A} R(b)\to  \type$ 和 $d:D(a_0,r_0)$。我们可以等价地将 $D$ 表示为一个族 $D':(\sm{b:A} R(b)) \to \type$。现在，由于 $\sm{b:A} R(b)$ 是收缩的，我们有
    \[p:\prd{u:\sm{b:A} R(b)} (a_0,r_0) = u. \]
    此外，由于收缩类型的路径类型再次收缩，我们有 $p((a_0,r_0)) = \refl{(a_0,r_0)}$。定义 $f(u) \defeq \transfib{D'}{p(u)}{d}$，得到 $f:\prd{u:\sm{b:A} R(b)} D'(u)$，或等价地 $f:\prd{b:A}{r:R(b)} D(b,r)$。最后，我们有
    \[f(a_0,r_0) \jdeq \transfib{D'}{p((a_0,r_0))}{d} = \transfib{D'}{\refl{(a_0,r_0)}}{d} = d。\]
    因此，~\ref{item:identity-systems1} 成立。
\end{proof}

\index{identity!system!at a point|)}%

我们可以推导出类似的结果，用于同一性类型 $=_A$，将其视为一个在 $A$ 的两个元素上变化的族。

\index{identity!system|(defstyle}%

\begin{defn}
    在一个类型 $A$ 上的\define{同一性系统}
    是一个族 $R:A\to A\to \type$，带有一个函数 $r_0:\prd{a:A} R(a,a)$，使得对于任何类型族 $D:\prd{a,b:A} R(a,b) \to \type$ 和 $d:\prd{a:A} D(a,a,r_0(a))$，存在函数 $f:\prd{a,b:A}{r:R(a,b)} D(a,b,r)$ 使得 $f(a,a,r_0(a))=d(a)$ 对所有 $a:A$ 成立。
\end{defn}

\begin{thm}\label{thm:ML-identity-systems}
对于 $R:A\to A\to\type$ 带有 $r_0:\prd{a:A} R(a,a)$，以下条件逻辑等价：
\begin{enumerate}
    \item $(R,r_0)$ 在 $A$ 上是一个同一性系统。\label{item:MLis1}
    \item 对于所有 $a_0:A$，带点谓词 $(R(a_0),r_0(a_0))$ 是在 $a_0$ 处的同一性系统。\label{item:MLis2}
    \item 对于任何 $S:A\to A\to\type$ 和 $s_0:\prd{a:A} S(a,a)$，类型
    \[ \sm{g:\prd{a,b:A} R(a,b) \to S(a,b)} \prd{a:A} g(a,a,r_0(a)) = s_0(a) \]
    是收缩的。\label{item:MLis3}
    \item 对于任何 $a,b:A$，映射 $\transfib{R(a)}{\blank}{r_0(a)} : (a =_A b) \to R(a,b)$ 是等价的。\label{item:MLis4}
    \item 对于任何 $a:A$，类型 $\sm{b:A} R(a,b)$ 是收缩的。\label{item:MLis5}
\end{enumerate}
\end{thm}
\begin{proof}
    等价~\ref{item:MLis1}$\Leftrightarrow$\ref{item:MLis2} 完全按照同一性类型的路径归纳原则和基于路径的归纳原则的等价性证明；参见 \cref{sec:identity-types}。然后，等价于~\ref{item:MLis4} 和~\ref{item:MLis5} 来自 \cref{thm:identity-systems}，而~\ref{item:MLis3} 是直接的。
\end{proof}

\index{identity!system|)}%

这个特征描述之所以有趣的原因之一是它提供了一种陈述同值性和函数外延性的替代方式。
\index{univalence axiom}%
对于宇宙 \UU 的同值性公理 (univalence axiom) 表示类型族
\[ (\eqv{\blank}{\blank}) : \UU\to\UU\to\UU \]
连同 $\idfunc : \prd{A:\UU} (\eqv AA)$ 满足 \cref{thm:ML-identity-systems}\ref{item:MLis4}。因此，它等价于相应的~\ref{item:MLis1} 版本，我们可以将其陈述如下。

\begin{cor}[等价归纳 (Equivalence induction)]\label{thm:equiv-induction}
\index{induction principle!for equivalences}%
\index{equivalence!induction}%
给定任何类型族 \narrowequation{D:\prd{A,B:\UU} (\eqv AB) \to \type} 和函数 $d:\prd{A:\UU} D(A,A,\idfunc[A])$，存在 \narrowequation{f : \prd{A,B:\UU}{e:\eqv AB} D(A,B,e)} 使得对于所有 $A:\UU$，$f(A,A,\idfunc[A]) = d(A)$。
\end{cor}

换句话说，要证明关于所有等价的某些东西，仅需证明关于身份映射的某些东西。我们已经在 \cref{lem:qinv-autohtpy} 中使用了这一原理（没有以普遍性陈述它）。

类似地，函数外延性表明，对于任何 $B:A\to\type$，类型族
\[ (\blank\htpy\blank) : \Parens{\prd{a:A} B(a)} \to \Parens{\prd{a:A} B(a)} \to \type
\]
连同 $\lamu{f:\prd{a:A} B(a)}{a:A} \refl{f(a)}$ 满足 \cref{thm:ML-identity-systems}\ref{item:MLis4}。因此，它也等价于相应的~\ref{item:MLis1} 版本。

\begin{cor}[同伦归纳 (Homotopy induction)]\label{thm:htpy-induction}
\index{induction principle!for homotopies}%
\index{homotopy!induction}%
给定任何 \narrowequation{D:\prd{f,g:\prd{a:A} B(a)} (f\htpy g) \to \type} 和 $d:\prd{f:\prd{a:A} B(a)} D(f,f,\lam{x}\refl{f(x)})$，存在
%
\begin{equation*}
    k:\prd{f,g:\prd{a:A} B(a)}{h:f\htpy g} D(f,g,h)
\end{equation*}
%
使得 $k(f,f,\lam{x}\refl{f(x)}) = d(f)$ 对所有 $f$ 成立。
\end{cor}

\sectionNotes

归纳定义在数学中有着悠久的历史，可以追溯到弗雷格 (Frege) 和皮亚诺 (Peano) 的自然数公理。\index{Frege}\index{Peano} %
更一般的“归纳谓词”并不罕见，但在集合论基础中，它们通常是显式构造的，或者作为适当类子集的交集，或者使用沿序数的超限迭代，而不是作为基本概念。

在类型论中，归纳定义的特殊情况可以追溯到 Martin-Löf 的原始论文：\cite{martin-lof-hauptsatz} 提出了归纳定义的谓词和关系的一般概念；归纳类型的概念（但仅有实例，而不是作为一般概念）出现在 Martin-Löf 的第一篇类型论论文中 \cite{Martin-Lof-1973}；然后作为一个普遍概念出现在 \cite{Martin-Lof-1979} 中。\index{Martin-Löf}%

归纳类型的一般概念由 Constable 和 Mendler 于 1985 年引入~\cite{DBLP:conf/lop/ConstableM85}。在强类型论中归纳类型的一般模式由 \cite{PfenningPaulinMohring} 提出。后续发展包括 \cite{CoquandPaulin, Dybjer:1991}。

归纳-递归 (inductive-recursive) 定义的概念出现在 \cite{Dybjer:2000} 中。一个重要的类型论概念是树类型 (tree types) 的概念（在类型论中 Post 系统概念的通用表达），它出现在 \cite{PeterssonSynek} 中。

自然数的普遍性质作为 $\nat$-代数范畴中的初始对象 (initial object) 由 Lawvere 提出 \cite{lawvere:adjinfound}。\index{Lawvere} 这后来被推广为 $\w$-类型作为多项式端函子 (polynomial endofunctors) 的初始代数的描述，由~\cite{mp:wftrees} 提出。\index{endofunctor!algebra for} 此类普遍性质与相应归纳原则（\cref{sec:initial-alg,sec:htpy-inductive}）之间的同伦-同调论等价由~\cite{ags:it-hott} 提出。

有关在类型论的同伦-同调论语义中的归纳类型的实际构造，请参见~\cite{klv:ssetmodel,mvdb:wtypes,ls:hits}。

\sectionExercises

\begin{ex}\label{ex:ind-lst}
从 \cref{sec:bool-nat} 中 $\lst{A}$ 作为归纳类型的定义中推导出类型 $\lst{A}$ 的归纳原则。\index{type!of lists}
\end{ex}

\begin{ex}\label{ex:same-recurrence-not-defeq}
构造两个在自然数上满足相同递归 (recurrence) $(e_z, e_s)$ 的函数，但它们不完全相等。
\end{ex}

\begin{ex}\label{ex:one-function-two-recurrences}
构造两个在相同类型 $E$ 上的不同递归 $(e_z,e_s)$，它们都在相同函数 $f:\nat\to E$ 上判断成立。
\end{ex}

\begin{ex}\label{ex:bool}
证明对于任何类型族 $E : \bool \to \type$，归纳算子
\[ \ind{\bool}(E) : \big(E(\bfalse) \times E(\btrue)\big) \to \prd{b : \bool} E(b) \]
是一个等价。
\end{ex}

\begin{ex}\label{ex:ind-nat-not-equiv}
证明对于 $\nat$ 的类似陈述与 \cref{ex:bool} 不成立。
\end{ex}

\begin{ex}\label{ex:no-dep-uniqueness-failure}
证明如果我们假设 $\w$-类型的简单而不是依赖消去 (elimination)，则唯一性属性（\cref{thm:w-uniq} 的类似物）不成立。也就是说，展示一个满足 $\w$-类型递归原则的类型，但其函数不唯一地由其递归确定。\index{recurrence}
\end{ex}

\begin{ex}\label{ex:loop}
假设在 \cref{sec:strictly-positive} 开头的类型 $C$ 的“归纳定义”中，我们用 \emptyt 替换 \nat。类似于~\eqref{eq:fake-recursor}，我们可能会考虑带有假设的这个类型的递归原则
\[ h:(C\to\emptyt) \to (P\to\emptyt) \to P. \]
证明即使没有计算规则，这个递归原则也是不一致的，即它允许我们构造 \emptyt 的一个元素。
\end{ex}

\begin{ex}\label{ex:loop2}
现在考虑一个具有构造函数 $\mathsf{scott}:(D\to D) \to D$ 的“归纳类型” $D$。
\index{Scott}%
\cref{sec:strictly-positive} 中建议的 $C$ 的第二递归算子导致 $D$ 的以下递归算子：
\[ \rec{D} : \prd{P:\UU} ((D\to D) \to (D\to P)\to P) \to D \to P \]
其计算规则为 $\rec{D}(P,h,\mathsf{scott}(\alpha)) \jdeq h(\alpha,(\lam{d} \rec{D}(P,h,\alpha(d))))$。
证明这也导致矛盾。
\end{ex}

\begin{ex}\label{ex:inductive-lawvere}
设 $A$ 是一个任意类型，并且一般地考虑具有构造函数 $\mathsf{lawvere}:(L_A\to A) \to L_A$ 的类型 $L_A$ 的“归纳定义”。\cref{sec:strictly-positive} 中建议的 $C$ 的第二递归算子导致 $L_A$ 的以下递归算子：
\[ \rec{L_A} : \prd{P:\UU} ((L_A\to A) \to P) \to L_A\to P \]
其计算规则为 $\rec{L_A}(P,h,\mathsf{lawvere}(\alpha)) \jdeq h(\alpha)$。
使用这个证明 $A$ 具有\define{不动点属性} (fixed-point property)，即对于每个函数 $f:A\to A$，存在一个 $a:A$ 使得 $f(a)=a$。
\index{Lawvere}%
\index{fixed-point property}%
特别地，如果 $A$ 是一个没有不动点属性的类型（例如 \emptyt、\bool 或 \nat），则 $L_A$ 是不一致的。
\end{ex}

\begin{ex}\label{ex:ilunit}
继续 \cref{ex:inductive-lawvere}，考虑 $L_\unit$，它显然没有不一致，因为 $\unit$ 确实具有不动点属性。制定 $L_\unit$ 的归纳原则及其计算规则，类似于其递归算子，并使用它证明它是收缩的。
\end{ex}

\begin{ex}\label{ex:empty-inductive-type}
在 \cref{sec:bool-nat} 中我们定义了类型 $\lst A$，表示类型 $A$ 的有限列表。考虑类似的归纳定义类型 $\lost A$，其唯一构造函数为
\[ \cons: A \to \lost A \to \lost A. \]
证明 $\lost A$ 等价于 \emptyt。
\end{ex}

\begin{ex}\label{ex:Wprop}
假设 $A$ 是一个单纯命题，并且 $B:A\to \UU$。
\begin{enumerate}
    \item 证明 $\wtype{a:A} B(a)$ 是一个单纯命题。
    \item 证明 $\wtype{a:A} B(a)$ 等价于 $\sm{a:A} \neg B(a)$。
    \item 不使用 $\wtype{a:A} B(a)$，证明 $\sm{a:A} \neg B(a)$ 是 \cref{sec:htpy-inductive} 意义上的同伦 $\w$-类型 $\wtypeh{a:A} B(a)$。
\end{enumerate}
\end{ex}

\begin{ex}\label{ex:Wbounds}
设 $A:\UU$ 并且 $B:A\to \UU$。
\begin{enumerate}
    \item 证明 $\Parens{\sm{a:A} \neg B(a)} \to \Parens{\wtype{a:A} B(a)}$。
    \item 证明 $\Parens{\wtype{a:A} B(a)} \to \Parens{\neg \prd{a:A} B(a)}$。
\end{enumerate}
\end{ex}

\begin{ex}\label{ex:Wdec}
设 $A:\UU$ 并假设 $B:A\to \UU$ 是可判定的，即 $\prd{a:A} (B(a)+\neg B(a))$（参见 \cref{defn:decidable-equality}）。
证明 $\Parens{\wtype{a:A} B(a)} \to \Parens{\sm{a:A} \neg B(a)}$。
\end{ex}

\begin{ex}\label{ex:Wbounds-loose}
证明以下条件逻辑等价。
\begin{enumerate}
    \item 对于任何 $A:\set$ 和 $B:A\to \prop$，$\Parens{\wtype{a:A} B(a)} \to \Brck{\sm{a:A} \neg B(a)}$。\label{item:Wbounds-loose-Sigma}
    \item 对于任何 $A:\set$ 和 $B:A\to \prop$，$\Parens{\neg \prd{a:A} B(a)} \to \Brck{\wtype{a:A} B(a)}$。\label{item:Wbounds-loose-Pi}
    \item 排中律（如 \cref{sec:intuitionism} 中所述）。
\end{enumerate}
同样，使用 \cref{thm:not-lem}，证明假设任何~\ref{item:Wbounds-loose-Sigma} 或~\ref{item:Wbounds-loose-Pi} 条件在所有 $A:\UU$ 和 $B:A\to \UU$ 上成立是不一致的。
\end{ex}

\begin{ex}\label{ex:Wimpred}
对于 $A:\UU$ 和 $B:A\to \UU$，定义
\[ W'_{A,B} \defeq \prd{R:\UU} \Parens{\prd{a:A} (B(a) \to R) \to R} \to R \]
$W'_{A,B}$ 被称为 \define{$\wtype{a:A} B(a)$ 的非限制性编码 (impredicative encoding)}。
\index{impredicative!encoding of a W-type@encoding of a $\w$-type}%
\index{W-type@$\w$-type!impredicative encoding of}%
注意，与 $\wtype{a:A} B(a)$ 不同，它存在于高于 $A$ 和 $B$ 的宇宙中。
\begin{enumerate}
    \item 证明 $W'_{A,B}$ 在逻辑上等价（如 \cref{sec:pat} 中定义）于 $\wtype{a:A} B(a)$。
    \item 证明 $W'_{A,B}$ 意味着 $\neg\neg \sm{a:A} \neg B(a)$。
    \item 不使用 $\wtype{a:A} B(a)$，证明 $W'_{A,B}$ 满足与 $\wtype{a:A} B(a)$ 相同的\emph{递归}原则，用于定义进入宇宙 $\UU$ 的类型的函数（它本身不属于其中）。
    \item 使用 \LEM，举一个 $A:\UU$ 和 $B:A\to \UU$ 的例子，使得 $W'_{A,B}$ 不等同于 $\wtype{a:A} B(a)$。
\end{enumerate}
\end{ex}

\begin{ex}\label{ex:no-nullary-constructor}
证明对于任何 $A:\UU$ 和 $B:A\to\UU$，我们有
\[ \eqv{\neg\Parens{\wtype{a:A} B(a)}}{\neg\Parens{\sm{a:A} \neg B(a)}}。 \]
换句话说，$\wtype{a:A} B(a)$ 是空的，当且仅当它没有空构造函数 (nullary constructor)。（比较 \cref{ex:empty-inductive-type}。）
\end{ex}

% Local Variables:
% TeX-master: "hott-online"
% End:

