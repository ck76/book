\chapter{类型论 (Type theory)}
\label{cha:typetheory}

\section{类型论与集合论 (Type theory versus set theory)}
\label{sec:types-vs-sets}
\label{sec:axioms}

\index{type theory|类型论}
同伦类型论 (Homotopy type theory) 是数学的基础语言之一，即作为 Zermelo–Fraenkel 集合论\index{set theory!Zermelo–Fraenkel|集合论!策梅洛–弗兰克尔}的替代品。然而，它在几个重要方面与集合论的行为有所不同，这可能需要一些时间来适应。在这里详细解释这些差异要求我们比在本书的其他部分更正式。如在引言中所述，我们的目标是非正式地书写类型论；但是对于习惯于集合论的数学家来说，起初更加精确可以帮助避免一些常见的误解和错误。

我们注意到，基于集合论的基础有两个“层次”：第一个层次是一阶逻辑的演绎系统\index{first-order!logic|一阶!逻辑}，第二个层次是在该系统内部制定的特定理论的公理，比如 ZFC。因此，集合论不仅仅是关于集合，而是关于集合（第二层次的对象）和命题（第一层次的对象）之间的相互作用。

相比之下，类型论是它自己的演绎系统：它不需要在任何超结构如一阶逻辑中制定。相反，类型论只有一个基本概念：\emph{类型 (types)}。命题（我们可以证明、反驳、假设、否定等的陈述\footnote{令人困惑的是，使用“命题 (proposition)”一词作为“定理 (theorem)”的同义词也是一种常见的做法。这种做法可以追溯到欧几里得。我们将自己限定在逻辑学家的用法中，按照这种用法，\emph{命题} 是一种\emph{可以}被证明的陈述，而\emph{定理}\index{theorem|定理}（或“引理 (lemma)”\index{lemma|引理}或“推论 (corollary)”\index{corollary|推论}）是\emph{已经}被证明的陈述。因此，“$0=1$”及其否定“$\neg(0=1)$”都是命题，但只有后者是定理。}）被识别为特定的类型，通过 \cref{tab:pov} 中所示的对应关系。因此，\emph{证明一个定理} 的数学活动被识别为 \emph{构造一个对象} 的特殊情况——在这种情况下，构造的对象是代表一个命题的类型的居民。

\index{deductive system|演绎系统}%
这引出了类型论与集合论之间的另一个差异，但要解释它，我们必须稍微讨论一下演绎系统的基本情况。非正式地说，演绎系统是一组 \define{规则 (rules)}\index{rule|规则}，用于推导所谓的 \define{判断 (judgments)}\index{judgment|判断}。如果我们将演绎系统视为一个正式游戏\index{game!deductive system as|游戏!演绎系统作为}，那么判断就是我们按照游戏规则达到的“位置”。我们还可以将演绎系统视为一种代数理论，在这种情况下，判断是元素（如群的元素），而演绎规则是操作（如群乘法）。从逻辑的角度来看，判断可以被认为是“外部”的陈述，存在于元理论中，而与理论本身的“内部”陈述相对。

在一阶逻辑的演绎系统（集合论基于此）中，只有一种判断：给定命题有证明。也就是说，每个命题 $A$ 引发一个判断“$A$ 有证明”，所有判断都是这种形式。一阶逻辑中的规则，例如“从 $A$ 和 $B$ 推导出 $A\wedge B$”，实际上是一种“证明构造”规则，它表示在给定“$A$ 有证明”和“$B$ 有证明”的判断后，我们可以推断出“$A\wedge B$ 有证明”。注意，判断“$A$ 有证明”存在于与 \emph{命题} $A$ 本身不同的层次，命题 $A$ 是理论的内部陈述。
% 特别是，我们不能操作它来构造命题，例如“如果 $A$ 有证明，那么 $B$ 没有证明”——除非我们使用我们的集合论基础作为元理论来谈论其他某些公理系统。

类型论的基本判断，类似于“$A$ 有证明”，写作“$a:A$”，读作“项 $a$ 具有类型 $A$”，或更松散地说“$a$ 是 $A$ 的元素”（或在同伦类型论中，“$a$ 是 $A$ 的点”）。
\index{term|项}%
\index{element|元素}%
\index{point!of a type|点!类型的}%
当 $A$ 是表示命题的类型时，$a$ 可以称为 $A$ 可证明性的 \emph{证人 (witness)}\index{witness!to the truth of a proposition|证人!命题真理的}，或者 $A$ 真实性的 \emph{证据 (evidence)}\index{evidence, of the truth of a proposition|证据, 命题真理的}（甚至 $A$ 的 \emph{证明 (proof)}\index{proof|证明}，但我们会尽量避免使用这种令人困惑的术语）。在这种情况下，当“$a:A$”可以在类型论中推导出时（对于某些 $a$），正好相当于在一阶逻辑中可以推导出类似的判断“$A$ 有证明”（基于假定的公理和数学编码的差异，我们将在整本书中讨论）。

另一方面，如果类型 $A$ 更像一个集合而不是命题（尽管我们将看到，这种区分可能会变得模糊），那么“$a:A$”可以看作是类比于集合论中的命题“$a\in A$”。然而，有一个本质的区别，“$a:A$”是一个 \emph{判断}，而“$a\in A$”是一个 \emph{命题}。特别是，当在类型论内部工作时，我们不能做出诸如“如果 $a:A$ 那么 $b:B$ 不成立”的声明，也不能“驳斥”判断“$a:A$”。

一种好的理解方式是，在集合论中，“隶属 (membership)”是一个关系，它可能在两个预先存在的对象“$a$”和“$A$”之间成立或不成立，而在类型论中，我们不能单独谈论一个元素“$a$”：每个元素\emph{本质上}都是某个类型的元素，并且该类型（一般而言）是唯一确定的。因此，当我们非正式地说“令 $x$ 是一个自然数”时，在集合论中这可以简写为“令 $x$ 是一个事物并假设 $x\in\nat$”，而在类型论中“令 $x:\nat$”是一个原子语句：我们不能在没有指定其类型的情况下引入一个变量。\index{membership|隶属关系}

乍一看，这似乎是一种令人不适的限制，但可以说它更接近于“令 $x$ 是一个自然数”的直观数学意义。在实践中，似乎每当我们确实\emph{需要}“$a\in A$”作为命题而非判断时，总是存在一个背景集合 $B$，其中 $a$ 已知是一个元素，而 $A$ 已知是一个子集。这种情况在类型论中也很容易表示，通过将 $a$ 视为类型 $B$ 的一个元素，并将 $A$ 视为 $B$ 上的一个谓词；见 \cref{subsec:prop-subsets}。

类型论与集合论之间的最后一个差异是对等式的处理。数学中熟悉的等式概念是一个命题：例如，我们可以反驳一个等式或假设一个等式作为前提。由于在类型论中，命题是类型，这意味着等式也是一种类型：对于元素 $a,b:A$（即 $a:A$ 和 $b:A$），我们有一个类型“$\id[A]ab$”。（当然，在\emph{同伦}类型论中，这种等式命题可以以不熟悉的方式表现出来：参见 \cref{sec:identity-types,cha:basics} 以及本书的其余部分）。当 $\id[A]ab$ 是可居住的，我们说 $a$ 和 $b$ 是 \define{（命题上）相等 (propositionally equal)}\index{propositional!equality|命题!相等}%
\index{equality!propositional|等式!命题}%。

然而，在类型论中，还需要一种等式\emph{判断}，存在于与判断“$x:A$”相同的层次上。\index{judgment|判断}
\symlabel{defn:judgmental-equality}%
这被称为 \define{判断相等 (judgmental equality)}\index{equality!judgmental|等式!判断}%
\index{judgmental equality|判断相等}%
或 \define{定义相等 (definitional equality)}\index{equality!definitional|等式!定义}%
\index{definitional equality|定义相等}%
我们将其写作 $a\jdeq b : A$ 或简单地 $a \jdeq b$。将其理解为“根据定义相等”是有帮助的。例如，如果我们通过等式 $f(x)=x^2$ 定义了一个函数 $f:\nat\to\nat$，那么表达式 $f(3)$ 根据定义等于 $3^2$。在理论内部，没有意义去否定或假设一个定义上的等式；我们不能说“如果 $x$ 根据定义等于 $y$，那么 $z$ 根据定义不等于 $w$”。根据定义是否相等只是扩展定义的问题；特别地，它是算法上\index{algorithm|算法}可判定的（尽管算法本质上是元理论的，而不是理论内部的）。\index{decidable!definitional equality|可判定!定义相等}

随着类型论变得更加复杂，判断相等可能会变得比这更微妙，但这是一个良好的直觉起点。或者，如果我们将演绎系统视为一种代数理论，那么判断相等只是该理论中的相等，类似于群的元素之间的相等——唯一可能引起混淆的是，在类型论的演绎系统\emph{内部}还存在一个对象（即类型“$a=b$”），它在内部表现为“相等”的概念。

我们\emph{需要}判断相等的原因是它可以控制其他形式的判断“$a:A$”。例如，假设我们已经给出了 $3^2=9$ 的证明，即我们已经推导出 $p:(3^2=9)$ 的判断。那么同样的证人 $p$ 应该被视为 $f(3)=9$ 的证明，因为 $f(3)$ 根据定义是 $3^2$。最好的表示方法是通过一个规则表示，给定判断 $a:A$ 和 $A\jdeq B$，我们可以推导出判断 $a:B$。

因此，对于我们来说，类型论将是基于两种形式判断的演绎系统：
\begin{center}
  \medskip
  \begin{tabular}{cl}
    \toprule
    判断 & 意义\\
    \midrule
    $a : A$       & “$a$ 是类型 $A$ 的一个对象”\\
    $a \jdeq b : A$ & “$a$ 和 $b$ 是类型 $A$ 的定义相等对象”\\
    \bottomrule
  \end{tabular}
  \medskip
\end{center}
%
\symlabel{defn:defeq}%
当引入一个定义上的等式时，即定义一件事物等于另一件事物时，我们将使用符号“$\defeq$”。因此，上述函数 $f$ 的定义将写作 $f(x)\defeq x^2$。

由于判断不能组合成更复杂的语句，因此符号“$:$”和“$\jdeq$”的结合力比其他任何东西都要弱。%
\footnote{在形式化\indexfoot{mathematics!formalized|数学!形式化的}类型论中，逗号和竖线可以结合得更松散。例如，$x:A,y:B\vdash c:C$ 被解析为 $((x:A),(y:B))\vdash (c:C)$。然而，在本书中，我们避免使用这种符号，直到 \cref{cha:rules}。}
因此，例如，“$p:\id{x}{y}$”应解析为“$p:(\id{x}{y})$”，这是有意义的，因为“$\id{x}{y}$”是一个类型，而不是“$\id{(p:x)}{y}$”，这是无意义的，因为“$p:x$”是一个判断，不能与任何东西相等。类似地，“$A\jdeq \id{x}{y}$”只能解析为“$A\jdeq(\id{x}{y})$”，尽管在极端情况下，像这样，最好添加括号来帮助理解。此外，稍后我们将使用链式相等的常见表示法——例如，写作 $a=b=c=d$ 表示“$a=b$ 和 $b=c$ 和 $c=d$，因此 $a=d$”——我们还将在这样的链中包括判断相等。上下文通常足以使意图清楚。

这也许是提到一个常见数学符号“$f:A\to B$”的适当时机，它表达了 $f$ 是从 $A$ 到 $B$ 的一个函数，可以被视为一个类型判断，因为我们使用“$A\to B$”作为从 $A$ 到 $B$ 的函数类型的符号（这在类型论中是标准做法；参见 \cref{sec:pi-types}）。

\index{assumption|假设|(defstyle}%
判断可能依赖于形如 $x:A$ 的\emph{假设}，其中 $x$ 是一个变量
\index{variable|变量}%
而 $A$ 是一个类型。例如，在假设 $m,n : \nat$ 的情况下，我们可以构造对象 $m + n : \nat$。另一个例子是，假设 $A$ 是一个类型，$x,y : A$，并且 $p : \id[A]{x}{y}$，我们可以构造元素 $p^{-1} : \id[A]{y}{x}$。所有这些假设的集合被称为 \define{上下文 (context)}；\index{context|上下文}从拓扑的角度来看，它可以被视为一个“参数\index{parameter!space|参数!空间}空间”。实际上，技术上讲，上下文必须是一个有序的假设列表，因为后来的假设可能依赖于先前的假设：假设 $x:A$ 只能在假设类型 $A$ 中出现的任何变量之后进行。

如果假设中的类型 $A$ 表示一个命题，那么这个假设就是\emph{假设}的类型论版本：\index{hypothesis|假设}我们假设命题 $A$ 成立。当类型被视为命题时，我们可以省略它们的证明名称。因此，在上述第二个例子中，我们可以改为说，假设 $\id[A]{x}{y}$，我们可以证明 $\id[A]{y}{x}$。然而，由于我们正在做“与证明相关的”数学，\index{mathematics!proof-relevant|数学!与证明相关的}我们将经常将证明作为对象参考。例如，在上面的例子中，我们可能希望建立 $p^{-1}$ 以及传递性和自反性的证明行为类似于一个群组；参见 \cref{cha:basics}。

请注意，在这个词\emph{假设}的意义下，我们可以假设命题等式（通过假设一个变量 $p:x=y$），但我们不能假设判断等式 $x\jdeq y$，因为它不是可以有元素的类型。然而，我们可以做一些看起来像假设判断等式的事情：如果我们有一个涉及变量 $x:A$ 的类型或元素，那么我们可以\emph{替换}任何特定的元素 $a:A$ 以获得更具体的类型或元素。我们有时会使用类似“现在假设 $x\jdeq a$”的语言来指代这个替换过程，尽管它不是上面引入的技术意义上的\emph{假设}。\index{assumption|假设|)}%

同样，我们也不能\emph{证明}判断等式，因为它不是我们可以展示一个见证的类型。然而，我们有时会将判断等式作为定理的一部分陈述，例如“存在 $f:A\to B$ 使得 $f(x)\jdeq y$”。这应该被视为做出两个独立的判断：首先我们对某个元素 $f$ 做出判断 $f:A\to B$，然后我们做出附加判断 $f(x)\jdeq y$。

在本章的其余部分，我们尝试给出类型论的非正式介绍，以满足本书的目的；在 \cref{cha:rules} 中，我们给出了更正式的说明。除了某些显而易见的规则（例如判断相等的东西总是可以互相替换\index{substitution|替换}），类型论的规则可以分组为\emph{类型形成器}。每个类型形成器包括一种构造类型的方法（可能使用先前构造的类型），以及构造和操作该类型的元素的规则。在大多数情况下，这些规则遵循一个相当可预测的模式，但我们不会在这里尝试使其精确化；然而，参见 \cref{sec:finite-product-types} 的开头以及 \cref{cha:induction}。

\index{axiom!versus rules|公理!与规则对比}%
\index{rule!versus axioms|规则!与公理对比}%
本章中介绍的类型论的一个重要方面是它完全由\emph{规则}组成，没有任何\emph{公理}。在基于判断的演绎系统描述中，\emph{规则}是允许我们从一组判断中得出另一个判断的东西，而\emph{公理}是我们一开始给出的判断。如果我们将演绎系统视为一个正式游戏，那么规则就是游戏规则，而公理是起始位置。如果我们将演绎系统视为一种代数理论，那么规则是该理论的操作，而公理是该理论的某个特定自由模型的\emph{生成元}。

在集合论中，唯一的规则是一阶逻辑的规则（例如，从“$A\wedge B$ 有证明”推导出“$A$ 有证明”和“$B$ 有证明”的规则）：所有关于集合行为的信息都包含在公理中。相比之下，在类型论中，通常是\emph{规则}包含了所有信息，而无需任何公理。例如，在 \cref{sec:finite-product-types} 中，我们将看到有一个规则允许我们从“$a:A$”和“$b:B$”中推导出判断“$(a,b):A\times B$”，而在集合论中，类似的陈述将是（成对公理的）一个结果。

通过仅使用规则来制定类型论的优势在于规则是“过程性的”。特别是，这一特性使得类型论的良好计算属性成为可能（尽管它并不自动确保），例如“规范性 (canonicity)”\index{canonicity|规范性}。然而，虽然这种风格适用于传统类型论，但我们尚未理解如何以这种方式制定\emph{同伦}类型论所需的一切。特别是，在 \cref{sec:compute-pi,sec:compute-universe,cha:hits} 中，我们将不得不通过引入额外的公理来补充本章中介绍的类型论规则，特别是\emph{一致性公理 (univalence axiom)}。然而，在本章中，我们仅限于传统的基于规则的类型论。

\section{函数类型 (Function types)}
\label{sec:function-types}

\index{type!function|(defstyle|类型!函数|(defstyle)}%
\indexsee{function type|类型, 函数}{type, function|类型, 函数}%
给定类型 $A$ 和 $B$，我们可以构造类型 $A \to B$，它表示\define{函数 (functions)}\index{function|(defstyle|函数|(defstyle)}%
\indexsee{map|映射}{function|函数}%
\indexsee{mapping|映射}{function|函数}%
其定义域为 $A$，值域为 $B$。我们有时也将函数称为\define{映射 (maps)}。\index{domain!of a function|定义域!函数的}%
\index{codomain, of a function|值域, 函数的}%
\index{function!domain of|函数!定义域}%
\index{function!codomain of|函数!值域}%
\index{functional relation|函数关系}%
与集合论不同，函数不是作为函数关系来定义的；而是作为类型论中的一个基本概念。我们通过规定函数的操作方式、如何构造它们以及它们诱导的等式来解释函数类型。

给定函数 $f : A \to B$ 和定义域中的一个元素 $a : A$，我们可以\define{应用 (apply)}\index{application!of function|应用!函数的}%
\index{function!application|函数!应用}%
\indexsee{evaluation|求值}{application, of a function|应用, 函数的}%
函数以获得值域 $B$ 的一个元素，表示为 $f(a)$，称为 $f$ 在 $a$ 处的\define{值 (value)}\index{value!of a function|值!函数的}。在类型论中，通常省略括号\index{parentheses|括号}，仅用 $f\,a$ 表示 $f(a)$，我们有时也会这样做。

但我们如何构造 $A \to B$ 的元素？有两种等效的方法：直接定义或使用$\lambda$-抽象。通过定义引入函数\index{definition!of function, direct|定义!函数的，直接}%
意味着我们通过给它一个名称——例如 $f$——来引入一个函数，并且我们定义 $f : A \to B$ 通过给出等式
\begin{equation}
  \label{eq:expldef}
  f(x) \defeq \Phi
\end{equation}
其中 $x$ 是一个变量\index{variable|变量}%
，$\Phi$ 是一个可以使用 $x$ 的表达式。为了使其有效，我们必须在假设 $x:A$ 的情况下检查 $\Phi : B$。

现在我们可以通过将 $\Phi$ 中的变量 $x$ 替换为 $a$ 来计算 $f(a)$。例如，考虑函数 $f : \nat \to \nat$，其定义为 $f(x) \defeq x+x$。（我们将在 \cref{sec:inductive-types} 中定义 $\nat$ 和 $+$）。然后 $f(2)$ 在判断上等于 $2+2$。

如果我们不想为函数引入名称，我们可以使用\define{$\lambda$-抽象 ($\lambda$-abstraction)}\index{lambda abstraction@$\lambda$-abstraction|defstyle|lambda 抽象@$\lambda$-抽象}%
\indexsee{function!lambda abstraction@$\lambda$-abstraction|函数!lambda 抽象@$\lambda$-抽象}{$\lambda$-abstraction|$\lambda$-抽象}%
\indexsee{abstraction!lambda-@$\lambda$-抽象}{$\lambda$-abstraction|$\lambda$-抽象}%
给定一个类型为 $B$ 的表达式 $\Phi$，它可以使用 $x:A$，如上所述，我们写作 $\lam{x:A} \Phi$ 以表示与\eqref{eq:expldef} 相同的函数。因此，我们有
\[ (\lamt{x:A}\Phi) : A \to B. \]
在前一段的示例中，我们有以下类型判断
\[ (\lam{x:\nat}x+x) : \nat \to \nat. \]
作为另一个示例，对于任意类型 $A$ 和 $B$ 以及任何元素 $y:B$，我们有一个\define{常数函数 (constant function)}\index{constant!function|常数!函数}%
\index{function!constant|函数!常数}%
$(\lam{x:A} y): A\to B$。

我们通常省略 $\lambda$-抽象中的变量 $x$ 的类型，写作 $\lam{x}\Phi$，因为从函数 $\lam x \Phi$ 具有类型 $A\to B$ 的判断中可以推断出变量 $x:A$ 的类型。按照约定，“$\lam{x}$”的变量绑定\index{variable!scope of|变量!范围}%
\index{scope|范围}%
的“范围”是表达式的整个其余部分，除非用括号\index{parentheses|括号}分隔。因此，例如，$\lam{x} x+x$ 应解析为 $\lam{x} (x+x)$，而不是 $(\lam{x}x)+x$（在这种情况下，无论如何它将是类型不合法的）。

另一种等效的符号是
\symlabel{mapsto}%
\[ (x \mapsto \Phi) : A \to B. \]
\symlabel{blank}%
我们有时也可以在表达式 $\Phi$ 中使用空白符号“$\blank$”代替变量，以表示隐含的 $\lambda$-抽象。例如，$g(x,\blank)$ 是另一种写作 $\lam{y} g(x,y)$ 的方式。

现在 $\lambda$-抽象是一个函数，因此我们可以将其应用于一个参数 $a:A$。然后我们有以下\define{计算规则 (computation rule)}\index{computation rule!for function types|计算规则!函数类型的}，这是一种定义相等性\footnote{使用这个等式通常被称为\define{$\beta$-变换 ($\beta$-conversion)}\index{beta-conversion@$\beta $-conversion|beta-变换@$\beta $-变换}%
\indexsee{beta-reduction|beta-约简}{conversion!beta@$\beta $-约简}{$\beta$-变换}%
或\define{$\beta$-约简 ($\beta$-reduction)}。%
\index{beta-reduction@$\beta $-reduction|footstyle|beta-约简@$\beta $-约简}%
\indexsee{reduction!beta@$\beta $-约简}{约简!beta@$\beta $-约简}{$\beta$-变换}%
}：
\[(\lamu{x:A}\Phi)(a) \jdeq \Phi'\]
其中 $\Phi'$ 是表达式 $\Phi$，其中所有 $x$ 的出现都被替换为 $a$。继续上述示例，我们有
%
\[ (\lamu{x:\nat}x+x)(2) \jdeq 2+2. \]
%
注意，从任意函数 $f:A\to B$，我们可以构造一个 $\lambda$-抽象函数 $\lam{x} f(x)$。由于这在定义上是“将 $f$ 应用于其参数的函数”，我们认为它在定义上等于 $f$：\footnote{使用这个等式通常被称为\define{$\eta$-变换 ($\eta$-conversion)}\index{eta-conversion@$\eta $-conversion|eta-变换@$\eta $-变换}%
\indexsee{conversion!eta@$\eta $-变换}{$\eta$-展开}%
或\define{$\eta$-展开 ($\eta$-expansion)}。%
\index{eta-expansion@$\eta $-expansion|footstyle|eta-展开@$\eta $-展开}%
\indexsee{expansion, eta-@expansion, $\eta $-展开}{$\eta$-展开}%
}}
\[ f \jdeq (\lam{x} f(x))。\]
此等式是\define{函数类型的唯一性原则 (uniqueness principle for function types)}\index{uniqueness!principle!for function types|唯一性!原则!函数类型的}，因为它表明 $f$ 是由其值唯一确定的。

通过显式参数定义函数的引入可以通过使用 $\lambda$-抽象来简化为简单的定义：即，我们可以通过
\[ f(x) \defeq \Phi \]
的定义来读取 $f: A\to B$ 作为
\[ f \defeq \lamu{x:A}\Phi。\]

在涉及变量的计算中，我们必须小心，当用涉及变量的表达式替换一个变量时，因为我们要保持表达式的绑定结构。所谓\emph{绑定结构 (binding structure)}\index{binding structure|绑定结构}，是指由诸如 $\lambda$、$\Pi$ 和 $\Sigma$ 等绑定符号（我们很快就会见到后者）生成的无形联系，连接了引入变量的位置和使用变量的位置。例如，考虑 $f : \nat \to (\nat \to \nat)$ 的定义
\[ f(x) \defeq \lamu{y:\nat} x + y。]
现在，如果我们假设某处 $y : \nat$，那么 $f(y)$ 是什么？将“$\lam{y}x+y$”定义 $f(x)$ 中的 $x$ 替换为 $y$，得到 $\lamu{y:\nat} y + y$，这样做是错误的，因为这意味着 $y$ 被\define{捕获 (captured)}。\index{capture, of a variable|捕获，变量的}%
\index{variable!captured|变量!被捕获}%
之前，替换的 $y$ 是指我们的假设，但现在它指的是 $\lambda$-抽象的参数。因此，这种天真的替换将破坏绑定结构，使我们能够进行语义上不正确的计算。

但是在这个例子中，$f(y)$ 是什么？请注意，受限（或“虚设的”）变量\index{variable!bound|变量!受限的}%
\index{variable!dummy|变量!虚设的}%
\indexsee{bound variable|受限变量}{variable, bound|变量, 受限的}%
\indexsee{dummy variable|虚设变量}{variable, bound|变量, 受限的}%
如表达式 $\lamu{y:\nat} x + y$ 中的 $y$ 只有局部意义，并且可以一致地替换为任何其他变量，从而保持绑定结构。实际上，$\lamu{y:\nat} x + y$ 被判断上等于\footnote{使用这个等式通常被称为\define{$\alpha$-变换 ($\alpha$-conversion)}。\index{alpha-conversion@$\alpha $-conversion|alpha-变换@$\alpha $-变换}%
\indexsee{conversion!alpha@$\alpha$-约简}{变换!alpha@$\alpha$-约简}{$\alpha$-变换}}为
$\lamu{z:\nat} x + z$。由此可得 $f(y)$ 判断上等于 $\lamu{z:\nat} y + z$，并且这回答了我们的问题。（代替 $z$，任何与 $y$ 不同的变量都可以使用，得到相同的结果。）

当然，这对于任何数学家来说都应该很熟悉：这与如果 $f(x) \defeq \int_1^2 \frac{dt}{x-t}$，则 $f(t)$ 不是 $\int_1^2 \frac{dt}{t-t}$，而是 $\int_1^2 \frac{ds}{t-s}$ 的现象是相同的。$\lambda$-抽象绑定虚设变量的方式与积分完全相同。

我们已经看到了如何定义一个变量的函数。一种定义多个变量函数的方法是使用笛卡尔积，这将在后面介绍；具有参数 $A$ 和 $B$ 并且结果在 $C$ 中的函数将具有类型 $f : A \times B \to C$。但是，还有另一种选择，它避免使用积类型，这称为\define{柯里化 (currying)}\index{currying|柯里化}%
\index{function!currying of|函数!柯里化}%
（以数学家 Haskell Curry 命名）。
\index{programming|编程}%

柯里化的想法是将具有两个输入 $a:A$ 和 $b:B$ 的函数表示为一个函数，该函数接受\emph{一个}输入 $a:A$ 并返回\emph{另一个函数}，然后该函数接受第二个输入 $b:B$ 并返回结果。即，我们认为两个变量的函数属于迭代函数类型 $f : A \to (B \to C)$。我们也可以在没有括号\index{parentheses|括号}的情况下写作 $f : A \to B \to C$，默认约定为右结合\index{associativity!of function types|结合性!函数类型的}。然后给定 $a : A$ 和 $b : B$，我们可以将 $f$ 应用于 $a$，然后将结果应用于 $b$，得到 $f(a)(b) : C$。为了避免括号的泛滥，我们允许自己写作 $f(a)(b)$ 为 $f(a,b)$，即使没有涉及积。在完全省略括号的情况下，我们写作 $f\,a\,b$ 为 $(f\,a)\,b$，现在默认结合性为左，使得 $f$ 按正确顺序应用其参数。

我们对显式参数定义的符号扩展到这种情况：我们可以通过给出等式 $f(x,y) \defeq \Phi$ 定义一个命名函数 $f : A \to B \to C$，其中在假设 $x:A$ 和 $y:B$ 的情况下 $\Phi:C$。使用 $\lambda$-抽象\index{lambda abstraction@$\lambda$-abstraction|lambda 抽象@$\lambda$-抽象}，这相当于
\[ f \defeq \lamu{x:A}{y:B} \Phi，\]
也可以写作
\[ f \defeq x \mapsto y \mapsto \Phi。\]
我们也可以通过写作多个空白符号来隐式抽象多个变量，例如 $g(\blank,\blank)$ 意味着 $\lam{x}{y} g(x,y)$。对三个或更多参数函数进行柯里化是我们刚刚描述的一个直接扩展。

\index{type!function|类型!函数|)}%
\index{function|函数|)}%

\section{宇宙和族 (Universes and families)}
\label{sec:universes}

到目前为止，我们一直在非正式地使用表达式“$A$ 是一个类型”。我们现在将通过引入\define{宇宙 (universes)}\index{type!universe|(defstyle|类型!宇宙|(defstyle)}%
\indexsee{universe|宇宙}{type, universe|类型, 宇宙}%
来使这一点更加精确。宇宙是一个类型，其元素是类型。与朴素集合论类似，我们可能希望有一个包含所有类型的宇宙 $\UU_\infty$，包括其自身（即 $\UU_\infty : \UU_\infty$）。然而，正如在集合论中一样，这是不健全的，即我们可以从中推导出每个类型，包括表示命题 False 的空类型（参见 \cref{sec:coproduct-types}）都是居留的。例如，使用树作为集合的表示，我们可以直接编码 Russell 悖论\index{paradox|悖论} \cite{coquand:paradox}。
% 或者，为了避免使用归纳类型来定义树，我们可以遵循 Girard \cite{girard:paradox} 的方法，编码 Burali-Forti 悖论，这表明所有序数的集合不能成为一个序数。

为了避免悖论，我们引入了一个宇宙的层次结构\index{hierarchy!of universes|层次结构!宇宙的}%
\[ \UU_0 : \UU_1 : \UU_2 : \cdots \]
其中每个宇宙 $\UU_i$ 是下一个宇宙 $\UU_{i+1}$ 的元素。此外，我们假设我们的宇宙是\define{累积的 (cumulative)}\index{type!universe!cumulative|类型!宇宙!累积的}%
\index{cumulative!universes|累积的!宇宙的}%
，即 $i$ 阶宇宙的所有元素也是 $i+1$ 阶宇宙的元素，即如果 $A:\UU_i$，那么 $A:\UU_{i+1}$ 也是如此。这很方便，但也带来了一些不太愉快的后果，即元素不再具有唯一的类型，并且在其他方面也有点棘手，这里不再赘述；详见注释。

当我们说 $A$ 是一个类型时，我们的意思是它居于某个宇宙 $\UU_i$。我们通常希望避免明确提及层级\index{universe level|宇宙层级}%
\indexsee{level|层级}{universe level or $n$-type|宇宙层级或$n$-类型}%
\indexsee{type!universe!level|类型!宇宙!层级}{universe level|宇宙层级}%
$i$，并假设层级可以以一致的方式分配；因此我们可以写作 $A:\UU$，省略层级。这样我们甚至可以写作 $\UU:\UU$，这可以理解为 $\UU_i:\UU_{i+1}$，将指标隐含地留下。以这种方式书写宇宙称为\define{典型的歧义 (typical ambiguity)}\index{typical ambiguity|典型的歧义}%
。这很方便，但也有点危险，因为它允许我们写出看似有效的证明，这些证明重现了自指的悖论。如果有任何关于一个论证是否正确的疑问，检查的方法是尝试为其中出现的所有宇宙一致地分配层级。当假设某个宇宙 \UU 时，我们可以将属于 \UU 的类型称为\define{小类型 (small types)}\index{small!type|小!类型}%
\index{type!small|类型!小}%。

为了建模在给定类型 $A$ 上变化的类型集合，我们使用其\index{family!of types|族!类型的}{type!family of|类型!族的}%
\indexsee{dependent!type|依赖!类型}{type, family of|类型, 族的}%
\indexsee{dependent!type|依赖!类型}{type, family of|类型, 族的}%
\index{type!family of|类型!族的}%
值域为宇宙的函数 $B : A \to \UU$。这些函数称为\define{类型族 (families of types)}（有时也称为\emph{依赖类型 (dependent types)}）；它们对应于集合论中使用的集合族。

\symlabel{fin}%
类型族的一个例子是有限集合的族 $\Fin : \nat \to \UU$，其中 $\Fin(n)$ 是一个恰好有 $n$ 个元素的类型。（我们现在还不能\emph{定义}族 $\Fin$——实际上，我们甚至还没有引入它的定义域 $\nat$——但我们很快就会这样做；参见 \cref{ex:fin}）。我们可以用 $0_n,1_n,\dots,(n-1)_n$ 来表示 $\Fin(n)$ 的元素，使用下标强调 $\Fin(n)$ 的元素与 $\Fin(m)$ 的元素不同，如果 $n$ 与 $m$ 不同，并且它们都与普通自然数不同（我们将在 \cref{sec:inductive-types} 中介绍）。

一个更为平凡（但非常重要）的类型族示例是一个\define{常量类型族 (constant type family)}\index{constant!type family|常量!类型族}%
\index{type!family of!constant|类型!族!常量}%
，位于类型 $B:\UU$，它当然是常函数 $(\lam{x:A} B):A\to\UU$。

作为一个\emph{非}示例，在我们版本的类型论中，没有类型族“$\lam{i:\nat} \UU_i$”。事实上，没有足够大的宇宙可以作为它的值域。此外，我们甚至不将宇宙 $\UU_i$ 的索引 $i$ 与类型论中的自然数 \nat（后者将在 \cref{sec:inductive-types} 中引入）等同。

\index{type!universe|宇宙|)}

\section{依赖函数类型（\texorpdfstring{$\Pi$}{Π}-类型） (Dependent function types (\texorpdfstring{$\Pi$}{Π}-types))}
\label{sec:pi-types}

\index{type!dependent function|(defstyle|类型!依赖函数|(defstyle)}%
\index{function!dependent|(defstyle|函数!依赖|(defstyle)}%
\indexsee{dependent!function|依赖!函数}{function, dependent|函数, 依赖的}%
\indexsee{type!Pi-@$\Pi$-|类型!Pi-@$\Pi$-}{type, dependent function|类型, 依赖函数}%
\indexsee{Pi-type@$\Pi$-type|Pi-类型@$\Pi$-类型}{type, dependent function|类型, 依赖函数}%
在类型论中，我们经常使用函数类型的更一般版本，称为\define{$\Pi$-类型 ($\Pi$-type)}或\define{依赖函数类型 (dependent function type)}。$\Pi$-类型的元素是\define{依赖函数 (dependent functions)}，其值域类型可以根据函数应用到的定义域元素而变化。“$\Pi$-类型”这个名称之所以使用，是因为该类型也可以看作是给定类型上的笛卡尔积。

给定类型 $A:\UU$ 和类型族 $B:A \to \UU$，我们可以构造依赖函数的类型 $\prd{x:A}B(x) : \UU$。这种类型有许多替代表示法，例如
\[ \tprd{x:A} B(x) \qquad \dprd{x:A}B(x) \qquad \lprd{x:A} B(x)。\]
如果 $B$ 是一个常量族，那么依赖积类型就是普通函数类型：
\[\tprd{x:A} B \jdeq (A \to B)。\]
实际上，所有 $\Pi$-类型的构造都是对普通函数类型相应构造的推广。

\index{definition!of function, direct|定义!函数的, 直接}%
我们可以通过显式定义引入依赖函数：为了定义 $f : \prd{x:A}B(x)$，其中 $f$ 是待定义的依赖函数的名称，我们需要一个可能涉及变量 $x:A$ 的表达式 $\Phi : B(x)$，\index{variable|变量}%
我们写作
\[ f(x) \defeq \Phi \qquad \text{对于 } x:A。\]
或者，我们可以使用\define{$\lambda$-抽象 ($\lambda$-abstraction)}%
\index{lambda abstraction@$\lambda$-abstraction|defstyle|lambda 抽象@$\lambda$-抽象}%
\begin{equation}
\label{eq:lambda-abstraction}
\lamu{x:A} \Phi \ :\ \prd{x:A} B(x)。
\end{equation}
\index{application!of dependent function|应用!依赖函数的}%
\index{function!dependent!application|函数!依赖!应用}%
与非依赖函数一样，我们可以将依赖函数 $f : \prd{x:A}B(x)$ 应用于参数 $a:A$，以获得元素 $f(a):B(a)$。等式与普通函数类型相同，即我们有以下计算规则\index{computation rule!for dependent function types|计算规则!依赖函数类型的}%
给定 $a:A$，我们有 $f(a) \jdeq \Phi'$ 和 $(\lamu{x:A} \Phi)(a) \jdeq \Phi'$，其中 $\Phi'$ 是通过将 $\Phi$ 中的所有 $x$ 替换为 $a$ 获得的（始终避免变量捕获）。同样，对于任何 $f:\prd{x:A} B(x)$，我们有唯一性原则 $f\jdeq (\lam{x} f(x))$。
\index{uniqueness!principle!for dependent function types|唯一性!原则!依赖函数类型的}%

例如，回想一下 \cref{sec:universes} 中有一个类型族 $\Fin:\nat\to\UU$，其值是标准有限集合，具有元素 $0_n,1_n,\dots,(n-1)_n : \Fin(n)$。然后有一个依赖函数 $\fmax : \prd{n:\nat} \Fin(n+1)$，它返回每个非空有限类型的“最大”元素，即 $\fmax(n) \defeq n_{n+1}$。
\index{finite!sets, family of|有限!集合, 族的}%
如同 $\Fin$ 本身的情况一样，我们还不能定义 $\fmax$，但我们很快就能做到；参见 \cref{ex:fin}。

我们现在可以定义的另一类重要的依赖函数类型是\define{多态函数 (polymorphic functions)}%
\index{function!polymorphic|函数!多态的}%
\index{polymorphic function|多态函数}%
在给定宇宙上。多态函数是一个以类型作为其参数之一的函数，然后对该类型的元素（或从中构造的其他类型的元素）进行操作。
\symlabel{idfunc}%
\index{function!identity|函数!恒等的}%
\index{identity!function|恒等!函数}%
一个例子是多态恒等函数 $\idfunc : \prd{A:\UU} A \to A$，我们定义为 $\idfunc{} \defeq \lam{A:\type}{x:A} x$。（如同 $\lambda$-抽象一样，$\Pi$s 自动对表达式的其余部分进行范围限定\index{scope|范围}，除非用括号限定；因此 $\idfunc : \prd{A:\UU} A \to A$ 意味着 $\idfunc : \prd{A:\UU} (A \to A)$。这个约定虽然在数学中不常见，但在类型论中很常见。）

我们有时会将依赖函数的某些参数写作下标。例如，我们可以等效地定义多态恒等函数为 $\idfunc[A](x) \defeq x$。此外，如果可以从上下文推断出一个参数，我们可以完全省略它。例如，如果 $a:A$，那么写作 $\idfunc(a)$ 是不含糊的，因为 $\idfunc$ 必须意味着 $\idfunc[A]$，以便它可以应用于 $a$。

另一个稍微复杂的多态函数示例是“交换”操作，它交换（柯里化的）两个参数函数的顺序：
\[ \mathsf{swap} : \prd{A:\UU}{B:\UU}{C:\UU} (A\to B\to C) \to (B\to A \to C)。\]
我们可以定义它为
\[ \mathsf{swap}(A,B,C,g) \defeq \lam{b}{a} g(a)(b)。\]
我们也可以将类型参数作为下标写作：
\[ \mathsf{swap}_{A,B,C}(g)(b,a) \defeq g(a,b)。\]

请注意，如同我们对普通函数所做的，我们使用柯里化来定义具有多个参数的依赖函数（例如 $\mathsf{swap}$）。然而，在依赖情况下，第二个定义域可以依赖于第一个定义域，而值域可以依赖于两者。即，给定 $A:\UU$ 和类型族 $B : A \to \UU$ 以及 $C : \prd{x:A}B(x) \to \UU$，我们可以构造类型 $\prd{x:A}{y : B(x)} C(x,y)$，这是具有两个参数的函数类型。
如果 $B$ 是常量并且等于 $A$，我们可以简化表示法并写作 $\prd{x,y:A}$；例如，$\mathsf{swap}$ 的类型也可以写作
\[ \mathsf{swap} : \prd{A,B,C:\UU} (A\to B\to C) \to (B\to A \to C)。\]
最后，给定 $f:\prd{x:A}{y : B(x)} C(x,y)$ 和参数 $a:A$ 以及 $b:B(a)$，我们有 $f(a)(b) : C(a,b)$，如前所述，我们将其写作 $f(a,b) : C(a,b)$。

\index{type!dependent function|类型!依赖函数|)}%
\index{function!dependent|函数!依赖|)}%

\section{积类型 (Product types)}
\label{sec:finite-product-types}

给定类型 $A,B:\UU$，我们引入类型 $A\times B:\UU$，我们称之为它们的\define{笛卡尔积 (cartesian product)}。 \indexsee{cartesian product|笛卡尔积}{type, product|类型, 积}%
\indexsee{type!cartesian product|类型!笛卡尔积}{type, product|类型, 积}%
\index{type!product|(defstyle|类型!积|(defstyle)}%
\indexsee{product!of types|积!类型的}{type, product|类型, 积}%
我们还引入了一个零元积类型，称为\define{单位类型 (unit type)} $\unit : \UU$。
\indexsee{nullary!product|零元!积}{type, unit|类型, 单位}%
\indexsee{unit!type|单位!类型}{type, unit|类型, 单位}%
\index{type!unit|(defstyle|类型!单位|(defstyle)}%
我们期望 $A\times B$ 的元素是对偶 $(a,b) : A \times B$，其中 $a:A$ 和 $b:B$，而 $\unit$ 的唯一元素是某个特定对象 $\ttt : \unit$。 \index{pair!ordered|对偶!有序的}%
然而，与集合论中我们将有序对定义为特定集合然后将它们全部收集到笛卡尔积中不同，在类型论中，有序对是一个原始概念，与函数一样。

\begin{rmk}\label{rmk:introducing-new-concepts}
在类型论中引入新类型的一般模式如下。我们在 \cref{sec:function-types,sec:pi-types} 中已经看到了这一模式\footnote{上述宇宙的描述是一个例外。}，所以值得强调一下其一般形式。
要指定一个类型，我们需要指定：
\begin{enumerate}
\item 如何通过\define{形成规则 (formation rules)}\index{formation rule|形成规则}%
\index{rule!formation|规则!形成}%
形成这种新类型。（例如，当 $A$ 是一个类型并且 $B$ 是一个类型时，我们可以形成函数类型 $A \to B$。当 $A$ 是一个类型并且 $B(x)$ 是 $x:A$ 的类型时，我们可以形成依赖函数类型 $\prd{x:A} B(x)$。）

\item 如何构造该类型的元素。这些称为该类型的\define{构造子 (constructors)}或\define{引入规则 (introduction rules)}。%
\index{constructor|构造子}%
\index{rule!introduction|规则!引入}%
\index{introduction rule|引入规则}%
（例如，函数类型有一个构造子，即 $\lambda$-抽象。回想一下，像 $f(x)\defeq 2x$ 这样的直接定义可以等效地表达为 $\lambda$-抽象 $f\defeq \lam{x} 2x$。）

\item 如何使用该类型的元素。这些称为该类型的\define{消去子 (eliminators)}或\define{消去规则 (elimination rules)}。%
\index{eliminator|消去子}%
\index{elimination rule|消去规则}%
（例如，函数类型有一个消去子，即函数应用。）

\item
一个\define{计算规则 (computation rule)}\index{computation rule|计算规则}，表示消去子如何作用于构造子。（例如，对于函数，计算规则表明 $(\lamu{x:A}\Phi)(a)$ 在判断上等于将 $a$ 代入 $\Phi$ 中的结果。）

\item
一个可选的\define{唯一性原则 (uniqueness principle)}\index{uniqueness!principle|唯一性!原则}，它表示从或向该类型映射的唯一性原则。对于某些类型，唯一性原则通过表明该类型的每个元素都可以通过将消去子应用于它来唯一确定，并且可以通过应用构造子从这些结果中重新构造，从而描述了向该类型的映射——因此以与计算规则对偶的方式表达了构造子如何作用于消去子。（例如，对于函数，唯一性原则表明任何函数 $f$ 在判断上等于“展开”的函数 $\lamu{x} f(x)$，因此由其值唯一确定。）对于其他类型，唯一性原则表明从该类型的每个映射（函数）都是由某些数据唯一确定的。（一个例子是 \cref{sec:coproduct-types} 中引入的并类型，其唯一性原则在 \cref{sec:universal-properties} 中提到。）

当唯一性原则不作为判断等式规则采用时，通常可以作为该类型的其他规则的\emph{命题}等式证明。在这种情况下，我们称之为\define{命题唯一性原则 (propositional uniqueness principle)}。%
\index{uniqueness!principle, propositional|唯一性!原则, 命题}%
\index{propositional!uniqueness principle|命题!唯一性原则}%
（在后续章节中，我们还将偶尔遇到\emph{命题计算规则 (propositional computation rules)}。）%
\index{computation rule!propositional|计算规则!命题}%
\end{enumerate}
\cref{sec:syntax-more-formally} 中的推理规则根据这种方式进行了组织和命名；参见 \cref{sec:more-formal-pi}，其中每种可能性都得到了实现。
\end{rmk}

构造对偶的方法显而易见：给定 $a:A$ 和 $b:B$，我们可以形成 $(a,b):A\times B$。同样，$\unit$ 的元素的唯一构造方式是 $\ttt:\unit$。我们期望“$A\times B$ 的每个元素都是对偶”，这是积的唯一性原则；我们不会将其作为类型论的规则，但我们将在稍后以命题等式的形式证明它。

现在，我们如何\emph{使用}对偶，即我们如何定义从积类型到其他类型的函数？让我们首先考虑一个非依赖函数 $f : A\times B \to C$ 的定义。由于我们期望 $A\times B$ 的唯一元素是对偶，因此我们期望能够通过规定 $f$ 应用于对偶 $\tup{a}{b}$ 时的结果来定义这样的函数。我们可以通过提供一个函数 $g : A \to B \to C$ 来规定这些结果。因此，我们引入了一个新规则（积的消去规则），它表明对于任何这样的 $g$，我们可以定义一个函数 $f : A\times B \to C$ 为
\[ f(\tup{a}{b}) \defeq g(a)(b)。\]
我们在这里避免写作 $g(a,b)$，以强调 $g$ 不是一个关于积的函数。（然而，在本书的后续部分，我们将经常将 $g(a,b)$ 写作用于积函数和柯里化的双变量函数。）这个定义等式是积类型的计算规则\index{computation rule!for product types|计算规则!积类型的}。

请注意，在集合论中，我们会通过 $A\times B$ 的每个元素都是有序对的事实来证明上述 $f$ 的定义是合理的，因此定义 $f$ 在这些对偶上的值就足够了。相比之下，类型论颠倒了这种情况：我们假设当我们指定其在对偶上的值时，定义在 $A\times B$ 上的函数是合理的，并且从这一点（或者更准确地说，从其更一般的依赖函数版本）我们将能够\emph{证明} $A\times B$ 的每个元素都是对偶。从范畴论的角度看，我们可以说我们定义了积 $A\times B$，使其成为“指数” $B\to C$ 的左伴随，我们已经引入了这一点。

例如，我们可以导出\define{投影函数 (projection functions)}%
\index{function!projection|函数!投影的}%
\index{component, of a pair|对偶的成分}%
\index{projection!from cartesian product type|投影!从笛卡尔积类型}%
函数
\symlabel{defn:proj}%
\begin{align*}
\fst & :  A \times B \to A \\
\snd & :  A \times B \to B
\end{align*}
其定义等式为
\begin{align*}
\fst(\tup{a}{b}) & \defeq  a \\
\snd(\tup{a}{b}) & \defeq  b。
\end{align*}
%
\symlabel{defn:recursor-times}%
我们可以定义一个函数类型为
\begin{equation}
\rec{A\times B} : \prd{C:\UU}(A \to B \to C) \to A \times B \to C
\end{equation}
并定义等式为
\[\rec{A\times B}(C,g,\tup{a}{b}) \defeq g(a)(b)。\]
然后，我们可以通过定义\index{recursor|递归子}%
\begin{align*}
\fst &\defeq \rec{A\times B}(A, \lam{a}{b} a)\\
\snd &\defeq \rec{A\times B}(B, \lam{a}{b} b)。
\end{align*}
来代替直接通过定义等式定义函数 $\fst$ 和 $\snd$。我们将函数 $\rec{A\times B}$ 称为积类型的\define{递归子 (recursor)}。这里使用“递归子”这个名字有点不幸，因为没有发生递归。这个名字来源于积类型是归纳类型一般框架的一个退化示例，对于诸如自然数的类型，递归子实际上将是递归的。我们也可以将笛卡尔积的递归原则称为上面所描述的通过给出对偶上的值来定义函数 $f:A\times B\to C$ 的事实。
\index{recursion principle!for cartesian product|递归原则!笛卡尔积的}%

我们留作简单的练习来展示如何从投影中导出递归子，反之亦然。
% Ex: Derive from projections

\symlabel{defn:recursor-unit}%
我们还定义了单位类型的递归子：
\[\rec{\unit} : \prd{C:\UU}C \to \unit \to C\]
并定义等式为
\[ \rec{\unit}(C,c,\ttt) \defeq c。 \]
虽然我们包括它以保持类型定义的模式，但单位的递归子完全没有用，因为我们可以直接通过简单地忽略单位类型的参数来定义这样的函数。

为了能够在积类型上定义\emph{依赖}函数，我们必须泛化递归子。给定 $C: A \times B \to \UU$，我们可以通过提供一个函数
\narrowequation{
g : \prd{x:A}\prd{y:B} C(\tup{x}{y})
}
并定义等式为
\[ f(\tup x y) \defeq g(x)(y)。\]
例如，通过这种方式我们可以证明命题唯一性原则，该原则指出 $A\times B$ 的每个元素都等于一个对偶。
\index{uniqueness!principle, propositional!for product types|唯一性!原则, 命题!积类型的}%
具体来说，我们可以构造一个函数
\[ \uniq{A\times B} : \prd{x:A \times B} (\id[A\times B]{\tup{\fst {(x)}}{\snd {(x)}}}{x})。 \]
这里我们使用的是身份类型 (identity type)，我们将在 \cref{sec:identity-types} 中引入。然而，我们现在需要知道的是，对于任何 $x:A$，都有一个反身性元素 $\refl{x} : \id[A]{x}{x}$。有了这个，我们可以定义
\label{uniquenessproduct}
\[ \uniq{A\times B}(\tup{a}{b}) \defeq \refl{\tup{a}{b}}。 \]
这种构造是有效的，因为在 $x \defeq \tup{a}{b}$ 的情况下，我们可以计算
\[ \tup{\fst(\tup{a}{b})}{\snd{(\tup{a}{b})}} \jdeq \tup{a}{b}，\]
使用投影的定义等式。因此，
\[ \refl{\tup{a}{b}} : \id{\tup{\fst(\tup{a}{b})}{\snd{(\tup{a}{b})}}}{\tup{a}{b}} \]
是类型良好的，因为等式的两边在判断上是相等的。

更一般地说，通过这种方式定义依赖函数的能力意味着要证明一个积的所有元素的属性，足以证明其规范元素（即有序对）的属性。当我们到达归纳类型（如自然数）时，对应的属性将是能够通过归纳法编写证明。因此，如果我们像上面那样做，并在通用情况下应用此原则一次，我们称产生的函数为积类型的\define{归纳法 (induction)}：给定 $A,B : \UU$，我们有
\symlabel{defn:induction-times}%
\[ \ind{A\times B} : \prd{C:A \times B \to \UU}
\Parens{\prd{x:A}{y:B} C(\tup{x}{y})} \to \prd{x:A \times B} C(x) \]
其定义等式为
\[ \ind{A\times B}(C,g,\tup{a}{b}) \defeq g(a)(b)。\]
同样，我们可以说通过积的归纳法得到的依赖函数被从积类型的\define{归纳原则 (induction principle)}中获得。
\index{induction principle|归纳原则}%
\index{induction principle!for product|归纳原则!积的}%
很容易看出，递归子只是当族 $C$ 是常量时归纳法的特例。由于归纳法描述了如何使用积类型的元素，因此归纳法也被称为\define{（依赖）消去子 (dependent eliminator)}，\index{eliminator!of inductive type!dependent|消去子!归纳类型的!依赖}%
而递归子则是\define{非依赖消去子 (non-dependent eliminator)}。 \index{eliminator!of inductive type!non-dependent|消去子!归纳类型的!非依赖}%
\index{non-dependent eliminator|非依赖消去子}%
\index{dependent eliminator|依赖消去子}%

% 我们可以将归纳法命题化，表示对于所有对偶都成立的属性对积类型的所有元素都成立。

单位类型的归纳法比递归子更有用：
\symlabel{defn:induction-unit}%
\[ \ind{\unit} : \prd{C:\unit \to \UU} C(\ttt) \to \prd{x:\unit}C(x)\]
其定义等式为
\[ \ind{\unit}(C,c,\ttt) \defeq c。 \]
归纳法使我们能够证明 $\unit$ 的命题唯一性原则，即它的唯一居留元素是 $\ttt$。也就是说，我们可以构造
\label{uniquenessunit}
\[\uniq{\unit} : \prd{x:\unit} \id{x}{\ttt} \]
通过使用定义等式
\[\uniq{\unit}(\ttt) \defeq \refl{\ttt}，\]
或者等效地通过使用归纳法：
\[\uniq{\unit} \defeq \ind{\unit}(\lamu{x:\unit} \id{x}{\ttt},\refl{\ttt})。 \]

\index{type!product|类型!积|)}%
\index{type!unit|类型!单位|)}%

\section{依赖对类型（Dependent pair types，\texorpdfstring{$\Sigma$}{Σ}-types）}
\label{sec:sigma-types}

\index{type!dependent pair|(defstyle}%
\indexsee{type!dependent sum}{type, dependent pair}%
\indexsee{type!Sigma-@$\Sigma$-}{type, dependent pair}%
\indexsee{Sigma-type@$\Sigma$-type}{type, dependent pair}%
\indexsee{sum!dependent}{type, dependent pair}%

就像我们将函数类型（function types）（\cref{sec:function-types}）推广到依赖函数类型（dependent function types）（\cref{sec:pi-types}）一样，通常我们也可以将积类型（product types）（\cref{sec:finite-product-types}）推广，以允许一对中的第二个分量的类型根据第一个分量的选择而变化。这被称为\define{依赖对类型}（dependent pair type），或者\define{$\Sigma$-type}，因为在集合论中它对应于给定类型上的索引和（即并集或不交并集）。

给定类型 $A:\UU$ 和族 $B : A \to \UU$，依赖对类型记作 $\sm{x:A} B(x) : \UU$。
替代的记号有：
\[ \tsm{x:A} B(x) \hspace{2cm} \dsm{x:A}B(x) \hspace{2cm} \lsm{x:A} B(x). \]
就像其他绑定构造（例如 $\lambda$-抽象和 $\Pi$）一样，$\Sigma$ 的作用域\index{scope} 也自动覆盖表达式的其余部分，除非用括号限定，例如 $\sm{x:A} B(x) \to C$ 表示 $\sm{x:A} (B(x) \to C)$。

\symlabel{defn:dependent-pair}%
\indexdef{pair!dependent}%
构造依赖对类型的元素的方法是配对：如果给定 $a:A$ 和 $b:B(a)$，则有 $\tup{a}{b} : \sm{x:A} B(x)$。
如果 $B$ 是常数，则依赖对类型是普通的笛卡尔积类型：
\[ \Parens{\sm{x:A} B} \jdeq (A \times B).\]
所有关于 $\Sigma$-types 的构造都可以看作是关于积类型的构造的直接推广，依赖函数通常替代非依赖函数。

例如，递归原理%
\index{recursion principle!for dependent pair type}
表明，要定义从 $\Sigma$-type 到非依赖函数 $f : (\sm{x:A} B(x)) \to C$，我们需要提供一个函数
$g : \prd{x:A} B(x) \to C$，然后我们可以通过定义
\[ f(\tup{a}{b}) \defeq g(a)(b). \]
来定义 $f$。
\indexdef{projection!from dependent pair type}%
例如，我们可以从 $\Sigma$-type 中推导出第一个投影：
\symlabel{defn:dependent-proj1}%
\begin{equation*}
\fst : \Parens{\sm{x : A}B(x)} \to A
\end{equation*}
通过定义方程
\begin{equation*}
\fst(\tup{a}{b}) \defeq a.
\end{equation*}
然而，由于一对的第二个分量的类型
\narrowequation{
(a,b):\sm{x:A} B(x)
}
是 $B(a)$，第二个投影必须是\emph{依赖的}函数，其类型涉及第一个投影函数：
\symlabel{defn:dependent-proj2}%
\[ \snd : \prd{p:\sm{x : A}B(x)}B(\fst(p)). \]
因此我们需要 \emph{归纳原理}%
\index{induction principle!for dependent pair type}
对于 $\Sigma$-types（即“依赖消解器”）。
这表明，为了构造从 $\Sigma$-type 到家族 $C : (\sm{x:A} B(x)) \to \UU$ 的依赖函数，我们需要一个函数
\[ g : \prd{a:A}{b:B(a)} C(\tup{a}{b}). \]
然后我们可以导出一个函数
\[ f : \prd{p : \sm{x:A}B(x)} C(p) \]
定义方程为：\index{computation rule!for dependent pair type}
\[ f(\tup{a}{b}) \defeq g(a)(b).\]
应用此定义 $C(p)\defeq B(\fst(p))$，我们可以定义
\narrowequation{
\snd : \prd{p:\sm{x : A}B(x)}B(\fst(p))
}
方程为
\[ \snd(\tup{a}{b})  \defeq  b. \]
为了确认这是正确的，我们注意到 $B (\fst(\tup{a}{b})) \jdeq B(a)$，使用 $\fst$ 的定义方程，并且
确实 $b : B(a)$。

我们可以将递归和归纳原理打包到 $\Sigma$ 的递归器中：
\symlabel{defn:recursor-sm}%
\[ \rec{\sm{x:A}B(x)} : \dprd{C:\UU}\Parens{\tprd{x:A} B(x) \to C} \to
\Parens{\tsm{x:A}B(x)} \to C \]
定义方程为：
\[ \rec{\sm{x:A}B(x)}(C,g,\tup{a}{b}) \defeq g(a)(b) \]
以及相应的归纳操作符：
\symlabel{defn:induction-sm}%
\begin{narrowmultline*}
\ind{\sm{x:A}B(x)} : \narrowbreak
\dprd{C:(\sm{x:A} B(x)) \to \UU}
\Parens{\tprd{a:A}{b:B(a)} C(\tup{a}{b})}
\to \dprd{p : \sm{x:A}B(x)} C(p)
\end{narrowmultline*}
定义方程为：
\[ \ind{\sm{x:A}B(x)}(C,g,\tup{a}{b}) \defeq g(a)(b). \]
如前所述，当 $C$ 是常数时，递归器是归纳的特例。

再举一个例子，考虑以下原则，其中 $A$ 和 $B$ 是类型，$R:A\to B\to \UU$：
\[ \ac : \Parens{\tprd{x:A} \tsm{y :B} R(x,y)} \to
\Parens{\tsm{f:A\to B} \tprd{x:A} R(x,f(x))}.
\]
我们可以将 $R$ 视为 $A$ 和 $B$ 之间的“与证明相关的关系”\index{mathematics!proof-relevant}%
，其中 $R(a,b)$ 是 $a:A$ 和 $b:B$ 相关性的见证类型。
然后 \ac 直观地表明，如果我们有一个依赖函数 $g$，它为每个 $a:A$ 分配一个依赖对 $(b,r)$，其中 $b:B$ 和 $r:R(a,b)$，那么我们有一个函数 $f:A\to B$，并为每个 $a:A$ 分配一个见证，证明 $R(a,f(a))$。
我们的直觉告诉我们，我们可以将 $g$ 的值分解为它们的分量。
实际上，使用我们刚刚定义的投影，我们可以定义：
\[ \ac(g) \defeq \Parens{\lamu{x:A} \fst(g(x)),\, \lamu{x:A} \snd(g(x))}. \]
为了验证这是否是良类型的，注意到如果 $g:\prd{x:A} \sm{y :B} R(x,y)$，我们有
\begin{align*}
\lamu{x:A} \fst(g(x)) &: A \to  B, \\
\lamu{x:A} \snd(g(x)) &: \tprd{x:A} R(x,\fst(g(x))).
\end{align*}
此外，类型 $\prd{x:A} R(x,\fst(g(x)))$ 是将 $\ac$ 的余域中的类型家族 $\lamu{f:A\to B} \tprd{x:A} R(x,f(x))$ 应用于函数 $\lamu{x:A} \fst(g(x))$ 的结果：
\[ \tprd{x:A} R(x,\fst(g(x))) \jdeq
\Parens{\lamu{f:A\to B} \tprd{x:A} R(x,f(x))}\big(\lamu{x:A} \fst(g(x))\big). \]
因此，我们有
\[ \Parens{\lamu{x:A} \fst(g(x)),\, \lamu{x:A} \snd(g(x))} : \tsm{f:A\to B} \tprd{x:A} R(x,f(x))\]
如要求所示。

如果我们将 $\Pi$ 读作“对于所有”而将 $\Sigma$ 读作“存在”，那么函数 \ac 的类型表示：
\emph{如果对于所有 $x:A$ 存在 $y:B$ 使得 $R(x,y)$，那么存在一个函数 $f : A \to B$ 使得对于所有 $x:A$ 我们有 $R(x,f(x))$}。
由于这听起来像选择公理的一个版本，函数 \ac 传统上被称为\define{类型论的选择公理}（type-theoretic axiom of choice），如我们刚才所示，它可以直接从类型论的规则中证明，而不必作为公理。
\index{axiom!of choice!type-theoretic}%
然而，注意到实际上没有涉及选择，因为选择已经在前提中给出：我们所要做的就是将其分解为两个函数：一个表示选择，另一个表示其正确性。
在 \cref{sec:axiom-choice} 中，我们将给出一个更接近通常选择公理的“选择公理”的另一个表述。

依赖对类型通常用于定义数学结构的类型，这些结构通常由多个依赖数据构成。
举一个简单的例子，假设我们要定义一个\define{magma}\indexdef{magma}，它是一个类型 $A$ 以及一个二元运算 $m:A\to A\to A$。
短语“together with”\index{together with}（以及同义的“equipped with”\index{equipped with}）的精确含义是“一个 magma”是一个\emph{对} $(A,m)$，其中包含类型 $A:\UU$ 和运算 $m:A\to A\to A$。
由于这个对的第二个分量 $m$ 的类型 $A\to A\to A$ 依赖于其第一个分量 $A$，因此这些对属于依赖对类型。
因此，定义“一个 magma 是一个类型 $A$ 和一个二元运算 $m:A\to A\to A$”应理解为定义\emph{magma 的类型}为
\[ \mathsf{Magma} \defeq \sm{A:\UU} (A\to A\to A). \]
给定一个 magma，我们可以使用第一个投影 $\proj1$ 提取其基础类型（即其“载体”\index{carrier}），并使用第二个投影 $\proj2$ 提取其运算。
当然，由多个数据构建的结构需要迭代对类型，这些对类型可能只是部分依赖的；例如，带基点的 magma（即配备有基点 $e:A$ 的 magma $(A,m)$）的类型为
\[ \mathsf{PointedMagma} \defeq \sm{A:\UU} (A\to A\to A) \times A. \]
我们通常还希望对这样的结构施加公理，例如将带基点的 magma 转变为单子或群。
这也可以使用 $\Sigma$-types 来完成；见 \cref{sec:pat}。

在本书的其余部分，我们有时会明确地进行这样的定义，但最终我们信任读者将其从英语翻译成 $\Sigma$-types。
我们还通常遵循常见的数学惯例，使用相同的字母表示这种结构及其载体（这意味着在符号中隐含地省略适当的投影函数）：也就是说，我们将使用带有运算 $m:A\to A\to A$ 的 magma $A$。

注意，$\mathsf{PointedMagma}$ 的典型元素的形式为 $(A,(m,e))$，其中 $A:\UU$，$m:A\to A\to A$，$e:A$。
由于这种迭代 $\Sigma$-types 频繁出现，我们使用通常的有序三元组、四元组等符号来表示依赖的嵌套对，默认向右结合。
也就是说，我们有 $(x,y,z) \defeq (x,(y,z))$ 和 $(x,y,z,w)\defeq (x,(y,(z,w)))$，等等。

\index{type!dependent pair|)}%
\section{余积类型（Coproduct types）}
\label{sec:coproduct-types}

给定 $A,B:\UU$，我们引入它们的\define{余积类型}（coproduct type）$A+B:\UU$。
\indexsee{coproduct}{type, coproduct}%
\index{type!coproduct|(defstyle}%
\indexsee{disjoint!sum}{type, coproduct}%
\indexsee{disjoint!union}{type, coproduct}%
\indexsee{sum!disjoint}{type, coproduct}%
\indexsee{union!disjoint}{type, coproduct}%
这在集合论中对应于\emph{不交并}（disjoint union），我们也可以用这个名称。在类型论中，与函数和积类型的情况一样，余积必须是一种基础构造，因为没有“类型联合”的预定义概念。
我们还引入一个零元版本：\define{空类型（empty type）$\emptyt:\UU$}。
\indexsee{nullary!coproduct}{type, empty}%
\indexsee{empty type}{type, empty}%
\index{type!empty|(defstyle}%

构造 $A+B$ 的元素有两种方式，要么是 $\inl(a) : A+B$ 其中 $a:A$，要么是 $\inr(b):A+B$ 其中 $b:B$。
（名称 $\inl$ 和 $\inr$ 分别是“左注入”（left injection）和“右注入”（right injection）的缩写。）
没有构造空类型元素的方法。

\index{recursion principle!for coproduct}
要构造从 $A+B$ 到 $C$ 的非依赖函数 $f : A+B \to C$，我们需要提供函数 $g_0 : A \to C$ 和 $g_1 : B \to C$。然后 $f$ 的定义如下：
\begin{align*}
  f(\inl(a)) &\defeq g_0(a), \\
  f(\inr(b)) &\defeq g_1(b).
\end{align*}
也就是说，函数 $f$ 是通过\define{情况分析}（case analysis）定义的。
\indexdef{case analysis}%
同样，我们可以导出余积类型的递归器：
\symlabel{defn:recursor-plus}%
\[ \rec{A+B} : \dprd{C:\UU}(A \to C) \to (B\to C) \to A+B \to C\]
其定义方程为：
\begin{align*}
\rec{A+B}(C,g_0,g_1,\inl(a)) &\defeq g_0(a), \\
\rec{A+B}(C,g_0,g_1,\inr(b)) &\defeq g_1(b).
\end{align*}

\index{recursion principle!for empty type}
我们总是可以构造一个从 $\emptyt$ 到 $C$ 的函数 $f : \emptyt \to C$，因为在 $\emptyt$ 上没有元素可以定义 $f$。
因此，$\emptyt$ 的递归器为：
\symlabel{defn:recursor-emptyt}%
\[\rec{\emptyt} : \tprd{C:\UU} \emptyt \to C,\]
其构造了从空类型到任何其他类型的规范函数。从逻辑上讲，它对应于原理\textit{ex falso quodlibet}。
\index{ex falso quodlibet@\textit{ex falso quodlibet}}

\index{induction principle!for coproduct}
要从余积中构造依赖函数 $f:\prd{x:A+B}C(x)$，我们假设给定了家族
$C: (A + B) \to \UU$，并且需要提供：
\begin{align*}
  g_0 &: \prd{a:A} C(\inl(a)), \\
  g_1 &: \prd{b:B} C(\inr(b)).
\end{align*}
这样我们可以得到 $f$，定义方程为：\index{computation rule!for coproduct type}
\begin{align*}
  f(\inl(a)) &\defeq g_0(a), \\
  f(\inr(b)) &\defeq g_1(b).
\end{align*}
我们将这个方案打包成余积类型的归纳原理：
\symlabel{defn:induction-plus}%
\begin{narrowmultline*}
  \ind{A+B} :
  \dprd{C: (A + B) \to \UU}
  \Parens{\tprd{a:A} C(\inl(a))} \to \narrowbreak
  \Parens{\tprd{b:B} C(\inr(b))} \to \tprd{x:A+B}C(x).
\end{narrowmultline*}
同样，递归器出现在 $C$ 是常量的情况下。

\index{induction principle!for empty type}
空类型的归纳原理
\symlabel{defn:induction-emptyt}%
\[ \ind{\emptyt} : \prd{C:\emptyt \to \UU}{z:\emptyt} C(z) \]
提供了一种从空类型中定义一个琐碎的依赖函数的方法。 % In the presence of $\eta$-equality it is derivable
% from the recursor.
% ex

\index{type!coproduct|)}%
\index{type!empty|)}%
\section{布尔类型（The type of booleans）}
\label{sec:type-booleans}

\indexsee{boolean!type of}{type of booleans}%
\index{type!of booleans|(defstyle}%
布尔类型 $\bool:\UU$ 被设计为只有两个元素
$\bfalse,\btrue : \bool$。很显然，我们可以将这个类型构造为余积类型
\index{type!coproduct}%
和单位类型\index{type!unit} 的余积 $\unit + \unit$。然而，由于它的频繁使用，我们在这里给出显式规则。
实际上，我们还将观察到，我们也可以通过 $\Sigma$-types 和 $\bool$ 导出二元余积。

\index{recursion principle!for type of booleans}
要导出一个函数 $f : \bool \to C$，我们需要 $c_0,c_1 : C$，并添加定义方程：
\begin{align*}
f(\bfalse) &\defeq c_0, \\
f(\btrue)  &\defeq c_1.
\end{align*}
递归器对应于函数式编程中的 if-then-else 构造：
\symlabel{defn:recursor-bool}%
\[ \rec{\bool} : \prd{C:\UU}  C \to C \to \bool \to C \]
定义方程为：
\begin{align*}
\rec{\bool}(C,c_0,c_1,\bfalse) &\defeq c_0, \\
\rec{\bool}(C,c_0,c_1,\btrue)  &\defeq c_1.
\end{align*}

\index{induction principle!for type of booleans}
给定 $C : \bool \to \UU$，要导出依赖函数
$f : \prd{x:\bool}C(x)$，我们需要 $c_0:C(\bfalse)$ 和 $c_1 : C(\btrue)$，在这种情况下我们可以给出定义方程：
\begin{align*}
f(\bfalse) &\defeq c_0, \\
f(\btrue)  &\defeq c_1.
\end{align*}
我们将其打包为归纳原理：
\symlabel{defn:induction-bool}%
\[ \ind{\bool} : \dprd{C:\bool \to \UU}  C(\bfalse) \to C(\btrue)
\to \tprd{x:\bool} C(x) \]
定义方程为：
\begin{align*}
\ind{\bool}(C,c_0,c_1,\bfalse) &\defeq c_0, \\
\ind{\bool}(C,c_0,c_1,\btrue)  &\defeq c_1.
\end{align*}

例如，使用归纳原理，我们可以推导出，如预期的那样，布尔类型的每个元素要么是 $\btrue$，要么是 $\bfalse$。
同样，为了陈述这个结果，我们使用尚未介绍的等式类型，但我们只需要知道每个元素都等于它自身，即 $\refl{x}:x=x$。
因此，我们构造了一个元素：
\begin{equation}\label{thm:allbool-trueorfalse}
\prd{x:\bool}(x=\bfalse)+(x=\btrue),
\end{equation}
即：给每个 $x:\bool$ 赋予一个等式 $x=\bfalse$ 或一个等式 $x=\btrue$。
我们使用 $\bool$ 的归纳原理定义这个元素，其中 $C(x) \defeq (x=\bfalse)+(x=\btrue)$；
两个输入分别是 $\inl(\refl{\bfalse}) : C(\bfalse)$ 和 $\inr(\refl{\btrue}):C(\btrue)$。
换句话说，我们构造的元素为：
\[ \ind{\bool}\big(\lam{x}(x=\bfalse)+(x=\btrue),\, \inl(\refl{\bfalse}),\, \inr(\refl{\btrue})\big). \]

我们已经指出，$\Sigma$-types 可以看作是类似于索引不交并，而余积是二元不交并。
自然地，我们期望二元不交并 $A+B$ 可以通过两元素类型 $\bool$ 构造为一个索引不交并。
为此，我们需要一个类型族 $P:\bool\to\type$，使得 $P(\bfalse)\jdeq A$ 且 $P(\btrue)\jdeq B$。
实际上，我们可以通过 $\bool$ 的递归原理得到这样的家族。
\index{type!family of}%
（使用归纳和递归定义\emph{类型族}的能力，利用宇宙 $\UU$ 也是一个类型的事实，是类型论的一个微妙而重要的方面。）
因此，我们可以定义：
\index{type!coproduct}%
\[ A + B \defeq \sm{x:\bool} \rec{\bool}(\UU,A,B,x) \]
其构造方法如下：
\begin{align*}
\inl(a) &\defeq \tup{\bfalse}{a}, \\
\inr(b) &\defeq \tup{\btrue}{b}.
\end{align*}
我们留作练习，将这一定义中的余积类型的归纳原理推导出来。
（参见 \cref{ex:sum-via-bool,sec:appetizer-univalence}。）

我们可以将同样的想法应用于积类型（products）和 $\Pi$-types：我们可以定义
\[ A \times B \defeq \prd{x:\bool}\rec{\bool}(\UU,A,B,x). \]
然后使用 $\bool$ 的归纳构造对的类型：
\[ \tup{a}{b} \defeq \ind{\bool}(\rec{\bool}(\UU,A,B),a,b) \]
而投影函数则为直接应用：
\begin{align*}
\fst(p) &\defeq p(\bfalse), \\
\snd(p) &\defeq p(\btrue).
\end{align*}
以这种方式定义二元积的归纳原理的推导稍微复杂一些，并且需要函数外延性（function extensionality），我们将在 \cref{sec:compute-pi} 中介绍。
此外，我们并没有得到相同的判断性等式；参见 \cref{ex:prod-via-bool}。
这是在用一种类型编码另一种类型时经常出现的问题；我们将在 \cref{sec:htpy-inductive} 中再次讨论它。

我们偶尔会将 $\bool$ 的元素 $\bfalse$ 和 $\btrue$ 分别称为“假”（false）和“真”（true）。
然而，请注意，与经典\index{mathematics!classical} 数学不同，我们不使用 $\bool$ 的元素作为真值
\index{value!truth}%
或命题。
（相反，我们将命题与类型等同；参见 \cref{sec:pat}。）
特别是，类型 $A \to \bool$ 一般不是 $A$ 的幂集\index{power set}；它仅表示 $A$ 的“可判定”子集（参见 \cref{cha:logic}）。
\index{decidable!subset}%

\index{type!of booleans|)}%


\section{自然数（The natural numbers）}
\label{sec:inductive-types}

\indexsee{type!of natural numbers}{natural numbers}%
\index{natural numbers|(defstyle}%
\indexsee{number!natural}{natural numbers}%
到目前为止，我们已经有了通过抽象操作构造新类型的规则，但是为了进行具体的数学操作，我们还需要一些具体的类型，比如数字类型。
最基本的这种类型是自然数的类型 $\nat : \UU$；一旦我们有了这个，我们就可以构造整数、有理数、实数，等等（见 \cref{cha:real-numbers}）。

$\nat$ 的元素是通过 $0 : \nat$\indexdef{zero} 和后继\indexdef{successor} 操作 $\suc : \nat \to \nat$ 来构造的。
在表示自然数时，我们采用通常的十进制表示法，如 $1 \defeq \suc(0)$，$2 \defeq \suc(1)$，$3 \defeq \suc(2)$，依此类推。

自然数的一个基本属性是我们可以通过递归定义函数，并通过归纳进行证明——这里的“递归”和“归纳”有了更为熟悉的含义。
\index{recursion principle!for natural numbers}%
为了通过递归从自然数中构造一个非依赖函数 $f : \nat \to C$，只需提供一个起始点 $c_0 : C$ 和一个“下一步”函数 $c_s : \nat \to C \to C$。
这产生了一个定义方程为\index{computation rule!for natural numbers} 的 $f$：
\begin{align*}
f(0) &\defeq c_0, \\
f(\suc(n)) &\defeq c_s(n,f(n)).
\end{align*}
我们说 $f$ 是通过\define{原始递归}定义的。
\indexdef{primitive!recursion}%
\indexdef{recursion!primitive}%

例如，我们看看如何定义一个在自然数上的函数，该函数将其参数加倍。
在这种情况下，我们有 $C\defeq \nat$。
首先，我们需要提供 $\dbl(0)$ 的值，这很容易：我们设定 $c_0 \defeq 0$。
接下来，要计算 $\dbl(\suc(n))$ 的值，我们首先计算 $\dbl(n)$ 的值，然后执行两次后继操作。
这通过递推公式\index{recurrence} $c_s(n,y) \defeq \suc(\suc(y))$ 表示。
注意，$c_s$ 的第二个参数 $y$ 代表\emph{递归调用}\index{recursive call} $\dbl(n)$ 的结果。

通过这种方式，用原始递归定义 $\dbl:\nat\to\nat$，因此我们得到定义方程：
\begin{align*}
\dbl(0) &\defeq 0\\
\dbl(\suc(n)) &\defeq \suc(\suc(\dbl(n))).
\end{align*}
这确实具有正确的计算行为：例如，我们有
\begin{align*}
\dbl(2) &\jdeq \dbl(\suc(\suc(0)))\\
& \jdeq c_s(\suc(0), \dbl(\suc(0))) \\
& \jdeq \suc(\suc(\dbl(\suc(0)))) \\
& \jdeq \suc(\suc(c_s(0,\dbl(0)))) \\
& \jdeq \suc(\suc(\suc(\suc(\dbl(0))))) \\
& \jdeq \suc(\suc(\suc(\suc(c_0)))) \\
& \jdeq \suc(\suc(\suc(\suc(0))))\\
&\jdeq 4.
\end{align*}
我们也可以通过原始递归定义多变量函数，通过柯里化并允许 $C$ 是一个函数类型。
\indexdef{addition!of natural numbers}
例如，我们定义加法 $\add : \nat \to \nat \to \nat$，其中 $C \defeq \nat \to \nat$，并使用以下“起始点”和“下一步”数据：
\begin{align*}
c_0 & : \nat \to \nat \\
c_0 (n) & \defeq n \\
c_s & : \nat \to (\nat \to \nat) \to (\nat \to \nat) \\
c_s(m,g)(n) & \defeq \suc(g(n)).
\end{align*}
我们因此得到 $\add : \nat \to \nat \to \nat$，其满足定义等式
\begin{align*}
\add(0,n) &\jdeq n \\
\add(\suc(m),n) &\jdeq \suc(\add(m,n)).
\end{align*}
通常，我们将 $\add(m,n)$ 写作 $m+n$。
读者可以验证 $2+2\jdeq 4$。
% ex: define multiplication and exponentiation.

与之前的情况一样，我们可以将原始递归的原则打包成一个递归器：
\[\rec{\nat}  : \dprd{C:\UU} C \to (\nat \to C \to C) \to \nat \to C \]
定义等式为
\symlabel{defn:recursor-nat}%
\begin{align*}
\rec{\nat}(C,c_0,c_s,0)  &\defeq c_0, \\
\rec{\nat}(C,c_0,c_s,\suc(n)) &\defeq c_s(n,\rec{\nat}(C,c_0,c_s,n)).
\end{align*}
%ex derive rec from it
使用 $\rec{\nat}$，我们可以如下表示 $\dbl$ 和 $\add$：
\begin{align}
\dbl &\defeq \rec\nat\big(\nat,\, 0,\, \lamu{n:\nat}{y:\nat} \suc(\suc(y))\big) \label{eq:dbl-as-rec}\\
\add &\defeq \rec{\nat}\big(\nat \to \nat,\, \lamu{n:\nat} n,\, \lamu{m:\nat}{g:\nat \to \nat}{n :\nat} \suc(g(n))\big).
\end{align}
当然，只使用原始递归原则定义的所有函数都将是\emph{可计算的}。
（然而，存在更高的函数类型——即以其他函数为参数的函数——意味着我们可以定义比通常的原始递归函数更多的内容；例如，参见~\cref{ex:ackermann}。）
这在构造性数学中是适当的；
\index{mathematics!constructive}%
在 \cref{sec:intuitionism,sec:axiom-choice} 中，我们将看到如何增强类型论，以便定义更一般的数学函数。

\index{induction principle!for natural numbers}
现在我们遵循与其他类型相同的方法，将原始递归推广到依赖函数，从而获得\emph{归纳原理}。
因此，假设给定一个类型族 $C : \nat \to \UU$，一个元素 $c_0 : C(0)$，以及一个函数 $c_s : \prd{n:\nat} C(n) \to C(\suc(n))$；然后我们可以构造一个函数 $f : \prd{n:\nat} C(n)$，其定义等式为：\index{computation rule!for natural numbers}
\begin{align*}
f(0) &\defeq c_0, \\
f(\suc(n)) &\defeq c_s(n,f(n)).
\end{align*}
我们也可以将其打包为一个函数
\symlabel{defn:induction-nat}%
\[\ind{\nat}  : \dprd{C:\nat\to \UU} C(0) \to \Parens{\tprd{n : \nat} C(n) \to C(\suc(n))} \to \tprd{n : \nat} C(n) \]
其定义等式为：
\begin{align*}
\ind{\nat}(C,c_0,c_s,0)  &\defeq c_0, \\
\ind{\nat}(C,c_0,c_s,\suc(n)) &\defeq c_s(n,\ind{\nat}(C,c_0,c_s,n)).
\end{align*}
在这里，我们终于看到了与经典归纳证明的联系。
回想一下，在类型论中，我们用类型表示命题，并通过填充对应的类型来证明命题。
特别是，自然数的\emph{性质}由类型族 $P:\nat\to\type$ 表示。
从这个角度看，上述归纳原理表明，如果我们可以证明 $P(0)$，并且对于任何 $n$，如果我们假设 $P(n)$ 成立，那么我们可以证明 $P(\suc(n))$，那么我们就有 $P(n)$ 对所有 $n$ 都成立。
当然，这正是经典的自然数归纳证明原则。

\index{associativity!of addition!of natural numbers}
例如，考虑我们如何表示一个显式证明，即 $+$ 是结合的。
（我们实际上不会以这种风格写出证明，但它作为理解归纳在类型论中的形式表示的有用例子。）
要推导出
\[\assoc : \prd{i,j,k:\nat} \id{i + (j + k)}{(i + j) + k}, \]
我们需要提供
\[ \assoc_0 :  \prd{j,k:\nat} \id{0 + (j + k)}{(0+ j) + k} \]
和
\begin{narrowmultline*}
\assoc_s  : \prd{i:\nat} \left(\prd{j,k:\nat} \id{i + (j + k)}{(i + j) + k}\right)
\narrowbreak
\to \prd{j,k:\nat} \id{\suc(i) + (j + k)}{(\suc(i) + j) + k}.
\end{narrowmultline*}
为了推导出 $\assoc_0$，请回想 $0+n \jdeq n$，因此 $0 + (j + k) \jdeq j+k \jdeq (0+ j) + k$。
因此，我们可以简单地设定
\[ \assoc_0(j,k) \defeq \refl{j+k}. \]
对于 $\assoc_s$，请回想加法定义给出了 $\suc(m)+n \jdeq \suc(m+n)$，因此
\begin{align*}
\suc(i) + (j + k)  &\jdeq \suc(i+(j+k)) \qquad\text{and}\\
(\suc(i)+j)+k &\jdeq \suc((i+j)+k).
\end{align*}
因此，$\assoc_s$ 的输出类型等价于 $\id{\suc(i+(j+k))}{\suc((i+j)+k)}$。
但它的输入（“归纳假设”）
\index{hypothesis!inductive}%
\index{inductive!hypothesis}%
给出了 $\id{i+(j+k)}{(i+j)+k}$，所以只需要调用一个事实，即如果两个自然数相等，那么它们的后继也是相等的。
（我们将在 \cref{lem:map} 中使用同一类型的归纳原理证明这一显而易见的事实。）
我们称这个事实为
$\apfunc{\suc} : %\prd{m,n:\nat}
(\id[\nat]{m}{n}) \to (\id[\nat]{\suc(m)}{\suc(n)})$，因此我们可以定义
\[\assoc_s(i,h,j,k) \defeq \apfunc{\suc}( %n+(j+k),(n+j)+k,
h(j,k)). \]
将这些与 $\ind{\nat}$ 结合起来，我们得到一个结合律的证明。

\index{natural numbers|)}%


\section{模式匹配和递归（Pattern matching and recursion）}
\label{sec:pattern-matching}

\index{pattern matching|(defstyle}%
\indexsee{matching}{pattern matching}%
\index{definition!by pattern matching|(}%
自然数比之前考虑的类型引入了额外的复杂性。
例如，对于并集，我们可以定义一个函数 $f:A+B\to C$，要么使用递归器：
\[ f \defeq \rec{A+B}(C, g_0, g_1) \]
或者通过给出定义方程：
\begin{align*}
f(\inl(a)) &\defeq g_0(a)\\
f(\inr(b)) &\defeq g_1(b).
\end{align*}
从 $f$ 的前者表达式到后者，我们只需使用递归器的计算规则。
反之，给定任意定义方程
\begin{align*}
f(\inl(a)) &\defeq \Phi_0\\
f(\inr(b)) &\defeq \Phi_1
\end{align*}
其中 $\Phi_0$ 和 $\Phi_1$ 是可能涉及变量 $a$ 和 $b$ 的表达式，我们可以通过使用 $\lambda$-抽象\index{lambda abstraction@$\lambda$-abstraction} 将这些方程等价地表示为递归器：
\[ f\defeq \rec{A+B}(C, \lam{a} \Phi_0, \lam{b} \Phi_1).\]
然而，在自然数的情况下，像 $\dbl$ 这样的函数的“定义方程”：
\begin{align}
\dbl(0) &\defeq 0 \label{eq:dbl0}\\
\dbl(\suc(n)) &\defeq \suc(\suc(\dbl(n)))\label{eq:dblsuc}
\end{align}
涉及到\emph{函数 $\dbl$ 本身} 在右侧。
然而，我们仍然希望能够给出这些方程，而不是~\eqref{eq:dbl-as-rec}，作为 \dbl 的定义，因为它们更方便和可读。
解决方案是将~\eqref{eq:dblsuc} 右侧的“$\dbl(n)$”表达式理解为递归调用的结果，在形式为 $\dbl\defeq \rec{\nat}(\nat,c_0,c_s)$ 的定义中，这将是 $c_s$ 的第二个参数。

更一般地说，如果我们有一个形式为 $f:\nat\to C$ 的函数的“定义”，比如
\begin{align*}
f(0) &\defeq \Phi_0\\
f(\suc(n)) &\defeq \Phi_s
\end{align*}
其中 $\Phi_0$ 是类型为 $C$ 的表达式，而 $\Phi_s$ 是类型为 $C$ 的表达式，可能涉及变量 $n$ 以及符号“$f(n)$”，我们可以将其翻译为定义
\[ f \defeq \rec{\nat}(C,\,\Phi_0,\,\lam{n}{r} \Phi_s') \]
其中 $\Phi_s'$ 是通过将“$f(n)$”的所有出现替换为新变量 $r$ 而得到的。

这种通过递归定义函数（或更一般地，通过归纳定义依赖函数）的风格是如此方便，我们经常采用它。
这称为\define{模式匹配}定义。
当然，它与计算机程序员可能定义一个递归函数并且函数体实际上包含对自身的递归调用非常相似。
然而，与程序员不同的是，我们在可以进行递归调用的类型上受到限制：为了使这种定义能够用递归原则重新表达，正在定义的函数 $f$ 只能在 $f(\suc(n))$ 的函数体中作为复合符号“$f(n)$”的一部分出现。
否则，我们可以写出无意义的函数，如
\begin{align*}
f(0)&\defeq 0\\
f(\suc(n)) &\defeq f(\suc(\suc(n))).
\end{align*}
如果程序员写了这样一个函数，它只会对任何正输入调用自身永远不停，进入无限循环，永远不返回值。
然而，在数学中，为了配得上“函数”这个名字，\emph{函数}必须始终为每个输入值关联一个唯一的输出值，因此这是不可接受的。

当我们在 \cref{cha:induction,cha:hits,cha:real-numbers} 中引入更复杂的归纳类型时，这一点将变得更加重要。
每当我们引入一种新的归纳定义时，我们总是首先推导它的归纳原理。
然后我们引入一种适当的“模式匹配”，可以将其证明为归纳原理的简写。

\index{pattern matching|)}%
\index{definition!by pattern matching|)}%

\section{命题作为类型（Propositions as types）}
\label{sec:pat}

\index{proposition!as types|(defstyle}%
\index{logic!propositions as types|(}%
如引言中所述，在类型论中要证明某个命题为真，相当于展示一个对应于该命题的类型的元素。
\index{evidence, of the truth of a proposition}%
\index{witness!to the truth of a proposition}%
\index{proof|(}
我们将该类型的元素视为该命题为真的\emph{证据}或\emph{见证}。（有时它们甚至被称为\emph{证明}，但这个术语可能会引起误解，所以我们一般避免使用它。）
然而，通常情况下，我们不会显式地构造见证；相反，我们会以普通数学语言呈现证明，使其可以翻译为某种类型的元素。
这与经典集合论中的推理没有什么不同，在经典集合论中，我们也不期望看到使用谓词逻辑规则和集合论公理的明确推导。

然而，类型论对证明的视角在某些重要方面还是有所不同。
类型论逻辑的基本原则是，一个命题不仅仅是对还是错，而是可以看作其真理的所有可能见证的集合。
在这种观念下，证明不仅仅是数学交流的手段，它们本身就是数学对象，与数字、映射、群等更为熟悉的对象同等重要。
因此，由于类型分类了可用的数学对象并规范了它们的交互方式，命题实际上只是特殊的类型——即，其元素为证明的类型。

\index{propositional!logic}%
\index{logic!propositional}%
促使这种认同成为可能的基本观察是，我们在命题的\emph{逻辑}运算（用英语表达）和它们对应的见证类型的\emph{类型论}运算之间有如下自然的对应关系。
\index{false}%
\index{true}%
\index{conjunction}%
\index{disjunction}%
\index{implication}%
\begin{center}
\medskip
\begin{tabular}{ll}
\toprule
英语 & 类型论\\
\midrule
真 & $\unit$ \\
假 & $\emptyt$ \\
$A$ 和 $B$ & $A \times B$ \\
$A$ 或 $B$ & $A + B$ \\
如果 $A$ 则 $B$ & $A \to B$ \\
$A$ 当且仅当 $B$ & $(A \to B) \times (B \to A)$ \\
非 $A$ &  $A \to \emptyt$ \\
\bottomrule
\end{tabular}
\medskip
\end{center}

这个对应关系的要点在于，每种情况下，右边类型的元素构造和使用规则对应于左边命题的推理规则。
例如，要证明形式为“$A$ 和 $B$”的陈述的基本方法是证明 $A$ 并同时证明 $B$，而构造 $A\times B$ 的元素的基本方法是构造一个对 $(a,b)$，其中 $a$ 是 $A$ 的一个元素（或见证），$b$ 是 $B$ 的一个元素（或见证）。
如果我们想要利用“$A$ 和 $B$”来证明其他东西，我们可以在证明过程中自由使用 $A$ 和 $B$，类似于 $A\times B$ 的归纳原则允许我们通过使用 $A$ 和 $B$ 的元素来构造一个函数。

类似地，证明一个蕴涵\index{implication}“如果 $A$ 则 $B$”的基本方法是假设 $A$ 并证明 $B$，而构造 $A\to B$ 元素的基本方法是给出一个表达式，该表达式表示 $B$ 的一个元素（见证），并且可能涉及一个未指定的 $A$ 类型的元素（见证）。
而利用蕴涵“如果 $A$ 则 $B$”的基本方法是，如果我们知道 $A$，则推导出 $B$，类似于我们可以将函数 $f:A\to B$ 应用于 $A$ 的一个元素来生成 $B$ 的一个元素。
我们强烈鼓励读者进行练习，验证其他类型构造器的规则是否合理地转化为逻辑。

特别值得注意的是，空类型 $\emptyt$ 对应于虚假。\index{false}
在逻辑上，我们将 $\emptyt$ 的一个元素称为\define{矛盾}：
\indexdef{矛盾}%
因此没有办法证明一个矛盾，%
\footnote{更准确地说，没有\emph{基本的}方法证明一个矛盾，即 $\emptyt$ 没有构造函数。
如果我们的类型论是不一致的，那么将会有一些更复杂的方法来构造一个 $\emptyt$ 的元素。}
而从一个矛盾中可以推导出任何东西。
我们还定义类型 $A$ 的\define{否定}
\indexdef{否定}%
为
%
\begin{equation*}
\neg A \ \defeq\ A \to \emptyt.
\end{equation*}
%
因此，$\neg A$ 的见证是一个从 $A \to \emptyt$ 的函数，我们可以通过假设 $x : A$ 并推导出 $\emptyt$ 的一个元素来构造它。
\index{proof!by contradiction}%
\index{logic!constructive vs classical}
注意，虽然我们得到的逻辑是“构造性的”，如引言中所讨论的，但这种“反证法”（假设 $A$ 并推导出矛盾，从而得出 $\neg A$）在构造性逻辑中是完全有效的：它只是调用了“否定”的\emph{意义}。
被禁止的那种“反证法”是，假设 $\neg A$ 并推导出矛盾，以此证明 $A$。
在构造性逻辑中，这样的论证只能让我们得出 $\neg\neg A$，读者可以验证，从 $\neg\neg A$（即，从 $(A\to \emptyt)\to\emptyt$）推导出 $A$ 是没有明显的方法的。

\mentalpause

上述逻辑连接词向类型构造操作的翻译被称为\define{命题作为类型}：它为我们提供了一种将用英语书写的命题及其证明翻译为类型及其元素的方法。
例如，假设我们要证明以下恒真式（“德摩根律”之一）：
\index{law!de Morgan's|(}%
\index{de Morgan's laws|(}%
\begin{equation}\label{eq:tautology1}
\text{\emph{“如果非 $A$ 且非 $B$，则非 ($A$ 或 $B$)”。}}
\end{equation}
这种事实的普通英语证明可能如下：
\begin{quote}
假设非 $A$ 且非 $B$，并且假设 $A$ 或 $B$；我们将得出一个矛盾。
有两种情况。
如果 $A$ 成立，那么由于非 $A$，我们有一个矛盾。
类似地，如果 $B$ 成立，那么由于非 $B$，我们也有一个矛盾。
因此，在任一情况下我们都有一个矛盾，所以非 ($A$ 或 $B$)。
\end{quote}
现在，根据上述规则，对应于我们的恒真式~\eqref{eq:tautology1} 的类型是
\begin{equation}\label{eq:tautology2}
(A\to \emptyt) \times (B\to\emptyt) \to (A+B\to\emptyt)
\end{equation}
因此我们应该能够将上述证明翻译为该类型的一个元素。

为了说明这种翻译的工作原理，让我们描述一下，一个数学家在阅读上述英语证明的同时，如何在脑海中构造出~\eqref{eq:tautology2} 的一个元素。
介绍性的短语“假设非 $A$ 且非 $B$”翻译为定义一个函数，隐含地应用了其定义域 $(A\to\emptyt)\times (B\to\emptyt)$ 的笛卡尔积的递归原理。
这引入了未命名的变量\index{variable}（假设\index{hypothesis}）类型为 $A\to\emptyt$ 和 $B\to\emptyt$。
在翻译为类型论时，我们必须给这些变量命名；我们称它们为 $x$ 和 $y$。
此时，我们可以写出~\eqref{eq:tautology2} 元素的部分定义为
\[ f((x,y)) \defeq\; \Box\;:A+B\to\emptyt \]
其中 $A+B\to\emptyt$ 类型的“空洞” $\Box$ 表示剩下的工作。
（我们可以等效地写成 $f \defeq \rec{(A\to\emptyt)\times (B\to\emptyt)}(A+B\to\emptyt,\lam{x}{y} \Box)$，使用递归器而不是模式匹配。）
下一短语“假设 $A$ 或 $B$；我们将推导出一个矛盾”指示通过函数定义填补这个空洞，介绍另一个未命名的假设 $z:A+B$，导致证明状态为：
\[ f((x,y))(z) \defeq \;\Box\; :\emptyt. \]
现在说“有两种情况”表示情况分裂，即应用 $A+B$ 的并集递归原理。
如果我们使用递归器写出来，它将是
\[ f((x,y))(z) \defeq \rec{A+B}(\emptyt,\lam{a} \Box,\lam{b}\Box,z) \]
如果我们使用模式匹配写出，它将是
\begin{align*}
f((x,y))(\inl(a)) &\defeq \;\Box\;:\emptyt\\
f((x,y))(\inr(b)) &\defeq \;\Box\;:\emptyt.
\end{align*}
请注意，在这两种情况下，我们现在都有两个类型为 $\emptyt$ 的“空洞”需要填补，对应于我们必须推导矛盾的两个情况。
最后，从 $a:A$ 和 $x:A\to\emptyt$ 推导矛盾的结论只是函数 $x$ 对 $a$ 的应用，类似地在另一种情况下也是如此。
\index{application!of hypothesis or theorem}%
（注意“应用函数”这个短语与“应用假设”或定理这个短语的巧合。）
因此，我们的最终定义是
\begin{align*}
f((x,y))(\inl(a)) &\defeq x(a)\\
f((x,y))(\inr(b)) &\defeq y(b).
\end{align*}

作为练习，你应该验证逆命题\emph{“如果非 ($A$ 或 $B$)，则（非 $A$）和（非 $B$）”}，通过展示一个元素
\[ ((A + B) \to \emptyt) \to (A \to \emptyt) \times (B \to \emptyt), \]
对于任意类型 $A$ 和 $B$，使用我们刚刚介绍的规则。

\index{logic!classical vs constructive|(}
然而，并非所有的经典\index{mathematics!classical}恒真式在这种解释下都成立。
例如，规则\emph{“如果非 ($A$ 和 $B$)，则（非 $A$）或（非 $B$）”}在一般情况下不成立：我们通常无法构造出对应类型的一个元素
\[ ((A \times B) \to \emptyt) \to (A \to \emptyt) + (B \to \emptyt).\]
这反映了类型论的“命题作为类型”逻辑是\emph{构造性的}。
这意味着它不包括某些经典原则，如排中律（\LEM{}）\index{excluded middle}或反证法\index{proof!by contradiction}，以及依赖于它们的其他原则，例如这个德摩根律的实例。
\index{law!de Morgan's|)}%
\index{de Morgan's laws|)}%

从哲学上讲，构造性逻辑之所以被称为“构造性”，是因为它只限于可以\emph{有效地}完成的构造，这意味着具有某种计算意义。
不必太精确地说，这意味着有某种算法\index{algorithm}指定了逐步构建对象的步骤（以及如何看到一个定理为真，作为一个特例）。
这要求省略 \LEM{}，因为没有\emph{有效的}\index{effective!procedure}程序来决定命题是真还是假。

类型论逻辑的构造性意味着它具有内在的计算意义，这对计算机科学家来说很有趣。
它还意味着类型论提供了\emph{公理自由}。\index{axiomatic freedom}
例如，虽然默认情况下没有见证 \LEM{} 存在的构造，但该逻辑仍然与其存在相容（见 \cref{sec:intuitionism}）。
因此，由于类型论并不\emph{否认} \LEM{}，我们可以一致地将其作为假设添加，并在不受限制的情况下进行常规操作。
在这一点上，类型论丰富了，而不是约束了传统的数学实践。

我们鼓励不熟悉构造性逻辑的读者通过一些更多的例子来熟悉它。
参见 \cref{ex:tautologies,ex:not-not-lem} 获取一些建议。
\index{logic!classical vs constructive|)}

\mentalpause

到目前为止，我们只讨论了命题逻辑。
\index{quantifier}%
\index{quantifier!existential}%
\index{quantifier!universal}%
\index{predicate!logic}%
\index{logic!predicate}%
现在我们考虑\emph{谓词}逻辑，在这种逻辑中，除了像“和”和“或”这样的逻辑连接词外，我们还有量词“存在”和“全称”。
在这种情况下，类型发挥了双重作用：它们既是命题，也作为类型的传统意义——即，我们量化的领域。
类型 $A$ 上的谓词表示为族 $P : A \to \UU$，将 $A$ 的每个元素 $a : A$ 映射到一个类型 $P(a)$，该类型对应于 $P$ 对 $a$ 成立的命题。我们现在通过对量词的解释来扩展上述翻译：
\begin{center}
\medskip
\begin{tabular}{ll}
\toprule
英语 & 类型论\\
\midrule
对所有 $x:A$，$P(x)$ 成立 & $\prd{x:A} P(x)$ \\
存在 $x:A$ 使得 $P(x)$ & $\sm{x:A}$ $P(x)$ \\
\bottomrule
\end{tabular}
\medskip
\end{center}
和以前一样，我们可以证明（构造性的）谓词逻辑的恒真式转化为可居住的类型。
例如，\emph{如果对于所有 $x:A$，$P(x)$ 和 $Q(x)$ 成立，则（对于所有 $x:A$，$P(x)$）和（对于所有 $x:A$，$Q(x)$）}可以翻译为
\[ (\tprd{x:A} P(x) \times Q(x)) \to (\tprd{x:A} P(x)) \times (\tprd{x:A} Q(x)). \]
这种恒真式的非正式证明可能如下：
\begin{quote}
假设对于所有 $x$，$P(x)$ 和 $Q(x)$ 成立。
首先，我们假设给定 $x$ 并证明 $P(x)$。
根据假设，我们有 $P(x)$ 和 $Q(x)$，因此我们有 $P(x)$。
其次，我们假设给定 $x$ 并证明 $Q(x)$。
同样根据假设，我们有 $P(x)$ 和 $Q(x)$，因此我们有 $Q(x)$。
\end{quote}
第一句话开始定义一个蕴涵作为函数，通过引入其假设的见证：\index{hypothesis}
\[ f(p) \defeq \;\Box\; : (\tprd{x:A} P(x)) \times (\tprd{x:A} Q(x)). \]
在这个例子中，使用配对构造器来生成一个积类型的元素有些明显，由“首先”和“其次”这些词有所标记：
\[ f(p) \defeq \Big( \;\Box\; : \tprd{x:A} P(x) \;,\; \Box\; : \tprd{x:A}Q(x) \;\Big). \]
短语“我们假设给定 $x$ 并证明 $P(x)$”现在表示以通常方式定义一个\emph{依赖}函数，引入一个变量\index{variable}作为其输入。
由于这是在配对构造器内部，因此自然地将其写为 $\lambda$-抽象\index{lambda abstraction@$\lambda$-abstraction}：
\[ f(p) \defeq \Big( \; \lam{x} \;\big(\Box\; : P(x)\big) \;,\; \Box\; : \tprd{x:A}Q(x) \;\Big). \]
现在，“我们有 $P(x)$ 和 $Q(x)$”调用假设，获得 $p(x) : P(x)\times Q(x)$，并且“因此我们有 $P(x)$”隐式地应用了适当的投影：
\[ f(p) \defeq \Big( \; \lam{x} \proj1(p(x))  \;,\; \Box\; : \tprd{x:A}Q(x) \;\Big). \]
接下来的两句话以显而易见的方式填补了另一个空洞：
\[ f(p) \defeq \Big( \; \lam{x} \proj1(p(x))  \;,\; \lam{x} \proj2(p(x)) \; \Big). \]
当然，我们一直使用的英语证明比数学家通常在实践中使用的要啰嗦得多；它们更像是“引论”课程中使用的语言。
实习数学家已经学会了填补空白，因此在实践中我们可以省略大量细节，并且我们通常会这样做。
然而，证明有效性的标准始终是，它们可以翻译回到构造对应类型的元素。

\symlabel{leq-nat}%
作为一个更具体的例子，考虑如何定义自然数的不等式。
一种自然的定义是，$n\le m$ 如果存在一个 $k:\nat$ 使得 $n+k=m$。
（这再次使用了我们将在下一节中介绍的同一性类型，但我们实际上不需要关于它们的太多内容。）
在“命题作为类型”翻译下，这将会产生：
\[ (n\le m) \defeq \sm{k:\nat} (\id{n+k}{m}). \]
我们邀请读者从这个定义中证明 $\le$ 的熟悉属性。
对于严格不等式，有几种自然的选择，如
\[ (n<m) \defeq \sm{k:\nat} (\id{n+\suc(k)}{m}) \]
或者
\[ (n<m) \defeq (n\le m) \times \neg(\id{n}{m}). \]
在构造数学中，前者更自然，但在这种情况下它实际上等价于后者，因为 $\nat$ 具有“可判定等式”（参见 \cref{sec:intuitionism,prop:nat-is-set}）。
\index{decidable!equality}%

类型 $\sm{x:A} P(x)$ 也有另一种解释。
由于它的一个元素是 $x:A$ 的一个元素以及 $P(x)$ 成立的一个见证，我们可以将 $\sm{x:A} P(x)$ 视为“存在 $x:A$ 使得 $P(x)$”的命题，而不是将其视为 $A$ 的“子类型”。
\index{subtype}%

我们将在 \cref{subsec:prop-subsets} 中回到这种解释。
现在我们注意到，它使我们能够将公理纳入\cref{sec:sigma-types} 中讨论的数学结构类型的定义中。
例如，假设我们要定义一个\define{半群}\index{semigroup}，即一个类型 $A$，配备一个二元运算 $m:A\to A\to A$（即一个\define{magma}\index{magma}），并且对于所有 $x,y,z:A$ 我们有 $m(x,m(y,z)) = m(m(x,y),z)$。
这个命题由类型表示
\[\prd{x,y,z:A} m(x,m(y,z)) = m(m(x,y),z),\]
因此，半群的类型为
\[ \semigroup \defeq \sm{A:\UU}{m:A\to A\to A} \prd{x,y,z:A} m(x,m(y,z)) = m(m(x,y),z), \]
即 $\mathsf{Magma}$ 的半群子类型。
从 $\semigroup$ 的一个元素中，我们可以通过应用适当的投影提取承载者 $A$、运算 $m$ 及其公理的见证。
我们将在 \cref{sec:equality-of-structures} 中回到这个例子。

还要注意，我们可以使用类型论中的宇宙表示“高阶逻辑”——即，我们可以对所有命题或所有谓词进行量化。
例如，我们可以表示命题\emph{对于所有性质 $P : A \to \UU$，如果 $P(a)$ 则 $P(b)$} 为
\[ \prd{P : A \to \UU} P(a) \to P(b) \]
其中 $A : \UU$ 且 $a,b : A$。
然而，这个命题\emph{先验地}存在于不同的、更高的宇宙中，比我们量化的命题要高：
\[ \Parens{\prd{P : A \to \UU_i} P(a) \to P(b)} : \UU_{i+1}. \]
我们将在 \cref{subsec:prop-subsets} 中回到这个问题。

\mentalpause

我们在这里描述了一个“证明相关的”
\index{mathematics!proof-relevant}%
命题的翻译，其中析取和存在陈述的证明携带一些信息。
例如，如果我们有一个 $A+B$ 的元素，将其视为“$A$ 或 $B$”的见证，那么我们知道它是来自 $A$ 还是 $B$。
同样，如果我们有 $\sm{x:A} P(x)$ 的一个元素，将其视为“存在 $x:A$ 使得 $P(x)$”的见证，那么我们知道元素 $x$ 是什么（它是给定元素的第一个投影）。

由于这种逻辑的证明相关性质，我们可能会遇到“$A$ 当且仅当 $B$”（回想一下，这意味着 $(A\to B)\times (B\to A)$），但类型 $A$ 和 $B$ 表现出不同的行为。
例如，很容易验证“$\mathbb{N}$ 当且仅当 $\unit$”，然而显然 $\mathbb{N}$ 和 $\unit$ 在重要方面有所不同。
陈述“$\mathbb{N}$ 当且仅当 $\unit$”只告诉我们，当被视为一个纯粹的命题时，类型 $\mathbb{N}$ 表示与 $\unit$ 相同的命题（在这种情况下，是真命题）。
我们有时会通过说 $A$ 和 $B$ 是\define{逻辑等价}的来表达“$A$ 当且仅当 $B$”。
\indexdef{logical equivalence}%
\indexdef{equivalence!logical}%
这与将在 \cref{sec:basics-equivalences,cha:equivalences} 中引入的更强的“类型等价”的概念有所不同：尽管 $\mathbb{N}$ 和 $\unit$ 逻辑等价，但它们不是等价类型。

在 \cref{cha:logic} 中，我们将引入一类称为“纯命题”的类型，对于这些类型，等价性和逻辑等价性是一致的。
使用这些类型，我们将引入一种有时适用的逻辑修改，其中析取和存在命题所包含的附加信息将被丢弃。

最后，我们注意到，命题作为类型的对应关系可以反向看待，使我们能够将任何类型 $A$ 视为一个命题，我们通过展示 $A$ 的一个元素来证明它。
有时我们会声明该命题为“$A$ 是\define{可居住的}”。
\indexdef{inhabited type}%
\indexsee{type!inhabited}{inhabited type}%
也就是说，当我们说 $A$ 是可居住的时，我们的意思是我们已经给出了一个（特定的）$A$ 的元素，但我们选择不为该元素命名。
同样地，若说 $A$ 是\emph{不可居住的}，则相当于给出了 $\neg A$ 的一个元素。
特别地，空类型 $\emptyt$ 显然是不可居住的，因为 $\neg \emptyt \jdeq (\emptyt \to \emptyt)$ 是由 $\idfunc[\emptyt]$ 居住的。\footnote{这不应与类型论一致性的声明相混淆，这是一种\emph{元理论}声称，即按照类型论的规则，不可能获得 $\emptyt$ 的元素。\indexfoot{consistency}}

\index{proof|)}%
\index{proposition!as types|)}%
\index{logic!propositions as types|)}%
\section{同一类型（Identity types）}
\label{sec:identity-types}

\index{类型!同一|(defstyle}%
\indexsee{同一!类型}{type, identity}%
\indexsee{类型!等同性}{type, identity}%
\indexsee{等同性!类型}{type, identity}%
尽管之前的构造可以被视为标准集合论构造的推广，但我们处理同一性的方法似乎是类型论特有的。根据命题即类型的观点，两个同类型元素 $a,b:A$ 相等的 \emph{命题} 必须对应某种 \emph{类型}。由于这个命题取决于 $a$ 和 $b$ 是什么，这些 \define{等同性类型（equality types）} 或 \define{同一类型（identity types）} 必须是依赖于 $A$ 的两个副本的类型族。

我们可以将这个类型族写作 $\idtypevar{A}:A\to A\to\type$（不要与同一函数 $\idfunc[A]$ 混淆），因此 $\idtype[A]ab$ 是表示 $a$ 和 $b$ 相等命题的类型。一旦我们熟悉了命题即类型的概念，使用标准的等号符号来表示这一点是很方便的；因此“$\id{a}{b}$”也可以作为 \emph{类型} $\idtype[A]ab$ 的记号，对应 $a$ 等于 $b$ 的命题。为了清楚起见，我们还可以写作“$\id[A]{a}{b}$”以明确类型 $A$。如果我们有 $\id[A]{a}{b}$ 的元素，我们可以说 $a$ 和 $b$ 是\define{相等的（equal）}，或者如果我们想强调这与在 \cref{sec:types-vs-sets} 中讨论的判断性相等 $a\jdeq b$ 不同，有时可以称为\define{命题性相等（propositionally equal）}。
\indexdef{等同性!命题性}%
\indexdef{命题性!等同性}%

正如我们在 \cref{sec:pat} 中所提到的，命题即类型版本的“或”与“存在”可以包含比命题为真的事实更多的信息，类型 $\id{a}{b}$ 也可以包含更多信息。实际上，这是同伦解释的基石，在这种解释中，我们将 $\id{a}{b}$ 的见证者视为 $A$ 空间中 $a$ 和 $b$ 之间的\emph{路径（paths）}\indexdef{路径}或\emph{等价（equivalences）}。就像空间中的两个点之间可以有多条路径一样，两个对象相等的见证者也可能不止一个。换句话说，我们可以将 $\id{a}{b}$ 视为 $a$ 和 $b$ 的\emph{同一性（identifications）}\indexdef{同一性}的类型，$a$ 和 $b$ 之间可能有多种不同的同一方式。我们将在 \cref{cha:basics} 中回到这种解释；现在我们专注于同一类型的基本规则。与本章中讨论的所有其他类型一样，它将具有形式上完全相同的构造规则、引入规则、消去规则和计算规则。

构造规则表明，给定一个类型 $A:\UU$ 和两个元素 $a,b:A$，我们可以在相同的宇宙中构造类型 $(\id[A]{a}{b}):\UU$。构造 $\id{a}{b}$ 元素的基本方式是知道 $a$ 和 $b$ 是相同的。因此，引入规则是一个依赖函数
\[\refl{} : \prd{a:A} (\id[A]{a}{a})\]
称为\define{反射性（reflexivity）}，
\indexdef{等同性的!反射性}%
它表明 $A$ 的每个元素都等于其自身（以特定的方式）。我们将 $\refl{a}$ 视为 $a$ 点上的
\define{常量路径（constant path）}\indexdef{路径!常量}\indexsee{环!常量}{path, constant}。

特别地，这意味着如果 $a$ 和 $b$ 是\emph{判断性}相等的，$a\jdeq b$，那么我们也有 $\refl{a} : \id[A]{a}{b}$ 的元素。这是类型良好的，因为 $a\jdeq b$ 意味着类型 $\id[A]{a}{b}$ 也判断性地等于 $\id[A]{a}{a}$，这是 $\refl{a}$ 的类型。

同一类型的归纳原理（即消去规则）是类型论中最微妙的部分之一，并且对同伦解释至关重要。我们首先考虑它的一个重要后果，即“相等的可以替代相等的”原则，如下所述：
\index{相同者的不可辨识性}%
\index{相等的可以替代相等的}%
\begin{description}
\item[相同者的不可辨识性（Indiscernibility of identicals）:]
对于每个类型族
\[
C : A \to \UU
\]
存在一个函数
\[
f : \prd{x,y:A}{p:\id[A] x y} C(x) \to C(y)
\]
使得
\[
f(x,x,\refl{x}) \defeq \idfunc[C(x)]。
\]
\end{description}
这表明每个类型族 $C$ 都尊重等同性，换句话说，将 $C$ 应用于 $A$ 的\emph{相等}元素也会导致这些类型之间的函数。显示的等式表明，与反射性相关联的函数是恒等函数（我们将看到，通常，函数 $f(x,y,p): C(x) \to C(y)$ 总是类型的等价）。

相同者的不可辨识性可以被视为同一类型的递归原理，类似于上面给出的布尔值和自然数的递归原理。就像 $\rec{\nat}$ 为某种特定类型 $C$ 给出了一个指定的映射 $\nat\to C$，相同者的不可辨识性为 $A$ 上的某些反射的二元关系（即形如 $C(x) \to C(y)$ 的关系）给出了从 $\id[A] x y$ 到这些关系的指定映射。我们还可以对更一般的反射关系 $C(x,y)$ 形式提出一个更一般的递归原理。但是，为了完全表征同一类型，我们必须将这一递归原理推广为归纳原理，不仅考虑从 $\id[A] x y$ 出发的映射，还要考虑其上的类型族。换句话说，我们不仅考虑允许相等的替换相等的，还要考虑导致这种相等的证据 $p$。

\subsection{路径归纳（Path induction）}

\index{类型的生成，归纳|(}%
同一类型的归纳原理称为\define{路径归纳（path induction）}，
\index{路径!归纳|(}%
\index{同一类型的归纳原理!归纳|(}%
在 \cref{cha:basics} 的介绍中将解释的同伦解释中，它可以被视为说明同一类型族由形如 $\refl{x}: \id{x}{x}$ 的元素自由生成。

\begin{description}
\item[路径归纳：]
给定一个类型族
\[ C : \prd{x,y:A} (\id[A]{x}{y}) \to \UU \]
和一个函数
\[ c :  \prd{x:A} C(x,x,\refl{x}),\]
存在一个函数
\[ f : \prd{x,y:A}{p:\id[A]{x}{y}} C(x,y,p) \]
使得
\[ f(x,x,\refl{x}) \defeq c(x)。\]
\end{description}

请注意，与乘积、余积、自然数等类型的归纳原理类似，路径归纳允许我们定义\emph{指定的}函数，这些函数表现出适当的计算行为。就像我们有由 $c_0:C$ 和 $c_s:\nat \to C \to C$ 递归定义的\emph{函数} $f:\nat\to C$，其满足 $f(0)\jdeq c_0$ 和 $f(\suc(n))\jdeq c_s(n,f(n))$，我们有由 $c :  \prd{x:A} C(x,x,\refl{x})$ 路径归纳定义的\emph{函数} $f : \dprd{x,y:A}{p:\id[A]{x}{y}} C(x,y,p)$，其满足 $f(x,x,\refl{x}) \jdeq c(x)$。

要理解此原理的含义，首先考虑 $C$ 不依赖于 $p$ 的简单情况。然后我们有 $C:A\to A\to \UU$，可以将其视为依赖于 $A$ 两个元素的谓词。我们对 $C(x,y)$ 在某对 $x,y:A$ 元素上何时为真感兴趣。在这种情况下，路径归纳的假设表明我们知道 $C(x,x)$ 对所有 $x:A$ 为真，即如果我们在对 $(x,x)$ 进行评估，我们得到了一个真命题——因此 $C$ 是一个反射关系。结论告诉我们当 $\id{x}{y}$ 时，$C(x,y)$ 成立。这正是上面提到的关于反射关系的一般递归原理。

归纳规则的通用形式允许 $C$ 也依赖于 $p:\id{x}{y}$ 作为 $x$ 和 $y$ 相等的见证。在前提中，我们不仅将 $x, y$ 替换为 $x,x$，还同时将 $p$ 替换为反射性：要证明某一性质适用于所有 $x,y$ 和连接它们的路径 $p:\id{x}{y}$，只需考虑 $x,x$ 和路径为 $\refl{x}:\id{x}{x}$ 的情况即可。如果我们仅将类型视为集合，那么这对我们并没有多大意义，但由于 $x$ 和 $y$ 之间可能有多种不同的 $p : \id{x}{y}$ 识别，所以在考虑 $\id[A]{x}{y}$ 类型上的族时保留这些信息是有意义的。在 \cref{cha:basics} 中，我们将看到这一点对同伦解释非常重要。

如果我们将路径归纳打包成一个单一的函数，它的形式是：
\symlabel{defn:induction-ML-id}%
\begin{narrowmultline*}
\indid{A} :  \dprd{C : \prd{x,y:A} (\id[A]{x}{y}) \to \UU}
\Parens{\tprd{x:A} C(x,x,\refl{x})} \to
\narrowbreak
\dprd{x,y:A}{p:\id[A]{x}{y}}   C(x,y,p)
\end{narrowmultline*}
满足等式\index{同一类型的计算规则!计算规则}
\[ \indid{A}(C,c,x,x,\refl{x}) \defeq c(x) 。\]
函数 $\indid{A}$ 传统上称为 $J$。
\indexsee{J@$J$}{同一类型的归纳原理}%
我们将在 \cref{lem:transport} 中展示不可辨识性是路径归纳的一个实例，并为其赋予一个新名称和记号。

\mentalpause

给定一个证据 $p : \id{a}{b}$，路径归纳要求我们\emph{同时}用相同的未知元素 $x$ 替换 $a$ 和 $b$；因此为了定义一个类型族 $C$ 的元素，对于 $A$ 的所有相等元素对，只需在对角线定义它即可。然而，在一些证明中，使用等式 $p : \id{a}{b}$ 将 $b$ 的所有出现替换为 $a$（或反之）更为简单，因为有时对等式中提到的特定元素 $a$ 进行证明比对一般未知的 $x$ 进行证明更容易。这激发了同一类型的第二个归纳原理，该原理表明类型族 $\id[A]{a}{x}$ 是由元素 $\refl{a} : \id{a}{a}$ 生成的。如下所示，这个第二归纳原理与第一个是等价的；只是有时是更方便的表达方式。

\index{路径!基于归纳}%
\index{同一类型的归纳原理!基于归纳}%
\begin{description}
\item[基于路径归纳：]
固定一个元素 $a:A$，并假设给定了一个类型族
\[ C : \prd{x:A} (\id[A]{a}{x}) \to \UU \]
和一个元素
\[ c : C(a,\refl{a})。\]
然后我们可以获得一个函数
\[ f : \prd{x:A}{p:\id{a}{x}} C(x,p) \]
使得
\[ f(a,\refl{a}) \defeq c。\]
\end{description}

在这里，$C(x,p)$ 是一个类型族，其中 $x$ 是 $A$ 的元素，$p$ 是同一类型 $\id[A]{a}{x}$ 的元素，对固定的 $a$ 在 $A$ 中。基于路径归纳原理表明，要定义此族的元素适用于所有 $x$ 和 $p$，只需考虑 $x$ 为 $a$ 且 $p$ 为 $\refl{a} : \id{a}{a}$ 的情况即可。

打包成一个函数，基于路径归纳变为：
\symlabel{defn:induction-PM-id}%
\begin{align*}
\indidb{A} :  \dprd{a:A}{C : \prd{x:A} (\id[A]{a}{x}) \to \UU}
C(a,\refl{a}) \to \dprd{x:A}{p : \id[A]{a}{x}} C(x,p)
\end{align*}
满足等式
\[ \indidb{A}(a,C,c,a,\refl{a}) \defeq c。\]
%\[ g(x)(x,\refl{x}) \defeq d(x) \]

下面，我们展示路径归纳和基于路径归纳是等价的。由于这一点，我们有时会松散地将基于路径归纳称为“路径归纳”，依赖读者从证明的形式中推断出是哪一个原理。

\begin{rmk}\label{rmk:the-only-path-is-refl}
直观地说，自然数的归纳原理表示每个自然数要么是 $0$，要么具有形如 $\suc(n)$ 的形式，因此如果我们证明了这些情况（第二种情况带有归纳假设）的某种性质，那么我们就证明了所有自然数的这一性质。同样，$A+B$ 的归纳原理表示每个 $A+B$ 的元素要么是形如 $\inl(a)$，要么是 $\inr(b)$ 的形式，等等。应用此类解读到路径归纳上，我们可以说路径归纳表明每条路径都具有 $\refl{a}$ 的形式，因此如果我们证明了反射路径的某个性质，那么我们就证明了所有路径的这一性质。

然而，这种解读在同伦解释路径的上下文中可能会令人困惑，在同伦解释中，$a$ 和 $b$ 之间可能有多种不同的识别方式，因此同一类型中可能有许多不同的元素！如果可能有许多不同的路径，怎么还能有归纳原理断言唯一的路径是反射的呢？

关键的观察是，归纳定义的不是同一\emph{类型}，而是同一\emph{族}。特别地，路径归纳表明类型族 $(\id[A]{x}{y})$，当 $x,y$ 在 $A$ 中变化时，是由 $\refl{x}$ 形式的元素归纳生成的。这意味着为了给定类型族 $C(x,y,p)$ 的元素，对所有族 $(x,y,p)$ 依赖于族 $(x,y,p)$ 的元素的情况，只需考虑 $(x,x,\refl{x})$ 形式的情况即可。在同伦解释中，这表明所有端点都可变的路径空间对应的空间是自由路径空间，并且事实上任何该空间中的点都同伦于某点的常量环。在类型论中同样成立：我们可以通过路径归纳证明 $\id[\sm{x,y:A}(\id{x}{y})]{(x,y,p)}{(x,x,\refl{x})}$。

同样，基于路径归纳表明，对于固定的 $a:A$，当 $y$ 在 $A$ 中变化时，类型族 $(\id[A]{a}{y})$ 是由 $\refl{a}$ 元素归纳生成的。因此，要定义此族的元素对所有 $y$ 和 $p$ 适用，只需考虑 $(a,\refl{a})$ 的情况即可。同伦地，这表明从某个选定点出发的路径空间（在该点的基于路径空间，类型论上是 $\sm{y:A} (\id{a}{y})$）是可收缩到选定点上的常量环的。同样，在类型论中这一事实也是成立的：我们可以通过基于路径归纳证明 $\id[\sm{y:A}(\id{a}{y})]{(y,p)}{(a,\refl{a})}$。此外，根据 \cref{sec:pat} 中提到的 $\Sigma$ 类型作为子类型的解释，类型 $\sm{y:A}(\id{a}{y})$ 可以视为“所有与 $a$ 相等的 $A$ 元素的类型”，这是一种类型论版本的“单例子集”。

无论是路径归纳还是基于路径归纳，都不能提供一种方法来给定具有两个固定端点 $a$ 和 $b$ 的族 $C(p)$ 的元素。特别地，对于依赖于循环的族 $C: (\id[A]{a}{a}) \to \UU$，我们\emph{不能}应用路径归纳并仅考虑 $C(\refl{a})$ 的情况，因此我们不能证明所有循环都是反射性的。因此，归纳定义同一族并不禁止在特定实例中的非反射性路径。换句话说，路径 $p:\id{x}{x}$ 可能在 $(\id{x}{x})$ 中不等于反射性，但是对 $(x,p)$ 和 $(x,\refl{x})$ 作为 $\sm{y:A}(\id{x}{y})$ 的元素，它们是相等的。

作为拓扑学的一个例子，考虑一个穿孔圆盘中的环（\narrowequation{\setof{ (x,y) | 0 < x^2+y^2 < 2 }}），它从 $(1,0)$ 开始绕 $(0,0)$ 绕行一圈然后回到 $(1,0)$。如果我们将两个端点都固定在 $(1,0)$，这个环就不能在保持在穿孔圆盘中的情况下缩成常量路径，就像将绳子缠绕在杆子上时，如果我们抓住两端，它就不能被拉进来一样。但是，如果我们允许一个端点变化，这个环就可以缩回到常量路径，就像我们只抓住绳子的一端，总是可以将其收回一样。
\end{rmk}

\index{路径!归纳|)}%
\index{同一类型的归纳原理!归纳|)}%
\index{类型的生成，归纳|)}

\subsection{路径归纳与基于路径归纳的等价性}

上面介绍的同一类型的两个归纳原理是等价的。可以很容易地看到，路径归纳可以从基于路径归纳的原理推导出来。事实上，我们假设路径归纳的前提条件：
\begin{align*}
C &: \prd{x,y:A}(\id[A]{x}{y}) \to \UU,\\
c &: \prd{x:A} C(x,x,\refl{x})。
\end{align*}
现在，给定一个元素 $x:A$，我们可以实例化上述两个条件，得到
\begin{align*}
C' &: \prd{y:A} (\id[A]{x}{y}) \to \UU,  \\
C' &\defeq C(x), \\
c' &: C'(x,\refl{x})， \\
c' &\defeq c(x)。
\end{align*}
显然，$C'$ 和 $c'$ 符合基于路径归纳的前提条件，因此我们可以构造
\begin{equation*}
g : \prd{y:A}{p : \id{x}{y}} C'(y,p)
\end{equation*}
并满足等式
\[ g(x,\refl{x}) \defeq c'。\]
现在我们观察到 $g$ 的值域等于 $C(x,y,p)$。因此，解除我们对 $x:A$ 的假设，我们可以推导出一个函数
\[ f : \prd{x,y:A}{p : \id[A]{x}{y}} C(x,y,p) \]
并具有所需的判断等式 $f(x,x,\refl{x}) \judgeq g(x,\refl{x}) \defeq c' \defeq c(x)$。

这个事实的另一种证明是观察到任何此类 $f$ 都可以作为 $\indid{A}$ 的实例，因此只需将 $\indid{A}$ 定义为 $\indidb{A}$ 的形式：
\[ \indid{A}(C,c,x,y,p) \defeq \indidb{A}(x,C(x),c(x),y,p)。\]

另一种方向略显复杂；尚不清楚如何使用路径归纳的特定实例来推导基于路径归纳的特定实例。相反，我们可以构造一个路径归纳的实例，显示基于路径归纳的所有可能实例。定义
\begin{align*}
D &: \prd{x,y:A} (\id[A]{x}{y}) \to \UU， \\
D(x,y,p) &\defeq \prd{C : \prd{z:A} (\id[A]{x}{z}) \to \UU} C(x,\refl{x}) \to C(y,p)。
\end{align*}
然后我们可以构造函数
\begin{align*}
d &: \prd{x : A} D(x,x,\refl{x})， \\
d &\defeq \lamu{x:A}\lamu{C:\prd{z:A}{p : \id[A]{x}{z}} \UU}\lam{c:C(x,\refl{x})} c
\end{align*}
并因此使用路径归纳获得
\[ f : \prd{x,y:A}{p:\id[A]{x}{y}} D(x,y,p) \]
其 $f(x,x,\refl{x}) \defeq d(x)$。展开 $D$ 的定义，我们可以扩展 $f$ 的类型：
\[ f : \prd{x,y:A}{p:\id[A]{x}{y}}{C : \prd{z:A} (\id[A]{x}{z}) \to \UU} C(x,\refl{x}) \to C(y,p)。\]
现在，给定 $a:A$ 以及 $x:A$ 和 $p:\id[A]{a}{x}$，我们可以推导出基于路径归纳的结论：
\[ f(a,x,p,C,c) : C(x,p)。\]
请注意，我们还获得了正确的定义等式。

另一个证明是观察到基于路径归纳的任何使用都是 $\indidb{A}$ 的实例，并定义
\begin{narrowmultline*}
\indidb{A}(a,C,c,x,p) \defeq \narrowbreak
\indid{A}
\begin{aligned}[t]
\big(
&\big(\lamu{x,y:A}{p:\id[A]{x}{y}} \tprd{C : \prd{z:A} (\id[A]{x}{z}) \to \UU} C(x,\refl{x}) \to C(y,p) \big)，\\
&(\lamu{x:A}{C:\prd{z:A} (\id[A]{x}{z}) \to \UU}{d:C(x,\refl{x})} d)，
a, x, p\big)(C, c)。
\end{aligned}
\end{narrowmultline*}

请注意，上述构造使用了宇宙。如果我们想用 $C : \prd{x:A} (\id[A]{a}{x}) \to \UU_i$ 来建模 $\indidb{A}$，我们需要使用 $\indid{A}$，其中
%
\[ D:\prd{x,y:A} (\id[A]{x}{y}) \to \UU_{i+1} \]
%
因为 $D$ 量化了所有给定类型的 $C$。虽然这与我们对宇宙的定义兼容，但也可以在不使用宇宙的情况下推导出 $\indidb{A}$：我们可以展示 $\indid{A}$ 包含了 \cref{lem:transport,thm:contr-paths}，并且这两个原理直接推导了 $\indidb{A}$。我们将细节留给读者作为 \cref{ex:pm-to-ml}。

我们可以使用上述任何形式的同一类型来确定等同性是一种等价关系，每个函数都保留等同性，并且每个族都尊重等同性。我们将细节留到下一章，在同伦类型论的背景下推导和解释。

\begin{rmk}\label{rmk:propeq-vs-jdeq}
我们强调尽管具有一些不熟悉的特征，但命题性等同性是同伦类型论中的\emph{数学等同性}。这种区别不属于判断性等同性，它是类型论规则的一个元理论特征。例如，在 \cref{sec:inductive-types} 中证明的自然数加法的结合律是\emph{命题性}等同性，而不是判断性的。同样地，交换律（\cref{ex:add-nat-commutative}）也是如此。甚至非常简单的交换律 $n+1=1+n$ 对于一般的 $n$ 来说也不是判断性等同性（尽管对于任何特定的 $n$ 来说它是判断性的，例如 $3+1\jdeq 1+3$，因为两者都通过定义 $+$ 的计算规则判断性地等于 $4$）。我们只能通过使用同一类型来证明这些事实，因为我们只能通过类型的归纳原理而不是判断来应用自然数。
\end{rmk}


\subsection{不等性（Disequality）}
\label{sec:disequality}

最后，我们也来讨论一下\define{不等性（disequality）}，
\indexdef{disequality}{不等性}%
它是等式的否定：%
\footnote{我们使用“不等式（inequality）”
来指代 $<$ 和 $\leq$。另外，注意这是 \emph{命题性}（propositional）的等式类型的否定。
当然，否定判断等式 $\jdeq$ 是没有意义的，因为判断不属于逻辑运算的范畴。}
%
\begin{equation*}
(x \neq_A y) \ \defeq\ \lnot (\id[A]{x}{y}).
\end{equation*}
如果 $x \neq y$，我们说 $x$ 和 $y$ \define{不相等（unequal）}
\indexdef{unequal}{不相等}%
或者 \define{不等（not equal）}。
%
与否定一样，不等性在这里的作用比在经典\index{mathematics!classical}{数学!经典}数学中要小。比如，我们不能通过证明两个东西不等来证明它们相等：这将是双重否定律的一个应用，参见 \cref{sec:intuitionism}。

有时，将不等性以一种正面的方式表达是有用的。例如，
在~\cref{RD-inverse-apart-0}中，我们将证明一个实数 $x$ 存在逆元当且仅当它与 $0$ 的距离为正，这比 $x \neq 0$ 的要求更强。

\index{type!identity|)}{类型!等式|）}%

\sectionNotes

这里介绍的类型论是 Martin-L\"{o}f 直觉主义类型论（Martin-L\"{o}f's intuitionistic type
theory）~\cite{Martin-Lof-1972,Martin-Lof-1973,Martin-Lof-1979,martin-lof:bibliopolis}的一个版本，它本身基于并受到 Brouwer \cite{beeson}, Heyting~\cite{heyting1966intuitionism}, Scott~\cite{scott70}, de
Bruijn~\cite{deBruijn-1973}, Howard~\cite{howard:pat}, Tait~\cite{Tait-1966,Tait-1968}, 和 Lawvere~\cite{lawvere:adjinfound}\index{Lawvere}的基础性工作的影响。
\index{proof!assistant}{证明!助手}%
Martin-L\"{o}f 的类型论有三个主要变种，它们分别在 \NuPRL \cite{constable+86nuprl-book}, \Coq~\cite{Coq}, 和
\Agda \cite{norell2007towards} 计算机实现的类型论中得以体现。这里介绍的理论在许多方面与这些变体有所不同，其中一些差异对于同伦解释至关重要，而另一些则是技术上的便利或涉及尚未在同伦环境中研究的概念。

\index{type theory!intensional}{类型论!内涵}%
\index{type theory!extensional}{类型论!外延}%
\index{intensional type theory}{内涵类型论}%
\index{extensional!type theory}{外延!类型论}%
最重要的是，这里描述的类型论源自 Martin-L\"{o}f 内涵类型论（\emph{intensional} version of Martin-L\"{o}f's type
theory）~\cite{Martin-Lof-1973}，而不是外延版本（\emph{extensional} version）~\cite{Martin-Lof-1979}。在外延理论中，判断等式和命题等式没有区别，而在内涵理论中，判断等式被认为是纯定义的，并允许对等式类型进行更广泛、与证明相关的解释，这对于同伦解释至关重要。从同伦的角度来看，外延类型论仅限于同伦离散集（见 \cref{sec:basics-sets}），而内涵理论则允许具有高维结构的类型。 \NuPRL 系统~\cite{constable+86nuprl-book}是外延的，而 \Coq~\cite{Coq} 和 \Agda~\cite{norell2007towards} 是内涵的。在内涵类型论中，不同的变体在身份证明的结构上有所不同。我们在此依赖的最自由解释允许对等式进行\emph{与证明相关的}解释，而更严格的变体则施加了\emph{唯一身份证明（uniqueness of identity proofs, UIP）}~\cite{Streicher93},
\indexsee{UIP}{唯一身份证明（uniqueness of identity proofs）}%
\index{uniqueness!of identity proofs}{唯一!身份证明}%
即任何两个等式的证明在判断上是相等的，和\emph{Axiom K}~\cite{Streicher93}，
\index{axiom!Streicher's Axiom K}{公理!Streicher的Axiom K}
即唯一的等式证明是反身性（up to judgmental equality）。这些额外的要求可以在 \Coq 和 \Agda 系统中选择性地施加。

%(In the terminology of \cref{cha:hlevels} such a type theory is about $0$-truncated types.)

在内涵理论之间的另一个变异点是判断等式的强度，特别是关于函数类型的对象。我们在此包括唯一性原则\index{uniqueness!principle}{唯一性!原则}（$\eta$-转换）$f \jdeq \lam{x} f(x)$，作为判断等式的一个原则。例如，该原则用于 \cref{sec:univalence-implies-funext} 中，表明一致性蕴含了命题函数扩展性。对于其他类型，有时也会考虑唯一性原则。
例如，笛卡尔积 $A\times B$ 的唯一性原则\index{uniqueness!principle!for product types}{唯一性!原则!对于积类型} 将是命题等式 $\uniq{A\times B}$ 的一个判断版本，我们在 \cref{sec:finite-product-types} 中构造了它，表示 $u \jdeq (\proj1(u),\proj2(u))$。
这和对于依赖对的相应版本将是合理的选择（我们并没有做出这个选择），但我们不能包括所有这些规则，因为身份类型的唯一性原则会使所有更高的同伦结构变得平凡。因此，我们\emph{不得不}将其排除在外，问题随后变成了在哪些地方划清界限。关于归纳类型，我们在~\cref{sec:htpy-inductive}中进一步讨论了这些要点。

对于诸如乘积、$\Sigma$-类型、并集、自然数等归纳类型（见 \cref{cha:induction}），在归纳和递归的表述上有额外的选择。
\index{pattern matching}{模式匹配}%
我们将\emph{归纳原则}作为基础，并从中导出\emph{模式匹配}，但也可以采用相反的做法；见 \cref{cha:rules}。
通常在后一种情况下，还允许\emph{深度}模式匹配；见~\cite{Coquand92Pattern}。
我们选择的原因有几个。
其中一个原因是，在范畴语义学中，我们自然获得的是归纳原则。
另一个原因是，指定允许的（深度）模式匹配类型是相当棘手的；
例如，\Agda的
\index{proof!assistant!Agda@\textsc{Agda}}{证明!助手!Agda@\textsc{Agda}}%
模式匹配可以默认证明 Axiom K，
\index{axiom!Streicher's Axiom K}{公理!Streicher的Axiom K}%
尽管 \texttt{--without-K} 标志可以阻止这一点~\cite{CDP14}。
最后，深度模式匹配对于\emph{更高}的归纳类型（见 \cref{cha:hits}）还没有得到充分理解。
因此，我们将仅使用\cref{sec:pattern-matching}中描述的那些直接等同于应用归纳原则的模式匹配。

\index{proof!assistant!Coq@\textsc{Coq}}{证明!助手!Coq@\textsc{Coq}}%
与 \Coq 的类型论不同，我们没有包括一个原始的命题类型。相反，如\cref{sec:pat}所述，我们采纳了\emph{命题即类型（propositions-as-types, PAT）}原则，将命题与类型等同。
这最早由 de Bruijn~\cite{deBruijn-1973}、Howard~\cite{howard:pat}、Tait~\cite{Tait-1968} 和 Martin-L\"{o}f~\cite{Martin-Lof-1972} 提出。
（我们的决定在\cref{subsec:pat?,subsec:hprops}中得到了更充分的解释。）

不过，我们确实包括了一个完整的累积层次的宇宙（universe），因此类型形成和等式判断变成了宇宙成员关系和等式判断的实例。
为了方便起见，我们将宇宙的对象视为类型，而不是类型的代码；在\cite{martin-lof:bibliopolis}的术语中，这意味着我们使用“Russell 风格的宇宙（Russell-style universes）”而不是“Tarski 风格的宇宙（Tarski-style universes）”。
\index{type!universe!Tarski-style}{类型!宇宙!Tarski风格}%
\index{type!universe!Russell-style}{类型!宇宙!Russell风格}%
另一种选择是使用 Tarski 风格的宇宙，要求显式强制函数\index{coercion, universe-raising}{强制, 宇宙提升}将一个宇宙的元素 $A:\UU$ 转化为一个类型 $\mathsf{El}(A)$，并在非正式操作时忽略强制。

我们还将宇宙层次视为累积的，即 $\UU_i$ 中的每个类型也是 $\UU_j$ 中的一个类型，对于每个 $j\geq i$。
有多种方式可以形式化地实现累积性：最简单的是包括一个规则，即如果 $A:\UU_i$ 那么 $A:\UU_j$。
然而，这会带来一个恼人的后果，即对于一个类型族 $B:A\to \UU_i$ 我们不能得出 $B:A\to\UU_j$，尽管我们可以得出 $\lam{a} B(a) : A\to\UU_j$。
更复杂的解决方案是引入一个判断上的子类型关系 $<:$，由 $\UU_i<:\UU_j$ 生成，但这使得类型论的研究更加复杂。
另一种选择是包括一个显式的强制函数 $\uparrow : \UU_i \to \UU_j$，在非正式操作时可以省略。

也不必要将宇宙按照自然数进行索引并线性排序。
对于某些用途，假设每个宇宙都是某个更大宇宙的一个元素，同时具有“定向性”属性，即任何两个宇宙都共同包含在某个更大的宇宙中是更为适当的。
还有许多其他可能的变化，例如包括一个包含所有 $\UU_i$ 的宇宙“$\UU_{\omega}$”（甚至更高的“巨基数”类型宇宙），或者将层次内部化为类型族 $\lam{i} \UU_i$。
后者实际上在 \Agda 中得到了应用。

身份类型的路径归纳原则由 Martin-L\"{o}f~\cite{Martin-Lof-1973} 提出。
在 Martin-L\"{o}f 类型论设置中，基于路径的归纳规则由 Paulin-Mohring \cite{Moh93} 提出；它可以看作是 \NuPRL~\cite[Section~8.1]{constable+86nuprl-book}中假设性判断的“逐点功能性（pointwise functionality）”概念的内涵推广。
Streicher 使用 Axiom K 证明了 Martin-L\"{o}f 的规则蕴含了 Paulin-Mohring 的规则（见~\cref{sec:hedberg}），Altenkirch 和 Goguen 如 \cref{sec:identity-types} 中所述进行了证明，最后 Hofmann 在没有宇宙的情况下进行了证明（如 \cref{ex:pm-to-ml}）；见~\cite[\S1.3 and Addendum]{Streicher93}。

\sectionExercises

\begin{ex}\label{ex:composition}
给定函数 $f:A\to B$ 和 $g:B\to C$，定义它们的\define{复合（composite）}
\indexdef{composition!of functions}{复合!函数的}%
\indexdef{function!composition}{函数!复合}%
$g\circ f:A\to C$。
\index{associativity!of function composition}{复合函数的结合性}%
证明我们有 $h \circ (g\circ f) \jdeq (h\circ g)\circ f$。
\end{ex}

\begin{ex}\label{ex:pr-to-rec}
仅使用投影推导乘积的递归原则 $\rec{A\times B} $，并验证定义等式是有效的。
对 $\Sigma$ 类型做同样的操作。
\end{ex}

\begin{ex}\label{ex:pr-to-ind}
仅使用投影和命题唯一性原则 $\uniq{A\times B}$，推导乘积的归纳原则 $\ind{A\times B}$。
验证定义等式是有效的。
将 $\uniq{A\times B}$ 推广到 $\Sigma$ 类型，并对 $\Sigma$ 类型做同样的操作。
\emph{（这需要 \cref{cha:basics} 中的概念。）}
\end{ex}

\begin{ex}\label{ex:iterator}
\index{iterator!for natural numbers}{迭代器!自然数的}
假设仅给定自然数的\emph{迭代器（iterator）}
\[\ite : \prd{C:\UU} C \to (C \to C) \to \nat \to C \]
其定义方程为
\begin{align*}
\ite(C,c_0,c_s,0)  &\defeq c_0, \\
\ite(C,c_0,c_s,\suc(n)) &\defeq c_s(\ite(C,c_0,c_s,n)),
\end{align*}
推导出具有递归器 $\rec{\nat}$ 类型的函数。
使用 $\nat$ 的归纳原则证明该函数的定义方程命题上成立。
\end{ex}

\begin{ex}\label{ex:sum-via-bool}
\index{type!coproduct}{类型!并集}%
证明如果我们定义 $A + B \defeq \sm{x:\bool} \rec{\bool}(\UU,A,B,x)$，那么我们可以给出 $\ind{A+B}$ 的定义，使得 \cref{sec:coproduct-types} 中陈述的定义等式成立。
\end{ex}

\begin{ex}\label{ex:prod-via-bool}
\index{type!product}{类型!乘积}%
证明如果我们定义 $A \times B \defeq \prd{x:\bool}\rec{\bool}(\UU,A,B,x)$，那么我们可以给出 $\ind{A\times B}$ 的定义，使得 \cref{sec:finite-product-types} 中陈述的定义等式命题上成立（即使用等式类型）。
\emph{（这需要在 \cref{sec:compute-pi} 中引入的函数扩展性公理（function extensionality axiom）。）}
\end{ex}

\begin{ex}\label{ex:pm-to-ml}
给出从 $\indidb{A}$ 到 $\indid{A}$ 的另一种推导，避免使用宇宙。
\emph{（使用后续章节中的概念最为容易。）}
\end{ex}

\begin{ex}\label{ex:nat-semiring}
\index{multiplication!of natural numbers}{自然数的乘法}%
使用 $\rec{\nat}$ 定义乘法和指数运算。
使用仅有的 $\ind{\nat}$ 验证 $(\nat,+,0,\times,1)$ 是一个半环\index{semiring}{半环}。
你可能还需要使用等式的对称性和传递性，\cref{lem:opp,lem:concat}。
\end{ex}

\begin{ex}\label{ex:fin}
\index{finite!sets, family of}{有限!集合，族的}%
定义 \cref{sec:universes} 结尾处提到的类型族 $\Fin : \nat \to \UU$，以及在 \cref{sec:pi-types} 中提到的依赖函数 $\fmax : \prd{n:\nat} \Fin(n+1)$。
\end{ex}

\begin{ex}\label{ex:ackermann}
\indexdef{function!Ackermann}{函数!Ackermann}%
\indexdef{Ackermann function}{Ackermann函数}%
证明 Ackermann 函数 $\ack : \nat \to \nat \to \nat$ 可以仅使用 $\rec{\nat}$ 定义，并满足以下方程：
\begin{align*}
\ack(0,n) &\jdeq \suc(n), \\
\ack(\suc(m),0) &\jdeq \ack(m,1), \\
\ack(\suc(m),\suc(n)) &\jdeq \ack(m,\ack(\suc(m),n)).
\end{align*}
\end{ex}

\begin{ex}\label{ex:neg-ldn}
证明对于任意类型 $A$，我们有 $\neg\neg\neg A \to \neg A$。
\end{ex}

\begin{ex}\label{ex:tautologies}
使用命题即类型的解释，推导出以下恒真式：
\begin{enumerate}
\item 如果 $A$，那么（如果 $B$ 则 $A$）。
\item 如果 $A$，则非（非 $A$）。
\item 如果（非 $A$ 或 非 $B$），则非（$A$ 且 $B$）。
\end{enumerate}
\end{ex}

\begin{ex}\label{ex:not-not-lem}
使用命题即类型的解释，推导出排中律的双重否定，即证明 \emph{非（非（$P$ 或 非 $P$））}。
\end{ex}

\begin{ex}\label{ex:without-K}
为什么身份类型的归纳原则不允许我们构造一个函数 $f: \prd{x:A}{p:\id{x}{x}} (\id{p}{\refl{x}})$ 并满足定义方程
\[ f(x,\refl{x}) \defeq \refl{\refl{x}} \quad ?\]
\end{ex}

\begin{ex}\label{ex:subtFromPathInd}
证明从路径归纳推导出不可辨别性。
\end{ex}

\begin{ex}\label{ex:add-nat-commutative}
证明自然数加法是交换的：$\prd{i,j:\nat} (i+j=j+i)$。
\end{ex}

% Local Variables:
% TeX-master: "hott-online"
% End:
